{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"path\"","webpack:///../jsii-kernel/node_modules/graceful-fs/graceful-fs.js","webpack:///external \"fs\"","webpack:///../jsii-kernel/node_modules/universalify/index.js","webpack:///../jsii-kernel/node_modules/fs-extra/lib/mkdirs/index.js","webpack:///../jsii-kernel/node_modules/fs-extra/lib/path-exists/index.js","webpack:///../jsii-kernel/node_modules/tar/lib/buffer.js","webpack:///../jsii-spec/node_modules/jsonschema/lib/helpers.js","webpack:///../jsii-kernel/node_modules/tar/lib/high-level-opt.js","webpack:///../jsii-kernel/node_modules/minipass/index.js","webpack:///../jsii-kernel/node_modules/tar/lib/header.js","webpack:///../jsii-kernel/node_modules/fs-minipass/index.js","webpack:///api.ts","webpack:///external \"assert\"","webpack:///../jsii-kernel/node_modules/fs-extra/lib/util/stat.js","webpack:///../jsii-kernel/node_modules/fs-extra/lib/remove/index.js","webpack:///external \"events\"","webpack:///../jsii-kernel/node_modules/tar/lib/read-entry.js","webpack:///../jsii-kernel/node_modules/tar/lib/types.js","webpack:///../jsii-kernel/node_modules/tar/lib/parse.js","webpack:///../jsii-kernel/node_modules/fs-extra/lib/json/jsonfile.js","webpack:///external \"url\"","webpack:///../jsii-spec/node_modules/jsonschema/lib/scan.js","webpack:///../jsii-kernel/node_modules/tar/lib/pack.js","webpack:///../jsii-kernel/node_modules/yallist/yallist.js","webpack:///../jsii-kernel/node_modules/tar/lib/pax.js","webpack:///../jsii-kernel/node_modules/tar/lib/warn-mixin.js","webpack:///../jsii-kernel/node_modules/tar/lib/list.js","webpack:///../jsii-kernel/node_modules/fs-extra/lib/fs/index.js","webpack:///../jsii-kernel/node_modules/fs-extra/lib/copy-sync/index.js","webpack:///../jsii-kernel/node_modules/fs-extra/lib/mkdirs/win32.js","webpack:///../jsii-kernel/node_modules/fs-extra/lib/util/utimes.js","webpack:///external \"os\"","webpack:///../jsii-kernel/node_modules/fs-extra/lib/copy/index.js","webpack:///index.ts","webpack:///../jsii-kernel/node_modules/safe-buffer/index.js","webpack:///external \"buffer\"","webpack:///../jsii-kernel/node_modules/minizlib/index.js","webpack:///../jsii-kernel/node_modules/tar/lib/write-entry.js","webpack:///../jsii-kernel/node_modules/tar/lib/winchars.js","webpack:///../jsii-kernel/node_modules/tar/lib/replace.js","webpack:///../jsii-kernel/node_modules/tar/lib/unpack.js","webpack:///objects.ts","webpack:///program.ts","webpack:///host.ts","webpack:///kernel.ts","webpack:///(webpack)/buildin/module.js","webpack:///../jsii-kernel/node_modules/fs-extra/lib/index.js","webpack:///../jsii-kernel/node_modules/graceful-fs/polyfills.js","webpack:///external \"constants\"","webpack:///../jsii-kernel/node_modules/graceful-fs/legacy-streams.js","webpack:///external \"stream\"","webpack:///../jsii-kernel/node_modules/graceful-fs/clone.js","webpack:///external \"util\"","webpack:///../jsii-kernel/node_modules/fs-extra/lib/copy-sync/copy-sync.js","webpack:///../jsii-kernel/node_modules/fs-extra/lib/mkdirs/mkdirs.js","webpack:///../jsii-kernel/node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js","webpack:///../jsii-kernel/node_modules/fs-extra/lib/util/buffer.js","webpack:///../jsii-kernel/node_modules/fs-extra/lib/copy/copy.js","webpack:///../jsii-kernel/node_modules/fs-extra/lib/empty/index.js","webpack:///../jsii-kernel/node_modules/fs-extra/lib/remove/rimraf.js","webpack:///../jsii-kernel/node_modules/fs-extra/lib/ensure/index.js","webpack:///../jsii-kernel/node_modules/fs-extra/lib/ensure/file.js","webpack:///../jsii-kernel/node_modules/fs-extra/lib/ensure/link.js","webpack:///../jsii-kernel/node_modules/fs-extra/lib/ensure/symlink.js","webpack:///../jsii-kernel/node_modules/fs-extra/lib/ensure/symlink-paths.js","webpack:///../jsii-kernel/node_modules/fs-extra/lib/ensure/symlink-type.js","webpack:///../jsii-kernel/node_modules/fs-extra/lib/json/index.js","webpack:///../jsii-kernel/node_modules/jsonfile/index.js","webpack:///../jsii-kernel/node_modules/fs-extra/lib/json/output-json.js","webpack:///../jsii-kernel/node_modules/fs-extra/lib/json/output-json-sync.js","webpack:///../jsii-kernel/node_modules/fs-extra/lib/move-sync/index.js","webpack:///../jsii-kernel/node_modules/fs-extra/lib/move-sync/move-sync.js","webpack:///../jsii-kernel/node_modules/fs-extra/lib/move/index.js","webpack:///../jsii-kernel/node_modules/fs-extra/lib/move/move.js","webpack:///../jsii-kernel/node_modules/fs-extra/lib/output/index.js","webpack:///assembly.ts","webpack:///name-tree.ts","webpack:///validate-assembly.ts","webpack:///../jsii-spec/node_modules/jsonschema/lib/index.js","webpack:///../jsii-spec/node_modules/jsonschema/lib/validator.js","webpack:///../jsii-spec/node_modules/jsonschema/lib/attribute.js","webpack:///../jsii-kernel/node_modules/tar/index.js","webpack:///../jsii-kernel/node_modules/tar/lib/create.js","webpack:///../jsii-kernel/node_modules/yallist/iterator.js","webpack:///external \"string_decoder\"","webpack:///external \"zlib\"","webpack:///../jsii-kernel/node_modules/minizlib/constants.js","webpack:///../jsii-kernel/node_modules/tar/lib/large-numbers.js","webpack:///../jsii-kernel/node_modules/tar/lib/mode-fix.js","webpack:///../jsii-kernel/node_modules/tar/lib/update.js","webpack:///../jsii-kernel/node_modules/tar/lib/extract.js","webpack:///../jsii-kernel/node_modules/tar/lib/mkdir.js","webpack:///../jsii-kernel/node_modules/mkdirp/index.js","webpack:///../jsii-kernel/node_modules/chownr/chownr.js","webpack:///external \"crypto\"","webpack:///external \"vm\"","webpack:///serialization.ts","webpack:///external \"module\"","webpack:///in-out.ts","webpack:///sync-stdio.ts"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;AClFA,iC;;;;;;ACAA,SAAS,mBAAO,CAAC,CAAI;AACrB,gBAAgB,mBAAO,CAAC,EAAgB;AACxC,aAAa,mBAAO,CAAC,EAAqB;AAC1C,YAAY,mBAAO,CAAC,EAAY;;AAEhC;;AAEA,WAAW,mBAAO,CAAC,EAAM;;AAEzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI,mBAAO,CAAC,EAAQ;AACpB,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH,EAAE;;AAEF,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtRA,+B;;;;;;;ACAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG,WAAW,iBAAiB;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG,WAAW,iBAAiB;AAC/B;;;;;;;;ACxBY;AACZ,UAAU,mBAAO,CAAC,CAAc;AAChC,iBAAiB,mBAAO,CAAC,EAAU;AACnC,mBAAmB,mBAAO,CAAC,EAAe;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACbY;AACZ,UAAU,mBAAO,CAAC,CAAc;AAChC,WAAW,mBAAO,CAAC,EAAO;;AAE1B;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACXY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,mBAAO,CAAC,EAAa;AAC3B;AACA;;;;;;;;ACVa;;AAEb,UAAU,mBAAO,CAAC,EAAK;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,2DAA2D;AAC3D;AACA,CAAC,EAAE;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,eAAe;AAClB,WAAW;AACX,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,EAAE,WAAW,EAAE,QAAQ,EAAE;AAC7C,eAAe,EAAE,WAAW,EAAE,QAAQ,EAAE;AACxC;;AAEA,iDAAiD,IAAI,yCAAyC,IAAI,iDAAiD,KAAK,kDAAkD,KAAK,iCAAiC,IAAI,sBAAsB,EAAE,WAAW,IAAI;AAC3R,iEAAiE,EAAE;AACnE,8BAA8B,IAAI,GAAG,EAAE,aAAa,IAAI,mBAAmB,IAAI,GAAG,EAAE,cAAc,IAAI,yEAAyE,EAAE,oBAAoB,IAAI,GAAG,EAAE,gBAAgB,IAAI,EAAE,IAAI,2EAA2E,EAAE,oBAAoB,IAAI,GAAG,EAAE,gBAAgB,IAAI,EAAE,IAAI,iBAAiB,IAAI,2EAA2E,EAAE,qBAAqB,IAAI,GAAG,EAAE,gBAAgB,IAAI,EAAE,IAAI,iBAAiB,IAAI,EAAE,IAAI,yEAAyE,EAAE,qBAAqB,IAAI,GAAG,EAAE,gBAAgB,IAAI,EAAE,IAAI,iBAAiB,IAAI,EAAE,IAAI,yEAAyE,EAAE,qBAAqB,IAAI,GAAG,EAAE,gBAAgB,IAAI,EAAE,IAAI,iBAAiB,IAAI,EAAE,IAAI,yEAAyE,EAAE,yBAAyB,IAAI,EAAE,IAAI,iBAAiB,IAAI,EAAE,IAAI,yEAAyE,EAAE;AACjjC;;AAEA,6BAA6B,EAAE,EAAE,IAAI;;AAErC;AACA,qBAAqB,MAAM,kCAAkC,KAAK,kDAAkD,KAAK;AACzH,sBAAsB,MAAM,kCAAkC,KAAK,kDAAkD,KAAK;;AAE1H;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH,4BAA4B,IAAI;AAChC,2BAA2B,KAAK;AAChC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;ACnUY;;AAEZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AC5BY;AACZ,WAAW,mBAAO,CAAC,EAAQ;AAC3B,gBAAgB,mBAAO,CAAC,EAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAO,CAAC,EAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,mBAAO,CAAC,EAAa;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB;;AAEvB,mBAAmB;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB;AACxB,eAAe;AACf;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0BAA0B;;AAE1D;AACA,gCAAgC,aAAa;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kCAAkC;AACnD;AACA;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,YAAY;AACZ;AACA;;;;;;;;ACtXY;AACZ;AACA;AACA;AACA;;AAEA,eAAe,mBAAO,CAAC,CAAa;AACpC,cAAc,mBAAO,CAAC,EAAY;AAClC,mBAAmB,mBAAO,CAAC,CAAM;AACjC,cAAc,mBAAO,CAAC,EAAoB;;AAE1C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,eAAe;AACpC;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,eAAe;AACpC;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AChSY;AACZ,iBAAiB,mBAAO,CAAC,CAAU;AACnC,WAAW,mBAAO,CAAC,EAAQ;AAC3B,WAAW,mBAAO,CAAC,CAAI;;AAEvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb,eAAe;;AAEf;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa;AACb,eAAe;;AAEf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;ACjYa,iBAAS,GAAG,aAAa,CAAC;AAC1B,kBAAU,GAAG,YAAY,CAAC;AAC1B,kBAAU,GAAG,YAAY,CAAC;AAMvC,SAAgB,QAAQ,CAAC,KAAU;IAC/B,OAAO,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,KAAK,IAAI,IAAI,iBAAS,IAAI,KAAK,CAAC;AAC7E,CAAC;AAFD,4BAEC;AAMD,SAAgB,UAAU,CAAC,KAAU;IACjC,OAAO,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,KAAK,IAAI,IAAI,kBAAU,IAAI,KAAK,CAAC;AAC9E,CAAC;AAFD,gCAEC;AAMD,SAAgB,UAAU,CAAC,KAAU;IACjC,OAAO,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,KAAK,IAAI,IAAI,kBAAU,IAAI,KAAK,CAAC;AAC9E,CAAC;AAFD,gCAEC;AASD,SAAgB,gBAAgB,CAAC,KAAe;IAC5C,OAAQ,KAAa,CAAC,MAAM,IAAI,IAAI,CAAC,CAAE,uBAAuB;AAClE,CAAC;AAFD,4CAEC;AAOD,SAAgB,kBAAkB,CAAC,KAAe;IAC9C,OAAQ,KAAa,CAAC,QAAQ,IAAI,IAAI,CAAC,CAAE,uBAAuB;AACpE,CAAC;AAFD,gDAEC;;;;;;;AC9CD,mC;;;;;;;ACAY;;AAEZ,WAAW,mBAAO,CAAC,CAAa;AAChC,aAAa,mBAAO,CAAC,CAAM;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,eAAe;AACjC;AACA,qBAAqB,eAAe;AACpC;AACA,sDAAsD,0BAA0B;AAChF;AACA;AACA,yBAAyB,oBAAoB;AAC7C,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA,sDAAsD,0BAA0B;AAChF;AACA;AACA,yBAAyB,oBAAoB;AAC7C,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,gCAAgC,eAAe;AAC/C,GAAG;AACH;AACA;AACA;AACA;AACA,oCAAoC,eAAe;AACnD,KAAK;AACL;AACA;AACA,GAAG;AACH,uCAAuC;AACvC;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oBAAoB;AACzC,GAAG;AACH;;AAEA;AACA,SAAS,oBAAoB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,eAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,eAAe;AACzD,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,SAAS,IAAI,IAAI,kCAAkC,KAAK;AAC3E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3KY;;AAEZ,UAAU,mBAAO,CAAC,CAAc;AAChC,eAAe,mBAAO,CAAC,EAAU;;AAEjC;AACA;AACA;AACA;;;;;;;ACRA,mC;;;;;;;ACAY;AACZ,cAAc,mBAAO,CAAC,EAAY;AAClC,iBAAiB,mBAAO,CAAC,CAAU;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7FY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;AC3CY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,mBAAO,CAAC,EAAiB;AACxC,aAAa,mBAAO,CAAC,CAAM;AAC3B,eAAe,mBAAO,CAAC,EAAa;AACpC,WAAW,mBAAO,CAAC,EAAQ;AAC3B,gBAAgB,mBAAO,CAAC,EAAS;AACjC;AACA,cAAc,mBAAO,CAAC,EAAiB;AACvC,YAAY,mBAAO,CAAC,EAAU;AAC9B,aAAa,mBAAO,CAAC,EAAU;AAC/B,eAAe,mBAAO,CAAC,CAAa;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+CAA+C;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;ACtaW;;AAEZ,UAAU,mBAAO,CAAC,CAAc;AAChC,iBAAiB,mBAAO,CAAC,EAAU;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACXA,gC;;;;;;;ACCA,aAAa,mBAAO,CAAC,EAAK;AAC1B,cAAc,mBAAO,CAAC,CAAW;;AAEjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzEY;;AAEZ,eAAe,mBAAO,CAAC,CAAa;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,CAAU;AACnC,aAAa,mBAAO,CAAC,EAAU;AAC/B,kBAAkB,mBAAO,CAAC,EAAiB;AAC3C,mBAAmB,mBAAO,CAAC,EAAkB;AAC7C;AACA;AACA,gBAAgB,mBAAO,CAAC,EAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,mBAAO,CAAC,CAAI;AACvB,aAAa,mBAAO,CAAC,CAAM;AAC3B,eAAe,mBAAO,CAAC,EAAiB;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;;;;;;;;ACnZY;AACZ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH,yCAAyC,OAAO;AAChD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC,iBAAiB;AACtD;AACA;AACA;AACA;;AAEA;AACA;AACA,mDAAmD,iBAAiB;AACpE;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,0BAA0B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,0BAA0B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;;AAEA,+BAA+B,iBAAiB;AAChD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qCAAqC,iBAAiB;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC,iBAAiB;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,6BAA6B;AAClE;AACA;AACA,QAAQ,2BAA2B;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,2BAA2B;AAC1E;AACA;AACA,QAAQ,6BAA6B;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,EAAE,mBAAO,CAAC,EAAe;AACzB,CAAC;;;;;;;;ACvXW;AACZ,eAAe,mBAAO,CAAC,CAAa;AACpC,eAAe,mBAAO,CAAC,EAAa;AACpC,aAAa,mBAAO,CAAC,CAAM;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,SAAS;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA,+BAA+B,gBAAgB;AAC/C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACjJY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACbY;;AAEZ,eAAe,mBAAO,CAAC,CAAa;;AAEpC;AACA;;AAEA;AACA,YAAY,mBAAO,CAAC,CAAqB;AACzC,eAAe,mBAAO,CAAC,EAAY;AACnC,WAAW,mBAAO,CAAC,CAAI;AACvB,YAAY,mBAAO,CAAC,EAAa;AACjC,aAAa,mBAAO,CAAC,CAAM;;AAE3B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,WAAW,mBAAmB;AAC9B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;;;;;;;;ACjIY;AACZ;AACA;AACA,UAAU,mBAAO,CAAC,CAAc;AAChC,WAAW,mBAAO,CAAC,CAAa;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;;;;;;;;AC5GY;;AAEZ;AACA,YAAY,mBAAO,CAAC,EAAa;AACjC;;;;;;;;ACJY;;AAEZ,aAAa,mBAAO,CAAC,CAAM;;AAE3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACxBY;;AAEZ,WAAW,mBAAO,CAAC,CAAa;AAChC,WAAW,mBAAO,CAAC,EAAI;AACvB,aAAa,mBAAO,CAAC,CAAM;;AAE3B,YAAY,IAAI;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC9EA,+B;;;;;;;ACAY;;AAEZ,UAAU,mBAAO,CAAC,CAAc;AAChC;AACA,UAAU,mBAAO,CAAC,EAAQ;AAC1B;;;;;;;;;;;;;ACLA,kCAA2B;AAC3B,kCAA4B;AAC5B,kCAAoC;;;;;;;ACFpC;AACA,aAAa,mBAAO,CAAC,EAAQ;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC/DA,mC;;;;;;;ACAY;;AAEZ,eAAe,mBAAO,CAAC,EAAQ;AAC/B,eAAe,mBAAO,CAAC,EAAQ;AAC/B,iBAAiB,mBAAO,CAAC,EAAM;;AAE/B,sCAAsC,mBAAO,CAAC,EAAgB;AAC9D,iBAAiB,mBAAO,CAAC,CAAU;;AAEnC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9UY;AACZ,eAAe,mBAAO,CAAC,CAAa;AACpC,iBAAiB,mBAAO,CAAC,CAAU;AACnC,YAAY,mBAAO,CAAC,EAAU;AAC9B,eAAe,mBAAO,CAAC,EAAa;AACpC,kBAAkB,mBAAO,CAAC,EAAiB;AAC3C,WAAW,mBAAO,CAAC,CAAI;AACvB,aAAa,mBAAO,CAAC,CAAM;;AAE3B,cAAc,mBAAO,CAAC,EAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAO,CAAC,EAAiB;AACxC,iBAAiB,mBAAO,CAAC,EAAe;;AAExC,gBAAgB,mBAAO,CAAC,EAAe;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,uCAAuC;AACpE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,aAAa,kBAAkB;AAC/B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACraY;;AAEZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACtBY;AACZ,eAAe,mBAAO,CAAC,CAAa;;AAEpC;AACA,YAAY,mBAAO,CAAC,CAAqB;AACzC,aAAa,mBAAO,CAAC,EAAW;AAChC,cAAc,mBAAO,CAAC,EAAY;AAClC,WAAW,mBAAO,CAAC,CAAI;AACvB,YAAY,mBAAO,CAAC,EAAa;AACjC,UAAU,mBAAO,CAAC,EAAW;AAC7B,aAAa,mBAAO,CAAC,CAAM;;AAE3B;AACA;AACA;AACA;AACA;;AAEA,eAAe,mBAAO,CAAC,EAAa;;AAEpC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gCAAgC,oBAAoB;AACpD,qCAAqC,cAAc;AACnD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA,WAAW,mBAAmB;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;;;;;;;AC3NY;;AAEZ,eAAe,mBAAO,CAAC,EAAQ;AAC/B,WAAW,mBAAO,CAAC,EAAQ;AAC3B,eAAe,mBAAO,CAAC,EAAY;AACnC,WAAW,mBAAO,CAAC,CAAI;AACvB,YAAY,mBAAO,CAAC,EAAa;AACjC,aAAa,mBAAO,CAAC,CAAM;AAC3B,cAAc,mBAAO,CAAC,EAAY;AAClC;AACA,WAAW,mBAAO,CAAC,EAAe;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAO,CAAC,EAAQ;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,mBAAmB;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;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CA;AACA,WAAW,mBAAO,CAAC,CAAI;AACvB;AACA;AACA,YAAY;AACZ,GAAG;AACH;;;;;;;AC3BA,gBAAgB,mBAAO,CAAC,EAAW;;AAEnC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;;AAEA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ,yCAAyC;AACzC;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL,8CAA8C;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AC/UA,sC;;;;;;ACAA,aAAa,mBAAO,CAAC,EAAQ;;AAE7B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB;;AAEA;;AAEA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;;AAEA;;AAEA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACrHA,mC;;;;;;;ACAY;;AAEZ;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;AClBA,iC;;;;;;;ACAY;;AAEZ,WAAW,mBAAO,CAAC,CAAa;AAChC,aAAa,mBAAO,CAAC,CAAM;AAC3B,mBAAmB,mBAAO,CAAC,CAAW;AACtC,mBAAmB,mBAAO,CAAC,EAAmB;AAC9C,aAAa,mBAAO,CAAC,EAAc;;AAEnC;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kGAAkG;AAClG;AACA;;AAEA,SAAS,oBAAoB;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,wBAAwB,KAAK;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,mBAAO,CAAC,EAAgB;;AAExC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,uDAAuD,KAAK,oBAAoB,IAAI;AACpF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS,WAAW;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,YAAY,kCAAkC,aAAa;AACjG;;AAEA;AACA;AACA;AACA;AACA,2CAA2C,aAAa,UAAU,YAAY;AAC9E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;ACnKY;;AAEZ,WAAW,mBAAO,CAAC,CAAa;AAChC,aAAa,mBAAO,CAAC,CAAM;AAC3B,yBAAyB,mBAAO,CAAC,EAAS;;AAE1C;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;AC9DY;;AAEZ,WAAW,mBAAO,CAAC,CAAa;AAChC,aAAa,mBAAO,CAAC,CAAM;AAC3B,yBAAyB,mBAAO,CAAC,EAAS;;AAE1C;;AAEA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;ACrDY;AACZ;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;;;;;;ACXY;;AAEZ,WAAW,mBAAO,CAAC,CAAa;AAChC,aAAa,mBAAO,CAAC,CAAM;AAC3B,eAAe,mBAAO,CAAC,CAAW;AAClC,mBAAmB,mBAAO,CAAC,CAAgB;AAC3C,eAAe,mBAAO,CAAC,EAAgB;AACvC,aAAa,mBAAO,CAAC,EAAc;;AAEnC;AACA;AACA;AACA;AACA,GAAG;AACH,YAAY;AACZ;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kGAAkG;AAClG;AACA;;AAEA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH,4BAA4B,KAAK;AACjC,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C,qBAAqB;AAChE;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,2DAA2D,KAAK,oBAAoB,IAAI;AACxF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,YAAY,kCAAkC,aAAa;AACzG;;AAEA;AACA;AACA;AACA;AACA,mDAAmD,aAAa,UAAU,YAAY;AACtF;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;ACnNY;;AAEZ,UAAU,mBAAO,CAAC,CAAc;AAChC,WAAW,mBAAO,CAAC,CAAa;AAChC,aAAa,mBAAO,CAAC,CAAM;AAC3B,cAAc,mBAAO,CAAC,CAAW;AACjC,eAAe,mBAAO,CAAC,EAAW;;AAElC;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/CY;;AAEZ,WAAW,mBAAO,CAAC,CAAa;AAChC,aAAa,mBAAO,CAAC,CAAM;AAC3B,eAAe,mBAAO,CAAC,EAAQ;;AAE/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,aAAa;AACpB,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACzTY;;AAEZ,aAAa,mBAAO,CAAC,EAAQ;AAC7B,aAAa,mBAAO,CAAC,EAAQ;AAC7B,gBAAgB,mBAAO,CAAC,EAAW;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtBY;;AAEZ,UAAU,mBAAO,CAAC,CAAc;AAChC,aAAa,mBAAO,CAAC,CAAM;AAC3B,WAAW,mBAAO,CAAC,CAAa;AAChC,cAAc,mBAAO,CAAC,CAAW;AACjC,mBAAmB,mBAAO,CAAC,CAAgB;;AAE3C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;AChDY;;AAEZ,UAAU,mBAAO,CAAC,CAAc;AAChC,aAAa,mBAAO,CAAC,CAAM;AAC3B,WAAW,mBAAO,CAAC,CAAa;AAChC,cAAc,mBAAO,CAAC,CAAW;AACjC,mBAAmB,mBAAO,CAAC,CAAgB;;AAE3C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;AC5DY;;AAEZ,UAAU,mBAAO,CAAC,CAAc;AAChC,aAAa,mBAAO,CAAC,CAAM;AAC3B,WAAW,mBAAO,CAAC,CAAa;AAChC,gBAAgB,mBAAO,CAAC,CAAW;AACnC;AACA;;AAEA,sBAAsB,mBAAO,CAAC,EAAiB;AAC/C;AACA;;AAEA,qBAAqB,mBAAO,CAAC,EAAgB;AAC7C;AACA;;AAEA,mBAAmB,mBAAO,CAAC,CAAgB;;AAE3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;AC9DY;;AAEZ,aAAa,mBAAO,CAAC,CAAM;AAC3B,WAAW,mBAAO,CAAC,CAAa;AAChC,mBAAmB,mBAAO,CAAC,CAAgB;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;AClGY;;AAEZ,WAAW,mBAAO,CAAC,CAAa;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;AC9BY;;AAEZ,UAAU,mBAAO,CAAC,CAAc;AAChC,iBAAiB,mBAAO,CAAC,EAAY;;AAErC,wBAAwB,mBAAO,CAAC,EAAe;AAC/C,0BAA0B,mBAAO,CAAC,EAAoB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACfA;AACA;AACA,QAAQ,mBAAO,CAAC,CAAa;AAC7B,CAAC;AACD,QAAQ,mBAAO,CAAC,CAAI;AACpB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,eAAe;AACf;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACrIY;;AAEZ,aAAa,mBAAO,CAAC,CAAM;AAC3B,cAAc,mBAAO,CAAC,CAAW;AACjC,mBAAmB,mBAAO,CAAC,CAAgB;AAC3C,iBAAiB,mBAAO,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AC,EAAa;AACrC,cAAc,mBAAO,CAAC,CAAW;AACjC,iBAAiB,mBAAO,CAAC,EAAQ;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,cAAc,kBAAkB;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,gBAAgB;AAChB;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC/Ta;;AAEb,cAAc,mBAAO,CAAC,CAAW;;AAEjC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qDAAqD;AACxE;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;;AAEA;;;;;;;;;;;;;;ACnzBY;;AAEZ;AACA,6BAA6B,mBAAO,CAAC,EAAiB;AACtD,8BAA8B,mBAAO,CAAC,EAAkB;AACxD,2BAA2B,mBAAO,CAAC,EAAe;AAClD,6BAA6B,mBAAO,CAAC,EAAiB;AACtD,8BAA8B,mBAAO,CAAC,EAAkB;;AAExD;AACA,eAAe,mBAAO,CAAC,EAAe;AACtC,iBAAiB,mBAAO,CAAC,EAAiB;AAC1C,gBAAgB,mBAAO,CAAC,EAAgB;AACxC,oBAAoB,mBAAO,CAAC,EAAqB;AACjD,qBAAqB,mBAAO,CAAC,EAAsB;AACnD,iBAAiB,mBAAO,CAAC,EAAiB;AAC1C,cAAc,mBAAO,CAAC,EAAc;AACpC,gBAAgB,mBAAO,CAAC,EAAgB;;;;;;;;ACjB5B;;AAEZ;AACA,YAAY,mBAAO,CAAC,CAAqB;;AAEzC,aAAa,mBAAO,CAAC,EAAW;AAChC,WAAW,mBAAO,CAAC,CAAI;AACvB,YAAY,mBAAO,CAAC,EAAa;AACjC,UAAU,mBAAO,CAAC,EAAW;AAC7B,aAAa,mBAAO,CAAC,CAAM;;AAE3B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;ACxGY;AACZ;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;;;;;;;ACPA,2C;;;;;;ACAA,iC;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;AC7CW;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,0BAA0B,OAAO;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B,OAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;AChGY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACbY;;AAEZ;;AAEA,YAAY,mBAAO,CAAC,CAAqB;AACzC,UAAU,mBAAO,CAAC,EAAc;AAChC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACnCY;;AAEZ;AACA,YAAY,mBAAO,CAAC,CAAqB;AACzC,eAAe,mBAAO,CAAC,EAAa;AACpC,WAAW,mBAAO,CAAC,CAAI;AACvB,YAAY,mBAAO,CAAC,EAAa;AACjC,aAAa,mBAAO,CAAC,CAAM;;AAE3B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AC/GY;AACZ;;AAEA;AACA;;AAEA,eAAe,mBAAO,CAAC,EAAQ;AAC/B,WAAW,mBAAO,CAAC,CAAI;AACvB,aAAa,mBAAO,CAAC,CAAM;AAC3B,eAAe,mBAAO,CAAC,EAAQ;;AAE/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;;;;;;AC7MA,WAAW,mBAAO,CAAC,CAAM;AACzB,SAAS,mBAAO,CAAC,CAAI;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACjGY;AACZ,WAAW,mBAAO,CAAC,CAAI;AACvB,aAAa,mBAAO,CAAC,CAAM;;AAE3B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;;;AAGA;AACA,cAAc,sBAAsB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AA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","file":"jsii-runtime.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 43);\n","module.exports = require(\"path\");","var fs = require('fs')\nvar polyfills = require('./polyfills.js')\nvar legacy = require('./legacy-streams.js')\nvar clone = require('./clone.js')\n\nvar queue = []\n\nvar util = require('util')\n\nfunction noop () {}\n\nvar debug = noop\nif (util.debuglog)\n  debug = util.debuglog('gfs4')\nelse if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || ''))\n  debug = function() {\n    var m = util.format.apply(util, arguments)\n    m = 'GFS4: ' + m.split(/\\n/).join('\\nGFS4: ')\n    console.error(m)\n  }\n\nif (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || '')) {\n  process.on('exit', function() {\n    debug(queue)\n    require('assert').equal(queue.length, 0)\n  })\n}\n\nmodule.exports = patch(clone(fs))\nif (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {\n    module.exports = patch(fs)\n    fs.__patched = true;\n}\n\n// Always patch fs.close/closeSync, because we want to\n// retry() whenever a close happens *anywhere* in the program.\n// This is essential when multiple graceful-fs instances are\n// in play at the same time.\nmodule.exports.close = (function (fs$close) { return function (fd, cb) {\n  return fs$close.call(fs, fd, function (err) {\n    if (!err)\n      retry()\n\n    if (typeof cb === 'function')\n      cb.apply(this, arguments)\n  })\n}})(fs.close)\n\nmodule.exports.closeSync = (function (fs$closeSync) { return function (fd) {\n  // Note that graceful-fs also retries when fs.closeSync() fails.\n  // Looks like a bug to me, although it's probably a harmless one.\n  var rval = fs$closeSync.apply(fs, arguments)\n  retry()\n  return rval\n}})(fs.closeSync)\n\n// Only patch fs once, otherwise we'll run into a memory leak if\n// graceful-fs is loaded multiple times, such as in test environments that\n// reset the loaded modules between tests.\n// We look for the string `graceful-fs` from the comment above. This\n// way we are not adding any extra properties and it will detect if older\n// versions of graceful-fs are installed.\nif (!/\\bgraceful-fs\\b/.test(fs.closeSync.toString())) {\n  fs.closeSync = module.exports.closeSync;\n  fs.close = module.exports.close;\n}\n\nfunction patch (fs) {\n  // Everything that references the open() function needs to be in here\n  polyfills(fs)\n  fs.gracefulify = patch\n  fs.FileReadStream = ReadStream;  // Legacy name.\n  fs.FileWriteStream = WriteStream;  // Legacy name.\n  fs.createReadStream = createReadStream\n  fs.createWriteStream = createWriteStream\n  var fs$readFile = fs.readFile\n  fs.readFile = readFile\n  function readFile (path, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$readFile(path, options, cb)\n\n    function go$readFile (path, options, cb) {\n      return fs$readFile(path, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$readFile, [path, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$writeFile = fs.writeFile\n  fs.writeFile = writeFile\n  function writeFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$writeFile(path, data, options, cb)\n\n    function go$writeFile (path, data, options, cb) {\n      return fs$writeFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$writeFile, [path, data, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$appendFile = fs.appendFile\n  if (fs$appendFile)\n    fs.appendFile = appendFile\n  function appendFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$appendFile(path, data, options, cb)\n\n    function go$appendFile (path, data, options, cb) {\n      return fs$appendFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$appendFile, [path, data, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$readdir = fs.readdir\n  fs.readdir = readdir\n  function readdir (path, options, cb) {\n    var args = [path]\n    if (typeof options !== 'function') {\n      args.push(options)\n    } else {\n      cb = options\n    }\n    args.push(go$readdir$cb)\n\n    return go$readdir(args)\n\n    function go$readdir$cb (err, files) {\n      if (files && files.sort)\n        files.sort()\n\n      if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n        enqueue([go$readdir, [args]])\n\n      else {\n        if (typeof cb === 'function')\n          cb.apply(this, arguments)\n        retry()\n      }\n    }\n  }\n\n  function go$readdir (args) {\n    return fs$readdir.apply(fs, args)\n  }\n\n  if (process.version.substr(0, 4) === 'v0.8') {\n    var legStreams = legacy(fs)\n    ReadStream = legStreams.ReadStream\n    WriteStream = legStreams.WriteStream\n  }\n\n  var fs$ReadStream = fs.ReadStream\n  if (fs$ReadStream) {\n    ReadStream.prototype = Object.create(fs$ReadStream.prototype)\n    ReadStream.prototype.open = ReadStream$open\n  }\n\n  var fs$WriteStream = fs.WriteStream\n  if (fs$WriteStream) {\n    WriteStream.prototype = Object.create(fs$WriteStream.prototype)\n    WriteStream.prototype.open = WriteStream$open\n  }\n\n  fs.ReadStream = ReadStream\n  fs.WriteStream = WriteStream\n\n  function ReadStream (path, options) {\n    if (this instanceof ReadStream)\n      return fs$ReadStream.apply(this, arguments), this\n    else\n      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)\n  }\n\n  function ReadStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        if (that.autoClose)\n          that.destroy()\n\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n        that.read()\n      }\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (this instanceof WriteStream)\n      return fs$WriteStream.apply(this, arguments), this\n    else\n      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)\n  }\n\n  function WriteStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        that.destroy()\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n      }\n    })\n  }\n\n  function createReadStream (path, options) {\n    return new ReadStream(path, options)\n  }\n\n  function createWriteStream (path, options) {\n    return new WriteStream(path, options)\n  }\n\n  var fs$open = fs.open\n  fs.open = open\n  function open (path, flags, mode, cb) {\n    if (typeof mode === 'function')\n      cb = mode, mode = null\n\n    return go$open(path, flags, mode, cb)\n\n    function go$open (path, flags, mode, cb) {\n      return fs$open(path, flags, mode, function (err, fd) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$open, [path, flags, mode, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  return fs\n}\n\nfunction enqueue (elem) {\n  debug('ENQUEUE', elem[0].name, elem[1])\n  queue.push(elem)\n}\n\nfunction retry () {\n  var elem = queue.shift()\n  if (elem) {\n    debug('RETRY', elem[0].name, elem[1])\n    elem[0].apply(null, elem[1])\n  }\n}\n","module.exports = require(\"fs\");","'use strict'\n\nexports.fromCallback = function (fn) {\n  return Object.defineProperty(function () {\n    if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)\n    else {\n      return new Promise((resolve, reject) => {\n        arguments[arguments.length] = (err, res) => {\n          if (err) return reject(err)\n          resolve(res)\n        }\n        arguments.length++\n        fn.apply(this, arguments)\n      })\n    }\n  }, 'name', { value: fn.name })\n}\n\nexports.fromPromise = function (fn) {\n  return Object.defineProperty(function () {\n    const cb = arguments[arguments.length - 1]\n    if (typeof cb !== 'function') return fn.apply(this, arguments)\n    else fn.apply(this, arguments).then(r => cb(null, r), cb)\n  }, 'name', { value: fn.name })\n}\n","'use strict'\nconst u = require('universalify').fromCallback\nconst mkdirs = u(require('./mkdirs'))\nconst mkdirsSync = require('./mkdirs-sync')\n\nmodule.exports = {\n  mkdirs,\n  mkdirsSync,\n  // alias\n  mkdirp: mkdirs,\n  mkdirpSync: mkdirsSync,\n  ensureDir: mkdirs,\n  ensureDirSync: mkdirsSync\n}\n","'use strict'\nconst u = require('universalify').fromPromise\nconst fs = require('../fs')\n\nfunction pathExists (path) {\n  return fs.access(path).then(() => true).catch(() => false)\n}\n\nmodule.exports = {\n  pathExists: u(pathExists),\n  pathExistsSync: fs.existsSync\n}\n","'use strict'\n\n// Buffer in node 4.x < 4.5.0 doesn't have working Buffer.from\n// or Buffer.alloc, and Buffer in node 10 deprecated the ctor.\n// .M, this is fine .\\^/M..\nlet B = Buffer\n/* istanbul ignore next */\nif (!B.alloc) {\n  B = require('safe-buffer').Buffer\n}\nmodule.exports = B\n","'use strict';\n\nvar uri = require('url');\n\nvar ValidationError = exports.ValidationError = function ValidationError (message, instance, schema, propertyPath, name, argument) {\n  if (propertyPath) {\n    this.property = propertyPath;\n  }\n  if (message) {\n    this.message = message;\n  }\n  if (schema) {\n    if (schema.id) {\n      this.schema = schema.id;\n    } else {\n      this.schema = schema;\n    }\n  }\n  if (instance) {\n    this.instance = instance;\n  }\n  this.name = name;\n  this.argument = argument;\n  this.stack = this.toString();\n};\n\nValidationError.prototype.toString = function toString() {\n  return this.property + ' ' + this.message;\n};\n\nvar ValidatorResult = exports.ValidatorResult = function ValidatorResult(instance, schema, options, ctx) {\n  this.instance = instance;\n  this.schema = schema;\n  this.propertyPath = ctx.propertyPath;\n  this.errors = [];\n  this.throwError = options && options.throwError;\n  this.disableFormat = options && options.disableFormat === true;\n};\n\nValidatorResult.prototype.addError = function addError(detail) {\n  var err;\n  if (typeof detail == 'string') {\n    err = new ValidationError(detail, this.instance, this.schema, this.propertyPath);\n  } else {\n    if (!detail) throw new Error('Missing error detail');\n    if (!detail.message) throw new Error('Missing error message');\n    if (!detail.name) throw new Error('Missing validator type');\n    err = new ValidationError(detail.message, this.instance, this.schema, this.propertyPath, detail.name, detail.argument);\n  }\n\n  if (this.throwError) {\n    throw err;\n  }\n  this.errors.push(err);\n  return err;\n};\n\nValidatorResult.prototype.importErrors = function importErrors(res) {\n  if (typeof res == 'string' || (res && res.validatorType)) {\n    this.addError(res);\n  } else if (res && res.errors) {\n    Array.prototype.push.apply(this.errors, res.errors);\n  }\n};\n\nfunction stringizer (v,i){\n  return i+': '+v.toString()+'\\n';\n}\nValidatorResult.prototype.toString = function toString(res) {\n  return this.errors.map(stringizer).join('');\n};\n\nObject.defineProperty(ValidatorResult.prototype, \"valid\", { get: function() {\n  return !this.errors.length;\n} });\n\n/**\n * Describes a problem with a Schema which prevents validation of an instance\n * @name SchemaError\n * @constructor\n */\nvar SchemaError = exports.SchemaError = function SchemaError (msg, schema) {\n  this.message = msg;\n  this.schema = schema;\n  Error.call(this, msg);\n  Error.captureStackTrace(this, SchemaError);\n};\nSchemaError.prototype = Object.create(Error.prototype,\n  { constructor: {value: SchemaError, enumerable: false}\n  , name: {value: 'SchemaError', enumerable: false}\n  });\n\nvar SchemaContext = exports.SchemaContext = function SchemaContext (schema, options, propertyPath, base, schemas) {\n  this.schema = schema;\n  this.options = options;\n  this.propertyPath = propertyPath;\n  this.base = base;\n  this.schemas = schemas;\n};\n\nSchemaContext.prototype.resolve = function resolve (target) {\n  return uri.resolve(this.base, target);\n};\n\nSchemaContext.prototype.makeChild = function makeChild(schema, propertyName){\n  var propertyPath = (propertyName===undefined) ? this.propertyPath : this.propertyPath+makeSuffix(propertyName);\n  var base = uri.resolve(this.base, schema.id||'');\n  var ctx = new SchemaContext(schema, this.options, propertyPath, base, Object.create(this.schemas));\n  if(schema.id && !ctx.schemas[base]){\n    ctx.schemas[base] = schema;\n  }\n  return ctx;\n}\n\nvar FORMAT_REGEXPS = exports.FORMAT_REGEXPS = {\n  'date-time': /^\\d{4}-(?:0[0-9]{1}|1[0-2]{1})-(3[01]|0[1-9]|[12][0-9])[tT ](2[0-4]|[01][0-9]):([0-5][0-9]):(60|[0-5][0-9])(\\.\\d+)?([zZ]|[+-]([0-5][0-9]):(60|[0-5][0-9]))$/,\n  'date': /^\\d{4}-(?:0[0-9]{1}|1[0-2]{1})-(3[01]|0[1-9]|[12][0-9])$/,\n  'time': /^(2[0-4]|[01][0-9]):([0-5][0-9]):(60|[0-5][0-9])$/,\n\n  'email': /^(?:[\\w\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\`\\{\\|\\}\\~]+\\.)*[\\w\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\`\\{\\|\\}\\~]+@(?:(?:(?:[a-zA-Z0-9](?:[a-zA-Z0-9\\-](?!\\.)){0,61}[a-zA-Z0-9]?\\.)+[a-zA-Z0-9](?:[a-zA-Z0-9\\-](?!$)){0,61}[a-zA-Z0-9]?)|(?:\\[(?:(?:[01]?\\d{1,2}|2[0-4]\\d|25[0-5])\\.){3}(?:[01]?\\d{1,2}|2[0-4]\\d|25[0-5])\\]))$/,\n  'ip-address': /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/,\n  'ipv6': /^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$/,\n  'uri': /^[a-zA-Z][a-zA-Z0-9+-.]*:[^\\s]*$/,\n\n  'color': /^(#?([0-9A-Fa-f]{3}){1,2}\\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\\(\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*\\))|(rgb\\(\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*\\)))$/,\n\n  // hostname regex from: http://stackoverflow.com/a/1420225/5628\n  'hostname': /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\\.?$/,\n  'host-name': /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\\.?$/,\n\n  'alpha': /^[a-zA-Z]+$/,\n  'alphanumeric': /^[a-zA-Z0-9]+$/,\n  'utc-millisec': function (input) {\n    return (typeof input === 'string') && parseFloat(input) === parseInt(input, 10) && !isNaN(input);\n  },\n  'regex': function (input) {\n    var result = true;\n    try {\n      new RegExp(input);\n    } catch (e) {\n      result = false;\n    }\n    return result;\n  },\n  'style': /\\s*(.+?):\\s*([^;]+);?/g,\n  'phone': /^\\+(?:[0-9] ?){6,14}[0-9]$/\n};\n\nFORMAT_REGEXPS.regexp = FORMAT_REGEXPS.regex;\nFORMAT_REGEXPS.pattern = FORMAT_REGEXPS.regex;\nFORMAT_REGEXPS.ipv4 = FORMAT_REGEXPS['ip-address'];\n\nexports.isFormat = function isFormat (input, format, validator) {\n  if (typeof input === 'string' && FORMAT_REGEXPS[format] !== undefined) {\n    if (FORMAT_REGEXPS[format] instanceof RegExp) {\n      return FORMAT_REGEXPS[format].test(input);\n    }\n    if (typeof FORMAT_REGEXPS[format] === 'function') {\n      return FORMAT_REGEXPS[format](input);\n    }\n  } else if (validator && validator.customFormats &&\n      typeof validator.customFormats[format] === 'function') {\n    return validator.customFormats[format](input);\n  }\n  return true;\n};\n\nvar makeSuffix = exports.makeSuffix = function makeSuffix (key) {\n  key = key.toString();\n  // This function could be capable of outputting valid a ECMAScript string, but the\n  // resulting code for testing which form to use would be tens of thousands of characters long\n  // That means this will use the name form for some illegal forms\n  if (!key.match(/[.\\s\\[\\]]/) && !key.match(/^[\\d]/)) {\n    return '.' + key;\n  }\n  if (key.match(/^\\d+$/)) {\n    return '[' + key + ']';\n  }\n  return '[' + JSON.stringify(key) + ']';\n};\n\nexports.deepCompareStrict = function deepCompareStrict (a, b) {\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (a instanceof Array) {\n    if (!(b instanceof Array)) {\n      return false;\n    }\n    if (a.length !== b.length) {\n      return false;\n    }\n    return a.every(function (v, i) {\n      return deepCompareStrict(a[i], b[i]);\n    });\n  }\n  if (typeof a === 'object') {\n    if (!a || !b) {\n      return a === b;\n    }\n    var aKeys = Object.keys(a);\n    var bKeys = Object.keys(b);\n    if (aKeys.length !== bKeys.length) {\n      return false;\n    }\n    return aKeys.every(function (v) {\n      return deepCompareStrict(a[v], b[v]);\n    });\n  }\n  return a === b;\n};\n\nfunction deepMerger (target, dst, e, i) {\n  if (typeof e === 'object') {\n    dst[i] = deepMerge(target[i], e)\n  } else {\n    if (target.indexOf(e) === -1) {\n      dst.push(e)\n    }\n  }\n}\n\nfunction copyist (src, dst, key) {\n  dst[key] = src[key];\n}\n\nfunction copyistWithDeepMerge (target, src, dst, key) {\n  if (typeof src[key] !== 'object' || !src[key]) {\n    dst[key] = src[key];\n  }\n  else {\n    if (!target[key]) {\n      dst[key] = src[key];\n    } else {\n      dst[key] = deepMerge(target[key], src[key])\n    }\n  }\n}\n\nfunction deepMerge (target, src) {\n  var array = Array.isArray(src);\n  var dst = array && [] || {};\n\n  if (array) {\n    target = target || [];\n    dst = dst.concat(target);\n    src.forEach(deepMerger.bind(null, target, dst));\n  } else {\n    if (target && typeof target === 'object') {\n      Object.keys(target).forEach(copyist.bind(null, target, dst));\n    }\n    Object.keys(src).forEach(copyistWithDeepMerge.bind(null, target, src, dst));\n  }\n\n  return dst;\n};\n\nmodule.exports.deepMerge = deepMerge;\n\n/**\n * Validates instance against the provided schema\n * Implements URI+JSON Pointer encoding, e.g. \"%7e\"=\"~0\"=>\"~\", \"~1\"=\"%2f\"=>\"/\"\n * @param o\n * @param s The path to walk o along\n * @return any\n */\nexports.objectGetPath = function objectGetPath(o, s) {\n  var parts = s.split('/').slice(1);\n  var k;\n  while (typeof (k=parts.shift()) == 'string') {\n    var n = decodeURIComponent(k.replace(/~0/,'~').replace(/~1/g,'/'));\n    if (!(n in o)) return;\n    o = o[n];\n  }\n  return o;\n};\n\nfunction pathEncoder (v) {\n  return '/'+encodeURIComponent(v).replace(/~/g,'%7E');\n}\n/**\n * Accept an Array of property names and return a JSON Pointer URI fragment\n * @param Array a\n * @return {String}\n */\nexports.encodePath = function encodePointer(a){\n\t// ~ must be encoded explicitly because hacks\n\t// the slash is encoded by encodeURIComponent\n\treturn a.map(pathEncoder).join('');\n};\n\n\n/**\n * Calculate the number of decimal places a number uses\n * We need this to get correct results out of multipleOf and divisibleBy\n * when either figure is has decimal places, due to IEEE-754 float issues.\n * @param number\n * @returns {number}\n */\nexports.getDecimalPlaces = function getDecimalPlaces(number) {\n\n  var decimalPlaces = 0;\n  if (isNaN(number)) return decimalPlaces;\n\n  if (typeof number !== 'number') {\n    number = Number(number);\n  }\n\n  var parts = number.toString().split('e');\n  if (parts.length === 2) {\n    if (parts[1][0] !== '-') {\n      return decimalPlaces;\n    } else {\n      decimalPlaces = Number(parts[1].slice(1));\n    }\n  }\n\n  var decimalParts = parts[0].split('.');\n  if (decimalParts.length === 2) {\n    decimalPlaces += decimalParts[1].length;\n  }\n\n  return decimalPlaces;\n};\n\n","'use strict'\n\n// turn tar(1) style args like `C` into the more verbose things like `cwd`\n\nconst argmap = new Map([\n  ['C', 'cwd'],\n  ['f', 'file'],\n  ['z', 'gzip'],\n  ['P', 'preservePaths'],\n  ['U', 'unlink'],\n  ['strip-components', 'strip'],\n  ['stripComponents', 'strip'],\n  ['keep-newer', 'newer'],\n  ['keepNewer', 'newer'],\n  ['keep-newer-files', 'newer'],\n  ['keepNewerFiles', 'newer'],\n  ['k', 'keep'],\n  ['keep-existing', 'keep'],\n  ['keepExisting', 'keep'],\n  ['m', 'noMtime'],\n  ['no-mtime', 'noMtime'],\n  ['p', 'preserveOwner'],\n  ['L', 'follow'],\n  ['h', 'follow']\n])\n\nconst parse = module.exports = opt => opt ? Object.keys(opt).map(k => [\n  argmap.has(k) ? argmap.get(k) : k, opt[k]\n]).reduce((set, kv) => (set[kv[0]] = kv[1], set), Object.create(null)) : {}\n","'use strict'\nconst EE = require('events')\nconst Yallist = require('yallist')\nconst EOF = Symbol('EOF')\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd')\nconst EMITTED_END = Symbol('emittedEnd')\nconst CLOSED = Symbol('closed')\nconst READ = Symbol('read')\nconst FLUSH = Symbol('flush')\nconst doIter = process.env._MP_NO_ITERATOR_SYMBOLS_  !== '1'\nconst ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol('asyncIterator not implemented')\nconst ITERATOR = doIter && Symbol.iterator || Symbol('iterator not implemented')\nconst FLUSHCHUNK = Symbol('flushChunk')\nconst SD = require('string_decoder').StringDecoder\nconst ENCODING = Symbol('encoding')\nconst DECODER = Symbol('decoder')\nconst FLOWING = Symbol('flowing')\nconst RESUME = Symbol('resume')\nconst BUFFERLENGTH = Symbol('bufferLength')\nconst BUFFERPUSH = Symbol('bufferPush')\nconst BUFFERSHIFT = Symbol('bufferShift')\nconst OBJECTMODE = Symbol('objectMode')\n\n// Buffer in node 4.x < 4.5.0 doesn't have working Buffer.from\n// or Buffer.alloc, and Buffer in node 10 deprecated the ctor.\n// .M, this is fine .\\^/M..\nlet B = Buffer\n/* istanbul ignore next */\nif (!B.alloc) {\n  B = require('safe-buffer').Buffer\n}\n\nmodule.exports = class MiniPass extends EE {\n  constructor (options) {\n    super()\n    this[FLOWING] = false\n    this.pipes = new Yallist()\n    this.buffer = new Yallist()\n    this[OBJECTMODE] = options && options.objectMode || false\n    if (this[OBJECTMODE])\n      this[ENCODING] = null\n    else\n      this[ENCODING] = options && options.encoding || null\n    if (this[ENCODING] === 'buffer')\n      this[ENCODING] = null\n    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null\n    this[EOF] = false\n    this[EMITTED_END] = false\n    this[CLOSED] = false\n    this.writable = true\n    this.readable = true\n    this[BUFFERLENGTH] = 0\n  }\n\n  get bufferLength () { return this[BUFFERLENGTH] }\n\n  get encoding () { return this[ENCODING] }\n  set encoding (enc) {\n    if (this[OBJECTMODE])\n      throw new Error('cannot set encoding in objectMode')\n\n    if (this[ENCODING] && enc !== this[ENCODING] &&\n        (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))\n      throw new Error('cannot change encoding')\n\n    if (this[ENCODING] !== enc) {\n      this[DECODER] = enc ? new SD(enc) : null\n      if (this.buffer.length)\n        this.buffer = this.buffer.map(chunk => this[DECODER].write(chunk))\n    }\n\n    this[ENCODING] = enc\n  }\n\n  setEncoding (enc) {\n    this.encoding = enc\n  }\n\n  write (chunk, encoding, cb) {\n    if (this[EOF])\n      throw new Error('write after end')\n\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n\n    if (!encoding)\n      encoding = 'utf8'\n\n    // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n    if (typeof chunk === 'string' && !this[OBJECTMODE] &&\n        // unless it is a string already ready for us to use\n        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {\n      chunk = B.from(chunk, encoding)\n    }\n\n    if (B.isBuffer(chunk) && this[ENCODING])\n      chunk = this[DECODER].write(chunk)\n\n    try {\n      return this.flowing\n        ? (this.emit('data', chunk), this.flowing)\n        : (this[BUFFERPUSH](chunk), false)\n    } finally {\n      this.emit('readable')\n      if (cb)\n        cb()\n    }\n  }\n\n  read (n) {\n    try {\n      if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH])\n        return null\n\n      if (this[OBJECTMODE])\n        n = null\n\n      if (this.buffer.length > 1 && !this[OBJECTMODE]) {\n        if (this.encoding)\n          this.buffer = new Yallist([\n            Array.from(this.buffer).join('')\n          ])\n        else\n          this.buffer = new Yallist([\n            B.concat(Array.from(this.buffer), this[BUFFERLENGTH])\n          ])\n      }\n\n      return this[READ](n || null, this.buffer.head.value)\n    } finally {\n      this[MAYBE_EMIT_END]()\n    }\n  }\n\n  [READ] (n, chunk) {\n    if (n === chunk.length || n === null)\n      this[BUFFERSHIFT]()\n    else {\n      this.buffer.head.value = chunk.slice(n)\n      chunk = chunk.slice(0, n)\n      this[BUFFERLENGTH] -= n\n    }\n\n    this.emit('data', chunk)\n\n    if (!this.buffer.length && !this[EOF])\n      this.emit('drain')\n\n    return chunk\n  }\n\n  end (chunk, encoding, cb) {\n    if (typeof chunk === 'function')\n      cb = chunk, chunk = null\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n    if (chunk)\n      this.write(chunk, encoding)\n    if (cb)\n      this.once('end', cb)\n    this[EOF] = true\n    this.writable = false\n    if (this.flowing)\n      this[MAYBE_EMIT_END]()\n  }\n\n  // don't let the internal resume be overwritten\n  [RESUME] () {\n    this[FLOWING] = true\n    this.emit('resume')\n    if (this.buffer.length)\n      this[FLUSH]()\n    else if (this[EOF])\n      this[MAYBE_EMIT_END]()\n    else\n      this.emit('drain')\n  }\n\n  resume () {\n    return this[RESUME]()\n  }\n\n  pause () {\n    this[FLOWING] = false\n  }\n\n  get flowing () {\n    return this[FLOWING]\n  }\n\n  [BUFFERPUSH] (chunk) {\n    if (this[OBJECTMODE])\n      this[BUFFERLENGTH] += 1\n    else\n      this[BUFFERLENGTH] += chunk.length\n    return this.buffer.push(chunk)\n  }\n\n  [BUFFERSHIFT] () {\n    if (this.buffer.length) {\n      if (this[OBJECTMODE])\n        this[BUFFERLENGTH] -= 1\n      else\n        this[BUFFERLENGTH] -= this.buffer.head.value.length\n    }\n    return this.buffer.shift()\n  }\n\n  [FLUSH] () {\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()))\n\n    if (!this.buffer.length && !this[EOF])\n      this.emit('drain')\n  }\n\n  [FLUSHCHUNK] (chunk) {\n    return chunk ? (this.emit('data', chunk), this.flowing) : false\n  }\n\n  pipe (dest, opts) {\n    if (dest === process.stdout || dest === process.stderr)\n      (opts = opts || {}).end = false\n    const p = { dest: dest, opts: opts, ondrain: _ => this[RESUME]() }\n    this.pipes.push(p)\n\n    dest.on('drain', p.ondrain)\n    this[RESUME]()\n    return dest\n  }\n\n  addListener (ev, fn) {\n    return this.on(ev, fn)\n  }\n\n  on (ev, fn) {\n    try {\n      return super.on(ev, fn)\n    } finally {\n      if (ev === 'data' && !this.pipes.length && !this.flowing)\n        this[RESUME]()\n      else if (ev === 'end' && this[EMITTED_END]) {\n        super.emit('end')\n        this.removeAllListeners('end')\n      }\n    }\n  }\n\n  get emittedEnd () {\n    return this[EMITTED_END]\n  }\n\n  [MAYBE_EMIT_END] () {\n    if (!this[EMITTED_END] && this.buffer.length === 0 && this[EOF]) {\n      this.emit('end')\n      this.emit('prefinish')\n      this.emit('finish')\n      if (this[CLOSED])\n        this.emit('close')\n    }\n  }\n\n  emit (ev, data) {\n    if (ev === 'data') {\n      if (!data)\n        return\n\n      if (this.pipes.length)\n        this.pipes.forEach(p => p.dest.write(data) || this.pause())\n    } else if (ev === 'end') {\n      if (this[EMITTED_END] === true)\n        return\n\n      this[EMITTED_END] = true\n      this.readable = false\n\n      if (this[DECODER]) {\n        data = this[DECODER].end()\n        if (data) {\n          this.pipes.forEach(p => p.dest.write(data))\n          super.emit('data', data)\n        }\n      }\n\n      this.pipes.forEach(p => {\n        p.dest.removeListener('drain', p.ondrain)\n        if (!p.opts || p.opts.end !== false)\n          p.dest.end()\n      })\n    } else if (ev === 'close') {\n      this[CLOSED] = true\n      // don't emit close before 'end' and 'finish'\n      if (!this[EMITTED_END])\n        return\n    }\n\n    const args = new Array(arguments.length)\n    args[0] = ev\n    args[1] = data\n    if (arguments.length > 2) {\n      for (let i = 2; i < arguments.length; i++) {\n        args[i] = arguments[i]\n      }\n    }\n\n    try {\n      return super.emit.apply(this, args)\n    } finally {\n      if (ev !== 'end')\n        this[MAYBE_EMIT_END]()\n      else\n        this.removeAllListeners('end')\n    }\n  }\n\n  // const all = await stream.collect()\n  collect () {\n    return new Promise((resolve, reject) => {\n      const buf = []\n      this.on('data', c => buf.push(c))\n      this.on('end', () => resolve(buf))\n      this.on('error', reject)\n    })\n  }\n\n  // for await (let chunk of stream)\n  [ASYNCITERATOR] () {\n    const next = () => {\n      const res = this.read()\n      if (res !== null)\n        return Promise.resolve({ done: false, value: res })\n\n      if (this[EOF])\n        return Promise.resolve({ done: true })\n\n      let resolve = null\n      let reject = null\n      const onerr = er => {\n        this.removeListener('data', ondata)\n        this.removeListener('end', onend)\n        reject(er)\n      }\n      const ondata = value => {\n        this.removeListener('error', onerr)\n        this.removeListener('end', onend)\n        this.pause()\n        resolve({ value: value, done: !!this[EOF] })\n      }\n      const onend = () => {\n        this.removeListener('error', onerr)\n        this.removeListener('data', ondata)\n        resolve({ done: true })\n      }\n      return new Promise((res, rej) => {\n        reject = rej\n        resolve = res\n        this.once('error', onerr)\n        this.once('end', onend)\n        this.once('data', ondata)\n      })\n    }\n\n    return { next }\n  }\n\n  // for (let chunk of stream)\n  [ITERATOR] () {\n    const next = () => {\n      const value = this.read()\n      const done = value === null\n      return { value, done }\n    }\n    return { next }\n  }\n}\n","'use strict'\n// parse a 512-byte header block to a data object, or vice-versa\n// encode returns `true` if a pax extended header is needed, because\n// the data could not be faithfully encoded in a simple header.\n// (Also, check header.needPax to see if it needs a pax header.)\n\nconst Buffer = require('./buffer.js')\nconst types = require('./types.js')\nconst pathModule = require('path').posix\nconst large = require('./large-numbers.js')\n\nconst SLURP = Symbol('slurp')\nconst TYPE = Symbol('type')\n\nclass Header {\n  constructor (data, off, ex, gex) {\n    this.cksumValid = false\n    this.needPax = false\n    this.nullBlock = false\n\n    this.block = null\n    this.path = null\n    this.mode = null\n    this.uid = null\n    this.gid = null\n    this.size = null\n    this.mtime = null\n    this.cksum = null\n    this[TYPE] = '0'\n    this.linkpath = null\n    this.uname = null\n    this.gname = null\n    this.devmaj = 0\n    this.devmin = 0\n    this.atime = null\n    this.ctime = null\n\n    if (Buffer.isBuffer(data))\n      this.decode(data, off || 0, ex, gex)\n    else if (data)\n      this.set(data)\n  }\n\n  decode (buf, off, ex, gex) {\n    if (!off)\n      off = 0\n\n    if (!buf || !(buf.length >= off + 512))\n      throw new Error('need 512 bytes for header')\n\n    this.path = decString(buf, off, 100)\n    this.mode = decNumber(buf, off + 100, 8)\n    this.uid = decNumber(buf, off + 108, 8)\n    this.gid = decNumber(buf, off + 116, 8)\n    this.size = decNumber(buf, off + 124, 12)\n    this.mtime = decDate(buf, off + 136, 12)\n    this.cksum = decNumber(buf, off + 148, 12)\n\n    // if we have extended or global extended headers, apply them now\n    // See https://github.com/npm/node-tar/pull/187\n    this[SLURP](ex)\n    this[SLURP](gex, true)\n\n    // old tar versions marked dirs as a file with a trailing /\n    this[TYPE] = decString(buf, off + 156, 1)\n    if (this[TYPE] === '')\n      this[TYPE] = '0'\n    if (this[TYPE] === '0' && this.path.substr(-1) === '/')\n      this[TYPE] = '5'\n\n    // tar implementations sometimes incorrectly put the stat(dir).size\n    // as the size in the tarball, even though Directory entries are\n    // not able to have any body at all.  In the very rare chance that\n    // it actually DOES have a body, we weren't going to do anything with\n    // it anyway, and it'll just be a warning about an invalid header.\n    if (this[TYPE] === '5')\n      this.size = 0\n\n    this.linkpath = decString(buf, off + 157, 100)\n    if (buf.slice(off + 257, off + 265).toString() === 'ustar\\u000000') {\n      this.uname = decString(buf, off + 265, 32)\n      this.gname = decString(buf, off + 297, 32)\n      this.devmaj = decNumber(buf, off + 329, 8)\n      this.devmin = decNumber(buf, off + 337, 8)\n      if (buf[off + 475] !== 0) {\n        // definitely a prefix, definitely >130 chars.\n        const prefix = decString(buf, off + 345, 155)\n        this.path = prefix + '/' + this.path\n      } else {\n        const prefix = decString(buf, off + 345, 130)\n        if (prefix)\n          this.path = prefix + '/' + this.path\n        this.atime = decDate(buf, off + 476, 12)\n        this.ctime = decDate(buf, off + 488, 12)\n      }\n    }\n\n    let sum = 8 * 0x20\n    for (let i = off; i < off + 148; i++) {\n      sum += buf[i]\n    }\n    for (let i = off + 156; i < off + 512; i++) {\n      sum += buf[i]\n    }\n    this.cksumValid = sum === this.cksum\n    if (this.cksum === null && sum === 8 * 0x20)\n      this.nullBlock = true\n  }\n\n  [SLURP] (ex, global) {\n    for (let k in ex) {\n      // we slurp in everything except for the path attribute in\n      // a global extended header, because that's weird.\n      if (ex[k] !== null && ex[k] !== undefined &&\n          !(global && k === 'path'))\n        this[k] = ex[k]\n    }\n  }\n\n  encode (buf, off) {\n    if (!buf) {\n      buf = this.block = Buffer.alloc(512)\n      off = 0\n    }\n\n    if (!off)\n      off = 0\n\n    if (!(buf.length >= off + 512))\n      throw new Error('need 512 bytes for header')\n\n    const prefixSize = this.ctime || this.atime ? 130 : 155\n    const split = splitPrefix(this.path || '', prefixSize)\n    const path = split[0]\n    const prefix = split[1]\n    this.needPax = split[2]\n\n    this.needPax = encString(buf, off, 100, path) || this.needPax\n    this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax\n    this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax\n    this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax\n    this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax\n    this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax\n    buf[off + 156] = this[TYPE].charCodeAt(0)\n    this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax\n    buf.write('ustar\\u000000', off + 257, 8)\n    this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax\n    this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax\n    this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax\n    this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax\n    this.needPax = encString(buf, off + 345, prefixSize, prefix) || this.needPax\n    if (buf[off + 475] !== 0)\n      this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax\n    else {\n      this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax\n      this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax\n      this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax\n    }\n\n    let sum = 8 * 0x20\n    for (let i = off; i < off + 148; i++) {\n      sum += buf[i]\n    }\n    for (let i = off + 156; i < off + 512; i++) {\n      sum += buf[i]\n    }\n    this.cksum = sum\n    encNumber(buf, off + 148, 8, this.cksum)\n    this.cksumValid = true\n\n    return this.needPax\n  }\n\n  set (data) {\n    for (let i in data) {\n      if (data[i] !== null && data[i] !== undefined)\n        this[i] = data[i]\n    }\n  }\n\n  get type () {\n    return types.name.get(this[TYPE]) || this[TYPE]\n  }\n\n  get typeKey () {\n    return this[TYPE]\n  }\n\n  set type (type) {\n    if (types.code.has(type))\n      this[TYPE] = types.code.get(type)\n    else\n      this[TYPE] = type\n  }\n}\n\nconst splitPrefix = (p, prefixSize) => {\n  const pathSize = 100\n  let pp = p\n  let prefix = ''\n  let ret\n  const root = pathModule.parse(p).root || '.'\n\n  if (Buffer.byteLength(pp) < pathSize)\n    ret = [pp, prefix, false]\n  else {\n    // first set prefix to the dir, and path to the base\n    prefix = pathModule.dirname(pp)\n    pp = pathModule.basename(pp)\n\n    do {\n      // both fit!\n      if (Buffer.byteLength(pp) <= pathSize &&\n          Buffer.byteLength(prefix) <= prefixSize)\n        ret = [pp, prefix, false]\n\n      // prefix fits in prefix, but path doesn't fit in path\n      else if (Buffer.byteLength(pp) > pathSize &&\n          Buffer.byteLength(prefix) <= prefixSize)\n        ret = [pp.substr(0, pathSize - 1), prefix, true]\n\n      else {\n        // make path take a bit from prefix\n        pp = pathModule.join(pathModule.basename(prefix), pp)\n        prefix = pathModule.dirname(prefix)\n      }\n    } while (prefix !== root && !ret)\n\n    // at this point, found no resolution, just truncate\n    if (!ret)\n      ret = [p.substr(0, pathSize - 1), '', true]\n  }\n  return ret\n}\n\nconst decString = (buf, off, size) =>\n  buf.slice(off, off + size).toString('utf8').replace(/\\0.*/, '')\n\nconst decDate = (buf, off, size) =>\n  numToDate(decNumber(buf, off, size))\n\nconst numToDate = num => num === null ? null : new Date(num * 1000)\n\nconst decNumber = (buf, off, size) =>\n  buf[off] & 0x80 ? large.parse(buf.slice(off, off + size))\n    : decSmallNumber(buf, off, size)\n\nconst nanNull = value => isNaN(value) ? null : value\n\nconst decSmallNumber = (buf, off, size) =>\n  nanNull(parseInt(\n    buf.slice(off, off + size)\n      .toString('utf8').replace(/\\0.*$/, '').trim(), 8))\n\n// the maximum encodable as a null-terminated octal, by field size\nconst MAXNUM = {\n  12: 0o77777777777,\n  8 : 0o7777777\n}\n\nconst encNumber = (buf, off, size, number) =>\n  number === null ? false :\n  number > MAXNUM[size] || number < 0\n    ? (large.encode(number, buf.slice(off, off + size)), true)\n    : (encSmallNumber(buf, off, size, number), false)\n\nconst encSmallNumber = (buf, off, size, number) =>\n  buf.write(octalString(number, size), off, size, 'ascii')\n\nconst octalString = (number, size) =>\n  padOctal(Math.floor(number).toString(8), size)\n\nconst padOctal = (string, size) =>\n  (string.length === size - 1 ? string\n  : new Array(size - string.length - 1).join('0') + string + ' ') + '\\0'\n\nconst encDate = (buf, off, size, date) =>\n  date === null ? false :\n  encNumber(buf, off, size, date.getTime() / 1000)\n\n// enough to fill the longest string we've got\nconst NULLS = new Array(156).join('\\0')\n// pad with nulls, return true if it's longer or non-ascii\nconst encString = (buf, off, size, string) =>\n  string === null ? false :\n  (buf.write(string + NULLS, off, size, 'utf8'),\n   string.length !== Buffer.byteLength(string) || string.length > size)\n\nmodule.exports = Header\n","'use strict'\nconst MiniPass = require('minipass')\nconst EE = require('events').EventEmitter\nconst fs = require('fs')\n\n// for writev\nconst binding = process.binding('fs')\nconst writeBuffers = binding.writeBuffers\nconst FSReqWrap = binding.FSReqWrap || binding.FSReqCallback\n\nconst _autoClose = Symbol('_autoClose')\nconst _close = Symbol('_close')\nconst _ended = Symbol('_ended')\nconst _fd = Symbol('_fd')\nconst _finished = Symbol('_finished')\nconst _flags = Symbol('_flags')\nconst _flush = Symbol('_flush')\nconst _handleChunk = Symbol('_handleChunk')\nconst _makeBuf = Symbol('_makeBuf')\nconst _mode = Symbol('_mode')\nconst _needDrain = Symbol('_needDrain')\nconst _onerror = Symbol('_onerror')\nconst _onopen = Symbol('_onopen')\nconst _onread = Symbol('_onread')\nconst _onwrite = Symbol('_onwrite')\nconst _open = Symbol('_open')\nconst _path = Symbol('_path')\nconst _pos = Symbol('_pos')\nconst _queue = Symbol('_queue')\nconst _read = Symbol('_read')\nconst _readSize = Symbol('_readSize')\nconst _reading = Symbol('_reading')\nconst _remain = Symbol('_remain')\nconst _size = Symbol('_size')\nconst _write = Symbol('_write')\nconst _writing = Symbol('_writing')\nconst _defaultFlag = Symbol('_defaultFlag')\n\nclass ReadStream extends MiniPass {\n  constructor (path, opt) {\n    opt = opt || {}\n    super(opt)\n\n    this.writable = false\n\n    if (typeof path !== 'string')\n      throw new TypeError('path must be a string')\n\n    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null\n    this[_path] = path\n    this[_readSize] = opt.readSize || 16*1024*1024\n    this[_reading] = false\n    this[_size] = typeof opt.size === 'number' ? opt.size : Infinity\n    this[_remain] = this[_size]\n    this[_autoClose] = typeof opt.autoClose === 'boolean' ?\n      opt.autoClose : true\n\n    if (typeof this[_fd] === 'number')\n      this[_read]()\n    else\n      this[_open]()\n  }\n\n  get fd () { return this[_fd] }\n  get path () { return this[_path] }\n\n  write () {\n    throw new TypeError('this is a readable stream')\n  }\n\n  end () {\n    throw new TypeError('this is a readable stream')\n  }\n\n  [_open] () {\n    fs.open(this[_path], 'r', (er, fd) => this[_onopen](er, fd))\n  }\n\n  [_onopen] (er, fd) {\n    if (er)\n      this[_onerror](er)\n    else {\n      this[_fd] = fd\n      this.emit('open', fd)\n      this[_read]()\n    }\n  }\n\n  [_makeBuf] () {\n    return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]))\n  }\n\n  [_read] () {\n    if (!this[_reading]) {\n      this[_reading] = true\n      const buf = this[_makeBuf]()\n      /* istanbul ignore if */\n      if (buf.length === 0) return process.nextTick(() => this[_onread](null, 0, buf))\n      fs.read(this[_fd], buf, 0, buf.length, null, (er, br, buf) =>\n        this[_onread](er, br, buf))\n    }\n  }\n\n  [_onread] (er, br, buf) {\n    this[_reading] = false\n    if (er)\n      this[_onerror](er)\n    else if (this[_handleChunk](br, buf))\n      this[_read]()\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      fs.close(this[_fd], _ => this.emit('close'))\n      this[_fd] = null\n    }\n  }\n\n  [_onerror] (er) {\n    this[_reading] = true\n    this[_close]()\n    this.emit('error', er)\n  }\n\n  [_handleChunk] (br, buf) {\n    let ret = false\n    // no effect if infinite\n    this[_remain] -= br\n    if (br > 0)\n      ret = super.write(br < buf.length ? buf.slice(0, br) : buf)\n\n    if (br === 0 || this[_remain] <= 0) {\n      ret = false\n      this[_close]()\n      super.end()\n    }\n\n    return ret\n  }\n\n  emit (ev, data) {\n    switch (ev) {\n      case 'prefinish':\n      case 'finish':\n        break\n\n      case 'drain':\n        if (typeof this[_fd] === 'number')\n          this[_read]()\n        break\n\n      default:\n        return super.emit(ev, data)\n    }\n  }\n}\n\nclass ReadStreamSync extends ReadStream {\n  [_open] () {\n    let threw = true\n    try {\n      this[_onopen](null, fs.openSync(this[_path], 'r'))\n      threw = false\n    } finally {\n      if (threw)\n        this[_close]()\n    }\n  }\n\n  [_read] () {\n    let threw = true\n    try {\n      if (!this[_reading]) {\n        this[_reading] = true\n        do {\n          const buf = this[_makeBuf]()\n          /* istanbul ignore next */\n          const br = buf.length === 0 ? 0 : fs.readSync(this[_fd], buf, 0, buf.length, null)\n          if (!this[_handleChunk](br, buf))\n            break\n        } while (true)\n        this[_reading] = false\n      }\n      threw = false\n    } finally {\n      if (threw)\n        this[_close]()\n    }\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      try {\n        fs.closeSync(this[_fd])\n      } catch (er) {}\n      this[_fd] = null\n      this.emit('close')\n    }\n  }\n}\n\nclass WriteStream extends EE {\n  constructor (path, opt) {\n    opt = opt || {}\n    super(opt)\n    this.readable = false\n    this[_writing] = false\n    this[_ended] = false\n    this[_needDrain] = false\n    this[_queue] = []\n    this[_path] = path\n    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null\n    this[_mode] = opt.mode === undefined ? 0o666 : opt.mode\n    this[_pos] = typeof opt.start === 'number' ? opt.start : null\n    this[_autoClose] = typeof opt.autoClose === 'boolean' ?\n      opt.autoClose : true\n\n    // truncating makes no sense when writing into the middle\n    const defaultFlag = this[_pos] !== null ? 'r+' : 'w'\n    this[_defaultFlag] = opt.flags === undefined\n    this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags\n\n    if (this[_fd] === null)\n      this[_open]()\n  }\n\n  get fd () { return this[_fd] }\n  get path () { return this[_path] }\n\n  [_onerror] (er) {\n    this[_close]()\n    this[_writing] = true\n    this.emit('error', er)\n  }\n\n  [_open] () {\n    fs.open(this[_path], this[_flags], this[_mode],\n      (er, fd) => this[_onopen](er, fd))\n  }\n\n  [_onopen] (er, fd) {\n    if (this[_defaultFlag] &&\n        this[_flags] === 'r+' &&\n        er && er.code === 'ENOENT') {\n      this[_flags] = 'w'\n      this[_open]()\n    } else if (er)\n      this[_onerror](er)\n    else {\n      this[_fd] = fd\n      this.emit('open', fd)\n      this[_flush]()\n    }\n  }\n\n  end (buf, enc) {\n    if (buf)\n      this.write(buf, enc)\n\n    this[_ended] = true\n\n    // synthetic after-write logic, where drain/finish live\n    if (!this[_writing] && !this[_queue].length &&\n        typeof this[_fd] === 'number')\n      this[_onwrite](null, 0)\n  }\n\n  write (buf, enc) {\n    if (typeof buf === 'string')\n      buf = new Buffer(buf, enc)\n\n    if (this[_ended]) {\n      this.emit('error', new Error('write() after end()'))\n      return false\n    }\n\n    if (this[_fd] === null || this[_writing] || this[_queue].length) {\n      this[_queue].push(buf)\n      this[_needDrain] = true\n      return false\n    }\n\n    this[_writing] = true\n    this[_write](buf)\n    return true\n  }\n\n  [_write] (buf) {\n    fs.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) =>\n      this[_onwrite](er, bw))\n  }\n\n  [_onwrite] (er, bw) {\n    if (er)\n      this[_onerror](er)\n    else {\n      if (this[_pos] !== null)\n        this[_pos] += bw\n      if (this[_queue].length)\n        this[_flush]()\n      else {\n        this[_writing] = false\n\n        if (this[_ended] && !this[_finished]) {\n          this[_finished] = true\n          this[_close]()\n          this.emit('finish')\n        } else if (this[_needDrain]) {\n          this[_needDrain] = false\n          this.emit('drain')\n        }\n      }\n    }\n  }\n\n  [_flush] () {\n    if (this[_queue].length === 0) {\n      if (this[_ended])\n        this[_onwrite](null, 0)\n    } else if (this[_queue].length === 1)\n      this[_write](this[_queue].pop())\n    else {\n      const iovec = this[_queue]\n      this[_queue] = []\n      writev(this[_fd], iovec, this[_pos],\n        (er, bw) => this[_onwrite](er, bw))\n    }\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      fs.close(this[_fd], _ => this.emit('close'))\n      this[_fd] = null\n    }\n  }\n}\n\nclass WriteStreamSync extends WriteStream {\n  [_open] () {\n    let fd\n    try {\n      fd = fs.openSync(this[_path], this[_flags], this[_mode])\n    } catch (er) {\n      if (this[_defaultFlag] &&\n          this[_flags] === 'r+' &&\n          er && er.code === 'ENOENT') {\n        this[_flags] = 'w'\n        return this[_open]()\n      } else\n        throw er\n    }\n    this[_onopen](null, fd)\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      try {\n        fs.closeSync(this[_fd])\n      } catch (er) {}\n      this[_fd] = null\n      this.emit('close')\n    }\n  }\n\n  [_write] (buf) {\n    try {\n      this[_onwrite](null,\n        fs.writeSync(this[_fd], buf, 0, buf.length, this[_pos]))\n    } catch (er) {\n      this[_onwrite](er, 0)\n    }\n  }\n}\n\nconst writev = (fd, iovec, pos, cb) => {\n  const done = (er, bw) => cb(er, bw, iovec)\n  const req = new FSReqWrap()\n  req.oncomplete = done\n  binding.writeBuffers(fd, iovec, pos, req)\n}\n\nexports.ReadStream = ReadStream\nexports.ReadStreamSync = ReadStreamSync\n\nexports.WriteStream = WriteStream\nexports.WriteStreamSync = WriteStreamSync\n","export const TOKEN_REF = '$jsii.byref';\nexport const TOKEN_DATE = '$jsii.date';\nexport const TOKEN_ENUM = '$jsii.enum';\n\nexport interface ObjRef {\n    [TOKEN_REF]: string;\n}\n\nexport function isObjRef(value: any): value is ObjRef {\n    return typeof value === 'object' && value !== null && TOKEN_REF in value;\n}\n\nexport interface WireDate {\n    [TOKEN_DATE]: string;\n}\n\nexport function isWireDate(value: any): value is WireDate {\n    return typeof value === 'object' && value !== null && TOKEN_DATE in value;\n}\n\nexport interface WireEnum {\n    [TOKEN_ENUM]: string;\n}\n\nexport function isWireEnum(value: any): value is WireEnum {\n    return typeof value === 'object' && value !== null && TOKEN_ENUM in value;\n}\n\nexport type Override = MethodOverride | PropertyOverride;\n\nexport interface MethodOverride {\n    method: string;\n    cookie?: string;\n}\n\nexport function isMethodOverride(value: Override): value is MethodOverride {\n    return (value as any).method != null;  // Python passes \"null\"\n}\n\nexport interface PropertyOverride {\n    property: string;\n    cookie?: string;\n}\n\nexport function isPropertyOverride(value: Override): value is PropertyOverride {\n    return (value as any).property != null;  // Python passes \"null\"\n}\n\nexport interface Callback {\n    cbid: string;\n    cookie: string | undefined;\n    invoke?: InvokeRequest;\n    get?: GetRequest;\n    set?: SetRequest;\n}\n\nexport interface HelloResponse {\n    hello: string;\n}\n\nexport interface LoadRequest {\n    /** The name of the assembly */\n    name: string;\n\n    /** Assembly version */\n    version: string;\n\n    /** The tarball of the package */\n    tarball: string;\n}\n\nexport interface LoadResponse {\n    assembly: string;\n    types: number;\n}\n\nexport interface CreateRequest {\n    fqn: string\n    args?: any[]\n    overrides?: Override[]\n}\n\n// tslint:disable-next-line:no-empty-interface\nexport interface CreateResponse extends ObjRef {\n\n}\n\nexport interface DelRequest {\n    objref: ObjRef;\n}\n\n// tslint:disable-next-line:no-empty-interface\nexport interface DelResponse {\n\n}\n\nexport interface GetRequest {\n    objref: ObjRef;\n    property: string;\n}\n\nexport interface StaticGetRequest {\n    fqn: string;\n    property: string;\n}\n\nexport interface GetResponse {\n    value: any;\n}\n\nexport interface StaticSetRequest {\n    fqn: string;\n    property: string;\n    value: any;\n}\n\nexport interface SetRequest {\n    objref: ObjRef;\n    property: string;\n    value: any;\n}\n\n// tslint:disable-next-line:no-empty-interface\nexport interface SetResponse {\n\n}\n\nexport interface StaticInvokeRequest  {\n    fqn: string;\n    method: string;\n    args?: any[];\n}\n\nexport interface InvokeRequest {\n    objref: ObjRef;\n    method: string;\n    args?: any[];\n}\n\nexport interface InvokeResponse {\n    result: any;\n}\n\nexport interface BeginRequest {\n    objref: ObjRef;\n    method: string;\n    args?: any[];\n}\n\nexport interface BeginResponse {\n    promiseid: string;\n}\n\nexport interface EndRequest {\n    promiseid: string;\n}\n\nexport interface EndResponse {\n    result: any;\n}\n\n// tslint:disable-next-line:no-empty-interface\nexport interface CallbacksRequest {\n}\n\nexport interface CallbacksResponse {\n    callbacks: Callback[];\n}\n\nexport interface CompleteRequest {\n    cbid: string;\n    err?: string;\n    result?: any;\n}\n\nexport interface CompleteResponse {\n    cbid: string;\n}\n\nexport interface NamingRequest {\n    assembly: string;\n}\n\nexport interface NamingResponse {\n    naming: { [language: string]: { [key: string]: any } | undefined };\n}\n\n// tslint:disable-next-line:no-empty-interface\nexport interface StatsRequest {\n}\n\nexport interface StatsResponse {\n    objectCount: number;\n}\n\nexport type KernelRequest =\n    LoadRequest |\n    CreateRequest |\n    DelRequest |\n    GetRequest |\n    SetRequest |\n    InvokeRequest |\n    BeginRequest |\n    EndRequest |\n    CallbacksRequest |\n    CompleteRequest |\n    NamingRequest |\n    StatsRequest;\n\nexport type KernelResponse =\n    HelloResponse |\n    LoadResponse |\n    CreateResponse |\n    DelResponse |\n    GetResponse |\n    SetResponse |\n    InvokeResponse |\n    BeginResponse |\n    EndResponse |\n    CallbacksResponse |\n    CompleteResponse |\n    NamingResponse |\n    StatsResponse;\n\nexport interface OkayResponse {\n    ok: any;\n}\n\nexport interface ErrorResponse {\n    error: string;\n    stack?: string;\n}\n","module.exports = require(\"assert\");","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\n\nconst NODE_VERSION_MAJOR_WITH_BIGINT = 10\nconst NODE_VERSION_MINOR_WITH_BIGINT = 5\nconst NODE_VERSION_PATCH_WITH_BIGINT = 0\nconst nodeVersion = process.versions.node.split('.')\nconst nodeVersionMajor = Number.parseInt(nodeVersion[0], 10)\nconst nodeVersionMinor = Number.parseInt(nodeVersion[1], 10)\nconst nodeVersionPatch = Number.parseInt(nodeVersion[2], 10)\n\nfunction nodeSupportsBigInt () {\n  if (nodeVersionMajor > NODE_VERSION_MAJOR_WITH_BIGINT) {\n    return true\n  } else if (nodeVersionMajor === NODE_VERSION_MAJOR_WITH_BIGINT) {\n    if (nodeVersionMinor > NODE_VERSION_MINOR_WITH_BIGINT) {\n      return true\n    } else if (nodeVersionMinor === NODE_VERSION_MINOR_WITH_BIGINT) {\n      if (nodeVersionPatch >= NODE_VERSION_PATCH_WITH_BIGINT) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\nfunction getStats (src, dest, cb) {\n  if (nodeSupportsBigInt()) {\n    fs.stat(src, { bigint: true }, (err, srcStat) => {\n      if (err) return cb(err)\n      fs.stat(dest, { bigint: true }, (err, destStat) => {\n        if (err) {\n          if (err.code === 'ENOENT') return cb(null, { srcStat, destStat: null })\n          return cb(err)\n        }\n        return cb(null, { srcStat, destStat })\n      })\n    })\n  } else {\n    fs.stat(src, (err, srcStat) => {\n      if (err) return cb(err)\n      fs.stat(dest, (err, destStat) => {\n        if (err) {\n          if (err.code === 'ENOENT') return cb(null, { srcStat, destStat: null })\n          return cb(err)\n        }\n        return cb(null, { srcStat, destStat })\n      })\n    })\n  }\n}\n\nfunction getStatsSync (src, dest) {\n  let srcStat, destStat\n  if (nodeSupportsBigInt()) {\n    srcStat = fs.statSync(src, { bigint: true })\n  } else {\n    srcStat = fs.statSync(src)\n  }\n  try {\n    if (nodeSupportsBigInt()) {\n      destStat = fs.statSync(dest, { bigint: true })\n    } else {\n      destStat = fs.statSync(dest)\n    }\n  } catch (err) {\n    if (err.code === 'ENOENT') return { srcStat, destStat: null }\n    throw err\n  }\n  return { srcStat, destStat }\n}\n\nfunction checkPaths (src, dest, funcName, cb) {\n  getStats(src, dest, (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat, destStat } = stats\n    if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n      return cb(new Error('Source and destination must not be the same.'))\n    }\n    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n      return cb(new Error(errMsg(src, dest, funcName)))\n    }\n    return cb(null, { srcStat, destStat })\n  })\n}\n\nfunction checkPathsSync (src, dest, funcName) {\n  const { srcStat, destStat } = getStatsSync(src, dest)\n  if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n    throw new Error('Source and destination must not be the same.')\n  }\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return { srcStat, destStat }\n}\n\n// recursively check if dest parent is a subdirectory of src.\n// It works for all file types including symlinks since it\n// checks the src and dest inodes. It starts from the deepest\n// parent and stops once it reaches the src parent or the root path.\nfunction checkParentPaths (src, srcStat, dest, funcName, cb) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return cb()\n  if (nodeSupportsBigInt()) {\n    fs.stat(destParent, { bigint: true }, (err, destStat) => {\n      if (err) {\n        if (err.code === 'ENOENT') return cb()\n        return cb(err)\n      }\n      if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n        return cb(new Error(errMsg(src, dest, funcName)))\n      }\n      return checkParentPaths(src, srcStat, destParent, funcName, cb)\n    })\n  } else {\n    fs.stat(destParent, (err, destStat) => {\n      if (err) {\n        if (err.code === 'ENOENT') return cb()\n        return cb(err)\n      }\n      if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n        return cb(new Error(errMsg(src, dest, funcName)))\n      }\n      return checkParentPaths(src, srcStat, destParent, funcName, cb)\n    })\n  }\n}\n\nfunction checkParentPathsSync (src, srcStat, dest, funcName) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return\n  let destStat\n  try {\n    if (nodeSupportsBigInt()) {\n      destStat = fs.statSync(destParent, { bigint: true })\n    } else {\n      destStat = fs.statSync(destParent)\n    }\n  } catch (err) {\n    if (err.code === 'ENOENT') return\n    throw err\n  }\n  if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return checkParentPathsSync(src, srcStat, destParent, funcName)\n}\n\n// return true if dest is a subdir of src, otherwise false.\n// It only checks the path strings.\nfunction isSrcSubdir (src, dest) {\n  const srcArr = path.resolve(src).split(path.sep).filter(i => i)\n  const destArr = path.resolve(dest).split(path.sep).filter(i => i)\n  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true)\n}\n\nfunction errMsg (src, dest, funcName) {\n  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`\n}\n\nmodule.exports = {\n  checkPaths,\n  checkPathsSync,\n  checkParentPaths,\n  checkParentPathsSync,\n  isSrcSubdir\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst rimraf = require('./rimraf')\n\nmodule.exports = {\n  remove: u(rimraf),\n  removeSync: rimraf.sync\n}\n","module.exports = require(\"events\");","'use strict'\nconst types = require('./types.js')\nconst MiniPass = require('minipass')\n\nconst SLURP = Symbol('slurp')\nmodule.exports = class ReadEntry extends MiniPass {\n  constructor (header, ex, gex) {\n    super()\n    this.extended = ex\n    this.globalExtended = gex\n    this.header = header\n    this.startBlockSize = 512 * Math.ceil(header.size / 512)\n    this.blockRemain = this.startBlockSize\n    this.remain = header.size\n    this.type = header.type\n    this.meta = false\n    this.ignore = false\n    switch (this.type) {\n      case 'File':\n      case 'OldFile':\n      case 'Link':\n      case 'SymbolicLink':\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'Directory':\n      case 'FIFO':\n      case 'ContiguousFile':\n      case 'GNUDumpDir':\n        break\n\n      case 'NextFileHasLongLinkpath':\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n      case 'GlobalExtendedHeader':\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        this.meta = true\n        break\n\n      // NOTE: gnutar and bsdtar treat unrecognized types as 'File'\n      // it may be worth doing the same, but with a warning.\n      default:\n        this.ignore = true\n    }\n\n    this.path = header.path\n    this.mode = header.mode\n    if (this.mode)\n      this.mode = this.mode & 0o7777\n    this.uid = header.uid\n    this.gid = header.gid\n    this.uname = header.uname\n    this.gname = header.gname\n    this.size = header.size\n    this.mtime = header.mtime\n    this.atime = header.atime\n    this.ctime = header.ctime\n    this.linkpath = header.linkpath\n    this.uname = header.uname\n    this.gname = header.gname\n\n    if (ex) this[SLURP](ex)\n    if (gex) this[SLURP](gex, true)\n  }\n\n  write (data) {\n    const writeLen = data.length\n    if (writeLen > this.blockRemain)\n      throw new Error('writing more to entry than is appropriate')\n\n    const r = this.remain\n    const br = this.blockRemain\n    this.remain = Math.max(0, r - writeLen)\n    this.blockRemain = Math.max(0, br - writeLen)\n    if (this.ignore)\n      return true\n\n    if (r >= writeLen)\n      return super.write(data)\n\n    // r < writeLen\n    return super.write(data.slice(0, r))\n  }\n\n  [SLURP] (ex, global) {\n    for (let k in ex) {\n      // we slurp in everything except for the path attribute in\n      // a global extended header, because that's weird.\n      if (ex[k] !== null && ex[k] !== undefined &&\n          !(global && k === 'path'))\n        this[k] = ex[k]\n    }\n  }\n}\n","'use strict'\n// map types from key to human-friendly name\nexports.name = new Map([\n  ['0', 'File'],\n  // same as File\n  ['', 'OldFile'],\n  ['1', 'Link'],\n  ['2', 'SymbolicLink'],\n  // Devices and FIFOs aren't fully supported\n  // they are parsed, but skipped when unpacking\n  ['3', 'CharacterDevice'],\n  ['4', 'BlockDevice'],\n  ['5', 'Directory'],\n  ['6', 'FIFO'],\n  // same as File\n  ['7', 'ContiguousFile'],\n  // pax headers\n  ['g', 'GlobalExtendedHeader'],\n  ['x', 'ExtendedHeader'],\n  // vendor-specific stuff\n  // skip\n  ['A', 'SolarisACL'],\n  // like 5, but with data, which should be skipped\n  ['D', 'GNUDumpDir'],\n  // metadata only, skip\n  ['I', 'Inode'],\n  // data = link path of next file\n  ['K', 'NextFileHasLongLinkpath'],\n  // data = path of next file\n  ['L', 'NextFileHasLongPath'],\n  // skip\n  ['M', 'ContinuationFile'],\n  // like L\n  ['N', 'OldGnuLongPath'],\n  // skip\n  ['S', 'SparseFile'],\n  // skip\n  ['V', 'TapeVolumeHeader'],\n  // like x\n  ['X', 'OldExtendedHeader']\n])\n\n// map the other direction\nexports.code = new Map(Array.from(exports.name).map(kv => [kv[1], kv[0]]))\n","'use strict'\n\n// this[BUFFER] is the remainder of a chunk if we're waiting for\n// the full 512 bytes of a header to come in.  We will Buffer.concat()\n// it to the next write(), which is a mem copy, but a small one.\n//\n// this[QUEUE] is a Yallist of entries that haven't been emitted\n// yet this can only get filled up if the user keeps write()ing after\n// a write() returns false, or does a write() with more than one entry\n//\n// We don't buffer chunks, we always parse them and either create an\n// entry, or push it into the active entry.  The ReadEntry class knows\n// to throw data away if .ignore=true\n//\n// Shift entry off the buffer when it emits 'end', and emit 'entry' for\n// the next one in the list.\n//\n// At any time, we're pushing body chunks into the entry at WRITEENTRY,\n// and waiting for 'end' on the entry at READENTRY\n//\n// ignored entries get .resume() called on them straight away\n\nconst warner = require('./warn-mixin.js')\nconst path = require('path')\nconst Header = require('./header.js')\nconst EE = require('events')\nconst Yallist = require('yallist')\nconst maxMetaEntrySize = 1024 * 1024\nconst Entry = require('./read-entry.js')\nconst Pax = require('./pax.js')\nconst zlib = require('minizlib')\nconst Buffer = require('./buffer.js')\n\nconst gzipHeader = Buffer.from([0x1f, 0x8b])\nconst STATE = Symbol('state')\nconst WRITEENTRY = Symbol('writeEntry')\nconst READENTRY = Symbol('readEntry')\nconst NEXTENTRY = Symbol('nextEntry')\nconst PROCESSENTRY = Symbol('processEntry')\nconst EX = Symbol('extendedHeader')\nconst GEX = Symbol('globalExtendedHeader')\nconst META = Symbol('meta')\nconst EMITMETA = Symbol('emitMeta')\nconst BUFFER = Symbol('buffer')\nconst QUEUE = Symbol('queue')\nconst ENDED = Symbol('ended')\nconst EMITTEDEND = Symbol('emittedEnd')\nconst EMIT = Symbol('emit')\nconst UNZIP = Symbol('unzip')\nconst CONSUMECHUNK = Symbol('consumeChunk')\nconst CONSUMECHUNKSUB = Symbol('consumeChunkSub')\nconst CONSUMEBODY = Symbol('consumeBody')\nconst CONSUMEMETA = Symbol('consumeMeta')\nconst CONSUMEHEADER = Symbol('consumeHeader')\nconst CONSUMING = Symbol('consuming')\nconst BUFFERCONCAT = Symbol('bufferConcat')\nconst MAYBEEND = Symbol('maybeEnd')\nconst WRITING = Symbol('writing')\nconst ABORTED = Symbol('aborted')\nconst DONE = Symbol('onDone')\n\nconst noop = _ => true\n\nmodule.exports = warner(class Parser extends EE {\n  constructor (opt) {\n    opt = opt || {}\n    super(opt)\n\n    if (opt.ondone)\n      this.on(DONE, opt.ondone)\n    else\n      this.on(DONE, _ => {\n        this.emit('prefinish')\n        this.emit('finish')\n        this.emit('end')\n        this.emit('close')\n      })\n\n    this.strict = !!opt.strict\n    this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize\n    this.filter = typeof opt.filter === 'function' ? opt.filter : noop\n\n    // have to set this so that streams are ok piping into it\n    this.writable = true\n    this.readable = false\n\n    this[QUEUE] = new Yallist()\n    this[BUFFER] = null\n    this[READENTRY] = null\n    this[WRITEENTRY] = null\n    this[STATE] = 'begin'\n    this[META] = ''\n    this[EX] = null\n    this[GEX] = null\n    this[ENDED] = false\n    this[UNZIP] = null\n    this[ABORTED] = false\n    if (typeof opt.onwarn === 'function')\n      this.on('warn', opt.onwarn)\n    if (typeof opt.onentry === 'function')\n      this.on('entry', opt.onentry)\n  }\n\n  [CONSUMEHEADER] (chunk, position) {\n    const header = new Header(chunk, position, this[EX], this[GEX])\n\n    if (header.nullBlock)\n      this[EMIT]('nullBlock')\n    else if (!header.cksumValid)\n      this.warn('invalid entry', header)\n    else if (!header.path)\n      this.warn('invalid: path is required', header)\n    else {\n      const type = header.type\n      if (/^(Symbolic)?Link$/.test(type) && !header.linkpath)\n        this.warn('invalid: linkpath required', header)\n      else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath)\n        this.warn('invalid: linkpath forbidden', header)\n      else {\n        const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX])\n\n        if (entry.meta) {\n          if (entry.size > this.maxMetaEntrySize) {\n            entry.ignore = true\n            this[EMIT]('ignoredEntry', entry)\n            this[STATE] = 'ignore'\n          } else if (entry.size > 0) {\n            this[META] = ''\n            entry.on('data', c => this[META] += c)\n            this[STATE] = 'meta'\n          }\n        } else {\n\n          this[EX] = null\n          entry.ignore = entry.ignore || !this.filter(entry.path, entry)\n          if (entry.ignore) {\n            this[EMIT]('ignoredEntry', entry)\n            this[STATE] = entry.remain ? 'ignore' : 'begin'\n          } else {\n            if (entry.remain)\n              this[STATE] = 'body'\n            else {\n              this[STATE] = 'begin'\n              entry.end()\n            }\n\n            if (!this[READENTRY]) {\n              this[QUEUE].push(entry)\n              this[NEXTENTRY]()\n            } else\n              this[QUEUE].push(entry)\n          }\n        }\n      }\n    }\n  }\n\n  [PROCESSENTRY] (entry) {\n    let go = true\n\n    if (!entry) {\n      this[READENTRY] = null\n      go = false\n    } else if (Array.isArray(entry))\n      this.emit.apply(this, entry)\n    else {\n      this[READENTRY] = entry\n      this.emit('entry', entry)\n      if (!entry.emittedEnd) {\n        entry.on('end', _ => this[NEXTENTRY]())\n        go = false\n      }\n    }\n\n    return go\n  }\n\n  [NEXTENTRY] () {\n    do {} while (this[PROCESSENTRY](this[QUEUE].shift()))\n\n    if (!this[QUEUE].length) {\n      // At this point, there's nothing in the queue, but we may have an\n      // entry which is being consumed (readEntry).\n      // If we don't, then we definitely can handle more data.\n      // If we do, and either it's flowing, or it has never had any data\n      // written to it, then it needs more.\n      // The only other possibility is that it has returned false from a\n      // write() call, so we wait for the next drain to continue.\n      const re = this[READENTRY]\n      const drainNow = !re || re.flowing || re.size === re.remain\n      if (drainNow) {\n        if (!this[WRITING])\n          this.emit('drain')\n      } else\n        re.once('drain', _ => this.emit('drain'))\n     }\n  }\n\n  [CONSUMEBODY] (chunk, position) {\n    // write up to but no  more than writeEntry.blockRemain\n    const entry = this[WRITEENTRY]\n    const br = entry.blockRemain\n    const c = (br >= chunk.length && position === 0) ? chunk\n      : chunk.slice(position, position + br)\n\n    entry.write(c)\n\n    if (!entry.blockRemain) {\n      this[STATE] = 'begin'\n      this[WRITEENTRY] = null\n      entry.end()\n    }\n\n    return c.length\n  }\n\n  [CONSUMEMETA] (chunk, position) {\n    const entry = this[WRITEENTRY]\n    const ret = this[CONSUMEBODY](chunk, position)\n\n    // if we finished, then the entry is reset\n    if (!this[WRITEENTRY])\n      this[EMITMETA](entry)\n\n    return ret\n  }\n\n  [EMIT] (ev, data, extra) {\n    if (!this[QUEUE].length && !this[READENTRY])\n      this.emit(ev, data, extra)\n    else\n      this[QUEUE].push([ev, data, extra])\n  }\n\n  [EMITMETA] (entry) {\n    this[EMIT]('meta', this[META])\n    switch (entry.type) {\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        this[EX] = Pax.parse(this[META], this[EX], false)\n        break\n\n      case 'GlobalExtendedHeader':\n        this[GEX] = Pax.parse(this[META], this[GEX], true)\n        break\n\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n        this[EX] = this[EX] || Object.create(null)\n        this[EX].path = this[META].replace(/\\0.*/, '')\n        break\n\n      case 'NextFileHasLongLinkpath':\n        this[EX] = this[EX] || Object.create(null)\n        this[EX].linkpath = this[META].replace(/\\0.*/, '')\n        break\n\n      /* istanbul ignore next */\n      default: throw new Error('unknown meta: ' + entry.type)\n    }\n  }\n\n  abort (msg, error) {\n    this[ABORTED] = true\n    this.warn(msg, error)\n    this.emit('abort', error)\n    this.emit('error', error)\n  }\n\n  write (chunk) {\n    if (this[ABORTED])\n      return\n\n    // first write, might be gzipped\n    if (this[UNZIP] === null && chunk) {\n      if (this[BUFFER]) {\n        chunk = Buffer.concat([this[BUFFER], chunk])\n        this[BUFFER] = null\n      }\n      if (chunk.length < gzipHeader.length) {\n        this[BUFFER] = chunk\n        return true\n      }\n      for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {\n        if (chunk[i] !== gzipHeader[i])\n          this[UNZIP] = false\n      }\n      if (this[UNZIP] === null) {\n        const ended = this[ENDED]\n        this[ENDED] = false\n        this[UNZIP] = new zlib.Unzip()\n        this[UNZIP].on('data', chunk => this[CONSUMECHUNK](chunk))\n        this[UNZIP].on('error', er =>\n          this.abort(er.message, er))\n        this[UNZIP].on('end', _ => {\n          this[ENDED] = true\n          this[CONSUMECHUNK]()\n        })\n        this[WRITING] = true\n        const ret = this[UNZIP][ended ? 'end' : 'write' ](chunk)\n        this[WRITING] = false\n        return ret\n      }\n    }\n\n    this[WRITING] = true\n    if (this[UNZIP])\n      this[UNZIP].write(chunk)\n    else\n      this[CONSUMECHUNK](chunk)\n    this[WRITING] = false\n\n    // return false if there's a queue, or if the current entry isn't flowing\n    const ret =\n      this[QUEUE].length ? false :\n      this[READENTRY] ? this[READENTRY].flowing :\n      true\n\n    // if we have no queue, then that means a clogged READENTRY\n    if (!ret && !this[QUEUE].length)\n      this[READENTRY].once('drain', _ => this.emit('drain'))\n\n    return ret\n  }\n\n  [BUFFERCONCAT] (c) {\n    if (c && !this[ABORTED])\n      this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c\n  }\n\n  [MAYBEEND] () {\n    if (this[ENDED] &&\n        !this[EMITTEDEND] &&\n        !this[ABORTED] &&\n        !this[CONSUMING]) {\n      this[EMITTEDEND] = true\n      const entry = this[WRITEENTRY]\n      if (entry && entry.blockRemain) {\n        const have = this[BUFFER] ? this[BUFFER].length : 0\n        this.warn('Truncated input (needed ' + entry.blockRemain +\n                  ' more bytes, only ' + have + ' available)', entry)\n        if (this[BUFFER])\n          entry.write(this[BUFFER])\n        entry.end()\n      }\n      this[EMIT](DONE)\n    }\n  }\n\n  [CONSUMECHUNK] (chunk) {\n    if (this[CONSUMING]) {\n      this[BUFFERCONCAT](chunk)\n    } else if (!chunk && !this[BUFFER]) {\n      this[MAYBEEND]()\n    } else {\n      this[CONSUMING] = true\n      if (this[BUFFER]) {\n        this[BUFFERCONCAT](chunk)\n        const c = this[BUFFER]\n        this[BUFFER] = null\n        this[CONSUMECHUNKSUB](c)\n      } else {\n        this[CONSUMECHUNKSUB](chunk)\n      }\n\n      while (this[BUFFER] && this[BUFFER].length >= 512 && !this[ABORTED]) {\n        const c = this[BUFFER]\n        this[BUFFER] = null\n        this[CONSUMECHUNKSUB](c)\n      }\n      this[CONSUMING] = false\n    }\n\n    if (!this[BUFFER] || this[ENDED])\n      this[MAYBEEND]()\n  }\n\n  [CONSUMECHUNKSUB] (chunk) {\n    // we know that we are in CONSUMING mode, so anything written goes into\n    // the buffer.  Advance the position and put any remainder in the buffer.\n    let position = 0\n    let length = chunk.length\n    while (position + 512 <= length && !this[ABORTED]) {\n      switch (this[STATE]) {\n        case 'begin':\n          this[CONSUMEHEADER](chunk, position)\n          position += 512\n          break\n\n        case 'ignore':\n        case 'body':\n          position += this[CONSUMEBODY](chunk, position)\n          break\n\n        case 'meta':\n          position += this[CONSUMEMETA](chunk, position)\n          break\n\n        /* istanbul ignore next */\n        default:\n          throw new Error('invalid state: ' + this[STATE])\n      }\n    }\n\n    if (position < length) {\n      if (this[BUFFER])\n        this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]])\n      else\n        this[BUFFER] = chunk.slice(position)\n    }\n  }\n\n  end (chunk) {\n    if (!this[ABORTED]) {\n      if (this[UNZIP])\n        this[UNZIP].end(chunk)\n      else {\n        this[ENDED] = true\n        this.write(chunk)\n      }\n    }\n  }\n})\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst jsonFile = require('jsonfile')\n\nmodule.exports = {\n  // jsonfile exports\n  readJson: u(jsonFile.readFile),\n  readJsonSync: jsonFile.readFileSync,\n  writeJson: u(jsonFile.writeFile),\n  writeJsonSync: jsonFile.writeFileSync\n}\n","module.exports = require(\"url\");","\nvar urilib = require('url');\nvar helpers = require('./helpers');\n\nmodule.exports.SchemaScanResult = SchemaScanResult;\nfunction SchemaScanResult(found, ref){\n  this.id = found;\n  this.ref = ref;\n}\n\n/**\n * Adds a schema with a certain urn to the Validator instance.\n * @param string uri\n * @param object schema\n * @return {Object}\n */\nmodule.exports.scan = function scan(base, schema){\n  function scanSchema(baseuri, schema){\n    if(!schema || typeof schema!='object') return;\n    // Mark all referenced schemas so we can tell later which schemas are referred to, but never defined\n    if(schema.$ref){\n      var resolvedUri = urilib.resolve(baseuri, schema.$ref);\n      ref[resolvedUri] = ref[resolvedUri] ? ref[resolvedUri]+1 : 0;\n      return;\n    }\n    var ourBase = schema.id ? urilib.resolve(baseuri, schema.id) : baseuri;\n    if (ourBase) {\n      // If there's no fragment, append an empty one\n      if(ourBase.indexOf('#')<0) ourBase += '#';\n      if(found[ourBase]){\n        if(!helpers.deepCompareStrict(found[ourBase], schema)){\n          throw new Error('Schema <'+schema+'> already exists with different definition');\n        }\n        return found[ourBase];\n      }\n      found[ourBase] = schema;\n      // strip trailing fragment\n      if(ourBase[ourBase.length-1]=='#'){\n        found[ourBase.substring(0, ourBase.length-1)] = schema;\n      }\n    }\n    scanArray(ourBase+'/items', ((schema.items instanceof Array)?schema.items:[schema.items]));\n    scanArray(ourBase+'/extends', ((schema.extends instanceof Array)?schema.extends:[schema.extends]));\n    scanSchema(ourBase+'/additionalItems', schema.additionalItems);\n    scanObject(ourBase+'/properties', schema.properties);\n    scanSchema(ourBase+'/additionalProperties', schema.additionalProperties);\n    scanObject(ourBase+'/definitions', schema.definitions);\n    scanObject(ourBase+'/patternProperties', schema.patternProperties);\n    scanObject(ourBase+'/dependencies', schema.dependencies);\n    scanArray(ourBase+'/disallow', schema.disallow);\n    scanArray(ourBase+'/allOf', schema.allOf);\n    scanArray(ourBase+'/anyOf', schema.anyOf);\n    scanArray(ourBase+'/oneOf', schema.oneOf);\n    scanSchema(ourBase+'/not', schema.not);\n  }\n  function scanArray(baseuri, schemas){\n    if(!(schemas instanceof Array)) return;\n    for(var i=0; i<schemas.length; i++){\n      scanSchema(baseuri+'/'+i, schemas[i]);\n    }\n  }\n  function scanObject(baseuri, schemas){\n    if(!schemas || typeof schemas!='object') return;\n    for(var p in schemas){\n      scanSchema(baseuri+'/'+p, schemas[p]);\n    }\n  }\n\n  var found = {};\n  var ref = {};\n  var schemaUri = base;\n  scanSchema(base, schema);\n  return new SchemaScanResult(found, ref);\n}\n","'use strict'\n\nconst Buffer = require('./buffer.js')\n\n// A readable tar stream creator\n// Technically, this is a transform stream that you write paths into,\n// and tar format comes out of.\n// The `add()` method is like `write()` but returns this,\n// and end() return `this` as well, so you can\n// do `new Pack(opt).add('files').add('dir').end().pipe(output)\n// You could also do something like:\n// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))\n\nclass PackJob {\n  constructor (path, absolute) {\n    this.path = path || './'\n    this.absolute = absolute\n    this.entry = null\n    this.stat = null\n    this.readdir = null\n    this.pending = false\n    this.ignore = false\n    this.piped = false\n  }\n}\n\nconst MiniPass = require('minipass')\nconst zlib = require('minizlib')\nconst ReadEntry = require('./read-entry.js')\nconst WriteEntry = require('./write-entry.js')\nconst WriteEntrySync = WriteEntry.Sync\nconst WriteEntryTar = WriteEntry.Tar\nconst Yallist = require('yallist')\nconst EOF = Buffer.alloc(1024)\nconst ONSTAT = Symbol('onStat')\nconst ENDED = Symbol('ended')\nconst QUEUE = Symbol('queue')\nconst CURRENT = Symbol('current')\nconst PROCESS = Symbol('process')\nconst PROCESSING = Symbol('processing')\nconst PROCESSJOB = Symbol('processJob')\nconst JOBS = Symbol('jobs')\nconst JOBDONE = Symbol('jobDone')\nconst ADDFSENTRY = Symbol('addFSEntry')\nconst ADDTARENTRY = Symbol('addTarEntry')\nconst STAT = Symbol('stat')\nconst READDIR = Symbol('readdir')\nconst ONREADDIR = Symbol('onreaddir')\nconst PIPE = Symbol('pipe')\nconst ENTRY = Symbol('entry')\nconst ENTRYOPT = Symbol('entryOpt')\nconst WRITEENTRYCLASS = Symbol('writeEntryClass')\nconst WRITE = Symbol('write')\nconst ONDRAIN = Symbol('ondrain')\n\nconst fs = require('fs')\nconst path = require('path')\nconst warner = require('./warn-mixin.js')\n\nconst Pack = warner(class Pack extends MiniPass {\n  constructor (opt) {\n    super(opt)\n    opt = opt || Object.create(null)\n    this.opt = opt\n    this.cwd = opt.cwd || process.cwd()\n    this.maxReadSize = opt.maxReadSize\n    this.preservePaths = !!opt.preservePaths\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.prefix = (opt.prefix || '').replace(/(\\\\|\\/)+$/, '')\n    this.linkCache = opt.linkCache || new Map()\n    this.statCache = opt.statCache || new Map()\n    this.readdirCache = opt.readdirCache || new Map()\n\n    this[WRITEENTRYCLASS] = WriteEntry\n    if (typeof opt.onwarn === 'function')\n      this.on('warn', opt.onwarn)\n\n    this.zip = null\n    if (opt.gzip) {\n      if (typeof opt.gzip !== 'object')\n        opt.gzip = {}\n      this.zip = new zlib.Gzip(opt.gzip)\n      this.zip.on('data', chunk => super.write(chunk))\n      this.zip.on('end', _ => super.end())\n      this.zip.on('drain', _ => this[ONDRAIN]())\n      this.on('resume', _ => this.zip.resume())\n    } else\n      this.on('drain', this[ONDRAIN])\n\n    this.portable = !!opt.portable\n    this.noDirRecurse = !!opt.noDirRecurse\n    this.follow = !!opt.follow\n    this.noMtime = !!opt.noMtime\n    this.mtime = opt.mtime || null\n\n    this.filter = typeof opt.filter === 'function' ? opt.filter : _ => true\n\n    this[QUEUE] = new Yallist\n    this[JOBS] = 0\n    this.jobs = +opt.jobs || 4\n    this[PROCESSING] = false\n    this[ENDED] = false\n  }\n\n  [WRITE] (chunk) {\n    return super.write(chunk)\n  }\n\n  add (path) {\n    this.write(path)\n    return this\n  }\n\n  end (path) {\n    if (path)\n      this.write(path)\n    this[ENDED] = true\n    this[PROCESS]()\n    return this\n  }\n\n  write (path) {\n    if (this[ENDED])\n      throw new Error('write after end')\n\n    if (path instanceof ReadEntry)\n      this[ADDTARENTRY](path)\n    else\n      this[ADDFSENTRY](path)\n    return this.flowing\n  }\n\n  [ADDTARENTRY] (p) {\n    const absolute = path.resolve(this.cwd, p.path)\n    if (this.prefix)\n      p.path = this.prefix + '/' + p.path.replace(/^\\.(\\/+|$)/, '')\n\n    // in this case, we don't have to wait for the stat\n    if (!this.filter(p.path, p))\n      p.resume()\n    else {\n      const job = new PackJob(p.path, absolute, false)\n      job.entry = new WriteEntryTar(p, this[ENTRYOPT](job))\n      job.entry.on('end', _ => this[JOBDONE](job))\n      this[JOBS] += 1\n      this[QUEUE].push(job)\n    }\n\n    this[PROCESS]()\n  }\n\n  [ADDFSENTRY] (p) {\n    const absolute = path.resolve(this.cwd, p)\n    if (this.prefix)\n      p = this.prefix + '/' + p.replace(/^\\.(\\/+|$)/, '')\n\n    this[QUEUE].push(new PackJob(p, absolute))\n    this[PROCESS]()\n  }\n\n  [STAT] (job) {\n    job.pending = true\n    this[JOBS] += 1\n    const stat = this.follow ? 'stat' : 'lstat'\n    fs[stat](job.absolute, (er, stat) => {\n      job.pending = false\n      this[JOBS] -= 1\n      if (er)\n        this.emit('error', er)\n      else\n        this[ONSTAT](job, stat)\n    })\n  }\n\n  [ONSTAT] (job, stat) {\n    this.statCache.set(job.absolute, stat)\n    job.stat = stat\n\n    // now we have the stat, we can filter it.\n    if (!this.filter(job.path, stat))\n      job.ignore = true\n\n    this[PROCESS]()\n  }\n\n  [READDIR] (job) {\n    job.pending = true\n    this[JOBS] += 1\n    fs.readdir(job.absolute, (er, entries) => {\n      job.pending = false\n      this[JOBS] -= 1\n      if (er)\n        return this.emit('error', er)\n      this[ONREADDIR](job, entries)\n    })\n  }\n\n  [ONREADDIR] (job, entries) {\n    this.readdirCache.set(job.absolute, entries)\n    job.readdir = entries\n    this[PROCESS]()\n  }\n\n  [PROCESS] () {\n    if (this[PROCESSING])\n      return\n\n    this[PROCESSING] = true\n    for (let w = this[QUEUE].head;\n         w !== null && this[JOBS] < this.jobs;\n         w = w.next) {\n      this[PROCESSJOB](w.value)\n      if (w.value.ignore) {\n        const p = w.next\n        this[QUEUE].removeNode(w)\n        w.next = p\n      }\n    }\n\n    this[PROCESSING] = false\n\n    if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {\n      if (this.zip)\n        this.zip.end(EOF)\n      else {\n        super.write(EOF)\n        super.end()\n      }\n    }\n  }\n\n  get [CURRENT] () {\n    return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value\n  }\n\n  [JOBDONE] (job) {\n    this[QUEUE].shift()\n    this[JOBS] -= 1\n    this[PROCESS]()\n  }\n\n  [PROCESSJOB] (job) {\n    if (job.pending)\n      return\n\n    if (job.entry) {\n      if (job === this[CURRENT] && !job.piped)\n        this[PIPE](job)\n      return\n    }\n\n    if (!job.stat) {\n      if (this.statCache.has(job.absolute))\n        this[ONSTAT](job, this.statCache.get(job.absolute))\n      else\n        this[STAT](job)\n    }\n    if (!job.stat)\n      return\n\n    // filtered out!\n    if (job.ignore)\n      return\n\n    if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {\n      if (this.readdirCache.has(job.absolute))\n        this[ONREADDIR](job, this.readdirCache.get(job.absolute))\n      else\n        this[READDIR](job)\n      if (!job.readdir)\n        return\n    }\n\n    // we know it doesn't have an entry, because that got checked above\n    job.entry = this[ENTRY](job)\n    if (!job.entry) {\n      job.ignore = true\n      return\n    }\n\n    if (job === this[CURRENT] && !job.piped)\n      this[PIPE](job)\n  }\n\n  [ENTRYOPT] (job) {\n    return {\n      onwarn: (msg, data) => {\n        this.warn(msg, data)\n      },\n      noPax: this.noPax,\n      cwd: this.cwd,\n      absolute: job.absolute,\n      preservePaths: this.preservePaths,\n      maxReadSize: this.maxReadSize,\n      strict: this.strict,\n      portable: this.portable,\n      linkCache: this.linkCache,\n      statCache: this.statCache,\n      noMtime: this.noMtime,\n      mtime: this.mtime\n    }\n  }\n\n  [ENTRY] (job) {\n    this[JOBS] += 1\n    try {\n      return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job))\n        .on('end', () => this[JOBDONE](job))\n        .on('error', er => this.emit('error', er))\n    } catch (er) {\n      this.emit('error', er)\n    }\n  }\n\n  [ONDRAIN] () {\n    if (this[CURRENT] && this[CURRENT].entry)\n      this[CURRENT].entry.resume()\n  }\n\n  // like .pipe() but using super, because our write() is special\n  [PIPE] (job) {\n    job.piped = true\n\n    if (job.readdir)\n      job.readdir.forEach(entry => {\n        const p = this.prefix ?\n          job.path.slice(this.prefix.length + 1) || './'\n          : job.path\n\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/')\n        this[ADDFSENTRY](base + entry)\n      })\n\n    const source = job.entry\n    const zip = this.zip\n\n    if (zip)\n      source.on('data', chunk => {\n        if (!zip.write(chunk))\n          source.pause()\n      })\n    else\n      source.on('data', chunk => {\n        if (!super.write(chunk))\n          source.pause()\n      })\n  }\n\n  pause () {\n    if (this.zip)\n      this.zip.pause()\n    return super.pause()\n  }\n})\n\nclass PackSync extends Pack {\n  constructor (opt) {\n    super(opt)\n    this[WRITEENTRYCLASS] = WriteEntrySync\n  }\n\n  // pause/resume are no-ops in sync streams.\n  pause () {}\n  resume () {}\n\n  [STAT] (job) {\n    const stat = this.follow ? 'statSync' : 'lstatSync'\n    this[ONSTAT](job, fs[stat](job.absolute))\n  }\n\n  [READDIR] (job, stat) {\n    this[ONREADDIR](job, fs.readdirSync(job.absolute))\n  }\n\n  // gotta get it all in this tick\n  [PIPE] (job) {\n    const source = job.entry\n    const zip = this.zip\n\n    if (job.readdir)\n      job.readdir.forEach(entry => {\n        const p = this.prefix ?\n          job.path.slice(this.prefix.length + 1) || './'\n          : job.path\n\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/')\n        this[ADDFSENTRY](base + entry)\n      })\n\n    if (zip)\n      source.on('data', chunk => {\n        zip.write(chunk)\n      })\n    else\n      source.on('data', chunk => {\n        super[WRITE](chunk)\n      })\n  }\n}\n\nPack.Sync = PackSync\n\nmodule.exports = Pack\n","'use strict'\nmodule.exports = Yallist\n\nYallist.Node = Node\nYallist.create = Yallist\n\nfunction Yallist (list) {\n  var self = this\n  if (!(self instanceof Yallist)) {\n    self = new Yallist()\n  }\n\n  self.tail = null\n  self.head = null\n  self.length = 0\n\n  if (list && typeof list.forEach === 'function') {\n    list.forEach(function (item) {\n      self.push(item)\n    })\n  } else if (arguments.length > 0) {\n    for (var i = 0, l = arguments.length; i < l; i++) {\n      self.push(arguments[i])\n    }\n  }\n\n  return self\n}\n\nYallist.prototype.removeNode = function (node) {\n  if (node.list !== this) {\n    throw new Error('removing node which does not belong to this list')\n  }\n\n  var next = node.next\n  var prev = node.prev\n\n  if (next) {\n    next.prev = prev\n  }\n\n  if (prev) {\n    prev.next = next\n  }\n\n  if (node === this.head) {\n    this.head = next\n  }\n  if (node === this.tail) {\n    this.tail = prev\n  }\n\n  node.list.length--\n  node.next = null\n  node.prev = null\n  node.list = null\n}\n\nYallist.prototype.unshiftNode = function (node) {\n  if (node === this.head) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var head = this.head\n  node.list = this\n  node.next = head\n  if (head) {\n    head.prev = node\n  }\n\n  this.head = node\n  if (!this.tail) {\n    this.tail = node\n  }\n  this.length++\n}\n\nYallist.prototype.pushNode = function (node) {\n  if (node === this.tail) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var tail = this.tail\n  node.list = this\n  node.prev = tail\n  if (tail) {\n    tail.next = node\n  }\n\n  this.tail = node\n  if (!this.head) {\n    this.head = node\n  }\n  this.length++\n}\n\nYallist.prototype.push = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    push(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.unshift = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    unshift(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.pop = function () {\n  if (!this.tail) {\n    return undefined\n  }\n\n  var res = this.tail.value\n  this.tail = this.tail.prev\n  if (this.tail) {\n    this.tail.next = null\n  } else {\n    this.head = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.shift = function () {\n  if (!this.head) {\n    return undefined\n  }\n\n  var res = this.head.value\n  this.head = this.head.next\n  if (this.head) {\n    this.head.prev = null\n  } else {\n    this.tail = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.head, i = 0; walker !== null; i++) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.next\n  }\n}\n\nYallist.prototype.forEachReverse = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.prev\n  }\n}\n\nYallist.prototype.get = function (n) {\n  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.next\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.getReverse = function (n) {\n  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.prev\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.map = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.head; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.next\n  }\n  return res\n}\n\nYallist.prototype.mapReverse = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.tail; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.prev\n  }\n  return res\n}\n\nYallist.prototype.reduce = function (fn, initial) {\n  var acc\n  var walker = this.head\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.head) {\n    walker = this.head.next\n    acc = this.head.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = 0; walker !== null; i++) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.next\n  }\n\n  return acc\n}\n\nYallist.prototype.reduceReverse = function (fn, initial) {\n  var acc\n  var walker = this.tail\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.tail) {\n    walker = this.tail.prev\n    acc = this.tail.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = this.length - 1; walker !== null; i--) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.prev\n  }\n\n  return acc\n}\n\nYallist.prototype.toArray = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.head; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.next\n  }\n  return arr\n}\n\nYallist.prototype.toArrayReverse = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.tail; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.prev\n  }\n  return arr\n}\n\nYallist.prototype.slice = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {\n    walker = walker.next\n  }\n  for (; walker !== null && i < to; i++, walker = walker.next) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.sliceReverse = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {\n    walker = walker.prev\n  }\n  for (; walker !== null && i > from; i--, walker = walker.prev) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.reverse = function () {\n  var head = this.head\n  var tail = this.tail\n  for (var walker = head; walker !== null; walker = walker.prev) {\n    var p = walker.prev\n    walker.prev = walker.next\n    walker.next = p\n  }\n  this.head = tail\n  this.tail = head\n  return this\n}\n\nfunction push (self, item) {\n  self.tail = new Node(item, self.tail, null, self)\n  if (!self.head) {\n    self.head = self.tail\n  }\n  self.length++\n}\n\nfunction unshift (self, item) {\n  self.head = new Node(item, null, self.head, self)\n  if (!self.tail) {\n    self.tail = self.head\n  }\n  self.length++\n}\n\nfunction Node (value, prev, next, list) {\n  if (!(this instanceof Node)) {\n    return new Node(value, prev, next, list)\n  }\n\n  this.list = list\n  this.value = value\n\n  if (prev) {\n    prev.next = this\n    this.prev = prev\n  } else {\n    this.prev = null\n  }\n\n  if (next) {\n    next.prev = this\n    this.next = next\n  } else {\n    this.next = null\n  }\n}\n\ntry {\n  // add if support for Symbol.iterator is present\n  require('./iterator.js')(Yallist)\n} catch (er) {}\n","'use strict'\nconst Buffer = require('./buffer.js')\nconst Header = require('./header.js')\nconst path = require('path')\n\nclass Pax {\n  constructor (obj, global) {\n    this.atime = obj.atime || null\n    this.charset = obj.charset || null\n    this.comment = obj.comment || null\n    this.ctime = obj.ctime || null\n    this.gid = obj.gid || null\n    this.gname = obj.gname || null\n    this.linkpath = obj.linkpath || null\n    this.mtime = obj.mtime || null\n    this.path = obj.path || null\n    this.size = obj.size || null\n    this.uid = obj.uid || null\n    this.uname = obj.uname || null\n    this.dev = obj.dev || null\n    this.ino = obj.ino || null\n    this.nlink = obj.nlink || null\n    this.global = global || false\n  }\n\n  encode () {\n    const body = this.encodeBody()\n    if (body === '')\n      return null\n\n    const bodyLen = Buffer.byteLength(body)\n    // round up to 512 bytes\n    // add 512 for header\n    const bufLen = 512 * Math.ceil(1 + bodyLen / 512)\n    const buf = Buffer.allocUnsafe(bufLen)\n\n    // 0-fill the header section, it might not hit every field\n    for (let i = 0; i < 512; i++) {\n      buf[i] = 0\n    }\n\n    new Header({\n      // XXX split the path\n      // then the path should be PaxHeader + basename, but less than 99,\n      // prepend with the dirname\n      path: ('PaxHeader/' + path.basename(this.path)).slice(0, 99),\n      mode: this.mode || 0o644,\n      uid: this.uid || null,\n      gid: this.gid || null,\n      size: bodyLen,\n      mtime: this.mtime || null,\n      type: this.global ? 'GlobalExtendedHeader' : 'ExtendedHeader',\n      linkpath: '',\n      uname: this.uname || '',\n      gname: this.gname || '',\n      devmaj: 0,\n      devmin: 0,\n      atime: this.atime || null,\n      ctime: this.ctime || null\n    }).encode(buf)\n\n    buf.write(body, 512, bodyLen, 'utf8')\n\n    // null pad after the body\n    for (let i = bodyLen + 512; i < buf.length; i++) {\n      buf[i] = 0\n    }\n\n    return buf\n  }\n\n  encodeBody () {\n    return (\n      this.encodeField('path') +\n      this.encodeField('ctime') +\n      this.encodeField('atime') +\n      this.encodeField('dev') +\n      this.encodeField('ino') +\n      this.encodeField('nlink') +\n      this.encodeField('charset') +\n      this.encodeField('comment') +\n      this.encodeField('gid') +\n      this.encodeField('gname') +\n      this.encodeField('linkpath') +\n      this.encodeField('mtime') +\n      this.encodeField('size') +\n      this.encodeField('uid') +\n      this.encodeField('uname')\n    )\n  }\n\n  encodeField (field) {\n    if (this[field] === null || this[field] === undefined)\n      return ''\n    const v = this[field] instanceof Date ? this[field].getTime() / 1000\n      : this[field]\n    const s = ' ' +\n      (field === 'dev' || field === 'ino' || field === 'nlink'\n       ? 'SCHILY.' : '') +\n      field + '=' + v + '\\n'\n    const byteLen = Buffer.byteLength(s)\n    // the digits includes the length of the digits in ascii base-10\n    // so if it's 9 characters, then adding 1 for the 9 makes it 10\n    // which makes it 11 chars.\n    let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1\n    if (byteLen + digits >= Math.pow(10, digits))\n      digits += 1\n    const len = digits + byteLen\n    return len + s\n  }\n}\n\nPax.parse = (string, ex, g) => new Pax(merge(parseKV(string), ex), g)\n\nconst merge = (a, b) =>\n  b ? Object.keys(a).reduce((s, k) => (s[k] = a[k], s), b) : a\n\nconst parseKV = string =>\n  string\n    .replace(/\\n$/, '')\n    .split('\\n')\n    .reduce(parseKVLine, Object.create(null))\n\nconst parseKVLine = (set, line) => {\n  const n = parseInt(line, 10)\n\n  // XXX Values with \\n in them will fail this.\n  // Refactor to not be a naive line-by-line parse.\n  if (n !== Buffer.byteLength(line) + 1)\n    return set\n\n  line = line.substr((n + ' ').length)\n  const kv = line.split('=')\n  const k = kv.shift().replace(/^SCHILY\\.(dev|ino|nlink)/, '$1')\n  if (!k)\n    return set\n\n  const v = kv.join('=')\n  set[k] = /^([A-Z]+\\.)?([mac]|birth|creation)time$/.test(k)\n    ?  new Date(v * 1000)\n    : /^[0-9]+$/.test(v) ? +v\n    : v\n  return set\n}\n\nmodule.exports = Pax\n","'use strict'\nmodule.exports = Base => class extends Base {\n  warn (msg, data) {\n    if (!this.strict)\n      this.emit('warn', msg, data)\n    else if (data instanceof Error)\n      this.emit('error', data)\n    else {\n      const er = new Error(msg)\n      er.data = data\n      this.emit('error', er)\n    }\n  }\n}\n","'use strict'\n\nconst Buffer = require('./buffer.js')\n\n// XXX: This shares a lot in common with extract.js\n// maybe some DRY opportunity here?\n\n// tar -t\nconst hlo = require('./high-level-opt.js')\nconst Parser = require('./parse.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst path = require('path')\n\nconst t = module.exports = (opt_, files, cb) => {\n  if (typeof opt_ === 'function')\n    cb = opt_, files = null, opt_ = {}\n  else if (Array.isArray(opt_))\n    files = opt_, opt_ = {}\n\n  if (typeof files === 'function')\n    cb = files, files = null\n\n  if (!files)\n    files = []\n  else\n    files = Array.from(files)\n\n  const opt = hlo(opt_)\n\n  if (opt.sync && typeof cb === 'function')\n    throw new TypeError('callback not supported for sync tar functions')\n\n  if (!opt.file && typeof cb === 'function')\n    throw new TypeError('callback only supported with file option')\n\n  if (files.length)\n    filesFilter(opt, files)\n\n  if (!opt.noResume)\n    onentryFunction(opt)\n\n  return opt.file && opt.sync ? listFileSync(opt)\n    : opt.file ? listFile(opt, cb)\n    : list(opt)\n}\n\nconst onentryFunction = opt => {\n  const onentry = opt.onentry\n  opt.onentry = onentry ? e => {\n    onentry(e)\n    e.resume()\n  } : e => e.resume()\n}\n\n// construct a filter that limits the file entries listed\n// include child entries if a dir is included\nconst filesFilter = (opt, files) => {\n  const map = new Map(files.map(f => [f.replace(/\\/+$/, ''), true]))\n  const filter = opt.filter\n\n  const mapHas = (file, r) => {\n    const root = r || path.parse(file).root || '.'\n    const ret = file === root ? false\n      : map.has(file) ? map.get(file)\n      : mapHas(path.dirname(file), root)\n\n    map.set(file, ret)\n    return ret\n  }\n\n  opt.filter = filter\n    ? (file, entry) => filter(file, entry) && mapHas(file.replace(/\\/+$/, ''))\n    : file => mapHas(file.replace(/\\/+$/, ''))\n}\n\nconst listFileSync = opt => {\n  const p = list(opt)\n  const file = opt.file\n  let threw = true\n  let fd\n  try {\n    const stat = fs.statSync(file)\n    const readSize = opt.maxReadSize || 16*1024*1024\n    if (stat.size < readSize) {\n      p.end(fs.readFileSync(file))\n    } else {\n      let pos = 0\n      const buf = Buffer.allocUnsafe(readSize)\n      fd = fs.openSync(file, 'r')\n      while (pos < stat.size) {\n        let bytesRead = fs.readSync(fd, buf, 0, readSize, pos)\n        pos += bytesRead\n        p.write(buf.slice(0, bytesRead))\n      }\n      p.end()\n    }\n    threw = false\n  } finally {\n    if (threw && fd)\n      try { fs.closeSync(fd) } catch (er) {}\n  }\n}\n\nconst listFile = (opt, cb) => {\n  const parse = new Parser(opt)\n  const readSize = opt.maxReadSize || 16*1024*1024\n\n  const file = opt.file\n  const p = new Promise((resolve, reject) => {\n    parse.on('error', reject)\n    parse.on('end', resolve)\n\n    fs.stat(file, (er, stat) => {\n      if (er)\n        reject(er)\n      else {\n        const stream = new fsm.ReadStream(file, {\n          readSize: readSize,\n          size: stat.size\n        })\n        stream.on('error', reject)\n        stream.pipe(parse)\n      }\n    })\n  })\n  return cb ? p.then(cb, cb) : p\n}\n\nconst list = opt => new Parser(opt)\n","'use strict'\n// This is adapted from https://github.com/normalize/mz\n// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors\nconst u = require('universalify').fromCallback\nconst fs = require('graceful-fs')\n\nconst api = [\n  'access',\n  'appendFile',\n  'chmod',\n  'chown',\n  'close',\n  'copyFile',\n  'fchmod',\n  'fchown',\n  'fdatasync',\n  'fstat',\n  'fsync',\n  'ftruncate',\n  'futimes',\n  'lchown',\n  'lchmod',\n  'link',\n  'lstat',\n  'mkdir',\n  'mkdtemp',\n  'open',\n  'readFile',\n  'readdir',\n  'readlink',\n  'realpath',\n  'rename',\n  'rmdir',\n  'stat',\n  'symlink',\n  'truncate',\n  'unlink',\n  'utimes',\n  'writeFile'\n].filter(key => {\n  // Some commands are not available on some systems. Ex:\n  // fs.copyFile was added in Node.js v8.5.0\n  // fs.mkdtemp was added in Node.js v5.10.0\n  // fs.lchown is not available on at least some Linux\n  return typeof fs[key] === 'function'\n})\n\n// Export all keys:\nObject.keys(fs).forEach(key => {\n  if (key === 'promises') {\n    // fs.promises is a getter property that triggers ExperimentalWarning\n    // Don't re-export it here, the getter is defined in \"lib/index.js\"\n    return\n  }\n  exports[key] = fs[key]\n})\n\n// Universalify async methods:\napi.forEach(method => {\n  exports[method] = u(fs[method])\n})\n\n// We differ from mz/fs in that we still ship the old, broken, fs.exists()\n// since we are a drop-in replacement for the native module\nexports.exists = function (filename, callback) {\n  if (typeof callback === 'function') {\n    return fs.exists(filename, callback)\n  }\n  return new Promise(resolve => {\n    return fs.exists(filename, resolve)\n  })\n}\n\n// fs.read() & fs.write need special treatment due to multiple callback args\n\nexports.read = function (fd, buffer, offset, length, position, callback) {\n  if (typeof callback === 'function') {\n    return fs.read(fd, buffer, offset, length, position, callback)\n  }\n  return new Promise((resolve, reject) => {\n    fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {\n      if (err) return reject(err)\n      resolve({ bytesRead, buffer })\n    })\n  })\n}\n\n// Function signature can be\n// fs.write(fd, buffer[, offset[, length[, position]]], callback)\n// OR\n// fs.write(fd, string[, position[, encoding]], callback)\n// We need to handle both cases, so we use ...args\nexports.write = function (fd, buffer, ...args) {\n  if (typeof args[args.length - 1] === 'function') {\n    return fs.write(fd, buffer, ...args)\n  }\n\n  return new Promise((resolve, reject) => {\n    fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {\n      if (err) return reject(err)\n      resolve({ bytesWritten, buffer })\n    })\n  })\n}\n\n// fs.realpath.native only available in Node v9.2+\nif (typeof fs.realpath.native === 'function') {\n  exports.realpath.native = u(fs.realpath.native)\n}\n","'use strict'\n\nmodule.exports = {\n  copySync: require('./copy-sync')\n}\n","'use strict'\n\nconst path = require('path')\n\n// get drive on windows\nfunction getRootPath (p) {\n  p = path.normalize(path.resolve(p)).split(path.sep)\n  if (p.length > 0) return p[0]\n  return null\n}\n\n// http://stackoverflow.com/a/62888/10333 contains more accurate\n// TODO: expand to include the rest\nconst INVALID_PATH_CHARS = /[<>:\"|?*]/\n\nfunction invalidWin32Path (p) {\n  const rp = getRootPath(p)\n  p = p.replace(rp, '')\n  return INVALID_PATH_CHARS.test(p)\n}\n\nmodule.exports = {\n  getRootPath,\n  invalidWin32Path\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst os = require('os')\nconst path = require('path')\n\n// HFS, ext{2,3}, FAT do not, Node.js v0.10 does not\nfunction hasMillisResSync () {\n  let tmpfile = path.join('millis-test-sync' + Date.now().toString() + Math.random().toString().slice(2))\n  tmpfile = path.join(os.tmpdir(), tmpfile)\n\n  // 550 millis past UNIX epoch\n  const d = new Date(1435410243862)\n  fs.writeFileSync(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141')\n  const fd = fs.openSync(tmpfile, 'r+')\n  fs.futimesSync(fd, d, d)\n  fs.closeSync(fd)\n  return fs.statSync(tmpfile).mtime > 1435410243000\n}\n\nfunction hasMillisRes (callback) {\n  let tmpfile = path.join('millis-test' + Date.now().toString() + Math.random().toString().slice(2))\n  tmpfile = path.join(os.tmpdir(), tmpfile)\n\n  // 550 millis past UNIX epoch\n  const d = new Date(1435410243862)\n  fs.writeFile(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141', err => {\n    if (err) return callback(err)\n    fs.open(tmpfile, 'r+', (err, fd) => {\n      if (err) return callback(err)\n      fs.futimes(fd, d, d, err => {\n        if (err) return callback(err)\n        fs.close(fd, err => {\n          if (err) return callback(err)\n          fs.stat(tmpfile, (err, stats) => {\n            if (err) return callback(err)\n            callback(null, stats.mtime > 1435410243000)\n          })\n        })\n      })\n    })\n  })\n}\n\nfunction timeRemoveMillis (timestamp) {\n  if (typeof timestamp === 'number') {\n    return Math.floor(timestamp / 1000) * 1000\n  } else if (timestamp instanceof Date) {\n    return new Date(Math.floor(timestamp.getTime() / 1000) * 1000)\n  } else {\n    throw new Error('fs-extra: timeRemoveMillis() unknown parameter type')\n  }\n}\n\nfunction utimesMillis (path, atime, mtime, callback) {\n  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)\n  fs.open(path, 'r+', (err, fd) => {\n    if (err) return callback(err)\n    fs.futimes(fd, atime, mtime, futimesErr => {\n      fs.close(fd, closeErr => {\n        if (callback) callback(futimesErr || closeErr)\n      })\n    })\n  })\n}\n\nfunction utimesMillisSync (path, atime, mtime) {\n  const fd = fs.openSync(path, 'r+')\n  fs.futimesSync(fd, atime, mtime)\n  return fs.closeSync(fd)\n}\n\nmodule.exports = {\n  hasMillisRes,\n  hasMillisResSync,\n  timeRemoveMillis,\n  utimesMillis,\n  utimesMillisSync\n}\n","module.exports = require(\"os\");","'use strict'\n\nconst u = require('universalify').fromCallback\nmodule.exports = {\n  copy: u(require('./copy'))\n}\n","export * from './kernel';\n\nimport * as api from './api';\nexport { api };","/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","module.exports = require(\"buffer\");","'use strict'\n\nconst assert = require('assert')\nconst Buffer = require('buffer').Buffer\nconst realZlib = require('zlib')\n\nconst constants = exports.constants = require('./constants.js')\nconst MiniPass = require('minipass')\n\nconst OriginalBufferConcat = Buffer.concat\n\nclass ZlibError extends Error {\n  constructor (msg, errno) {\n    super('zlib: ' + msg)\n    this.errno = errno\n    this.code = codes.get(errno)\n  }\n\n  get name () {\n    return 'ZlibError'\n  }\n}\n\n// translation table for return codes.\nconst codes = new Map([\n  [constants.Z_OK, 'Z_OK'],\n  [constants.Z_STREAM_END, 'Z_STREAM_END'],\n  [constants.Z_NEED_DICT, 'Z_NEED_DICT'],\n  [constants.Z_ERRNO, 'Z_ERRNO'],\n  [constants.Z_STREAM_ERROR, 'Z_STREAM_ERROR'],\n  [constants.Z_DATA_ERROR, 'Z_DATA_ERROR'],\n  [constants.Z_MEM_ERROR, 'Z_MEM_ERROR'],\n  [constants.Z_BUF_ERROR, 'Z_BUF_ERROR'],\n  [constants.Z_VERSION_ERROR, 'Z_VERSION_ERROR']\n])\n\nconst validFlushFlags = new Set([\n  constants.Z_NO_FLUSH,\n  constants.Z_PARTIAL_FLUSH,\n  constants.Z_SYNC_FLUSH,\n  constants.Z_FULL_FLUSH,\n  constants.Z_FINISH,\n  constants.Z_BLOCK\n])\n\nconst strategies = new Set([\n  constants.Z_FILTERED,\n  constants.Z_HUFFMAN_ONLY,\n  constants.Z_RLE,\n  constants.Z_FIXED,\n  constants.Z_DEFAULT_STRATEGY\n])\n\n// the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\nconst _opts = Symbol('opts')\nconst _flushFlag = Symbol('flushFlag')\nconst _finishFlush = Symbol('finishFlush')\nconst _handle = Symbol('handle')\nconst _onError = Symbol('onError')\nconst _level = Symbol('level')\nconst _strategy = Symbol('strategy')\nconst _ended = Symbol('ended')\n\nclass Zlib extends MiniPass {\n  constructor (opts, mode) {\n    super(opts)\n    this[_ended] = false\n    this[_opts] = opts = opts || {}\n    if (opts.flush && !validFlushFlags.has(opts.flush)) {\n      throw new TypeError('Invalid flush flag: ' + opts.flush)\n    }\n    if (opts.finishFlush && !validFlushFlags.has(opts.finishFlush)) {\n      throw new TypeError('Invalid flush flag: ' + opts.finishFlush)\n    }\n\n    this[_flushFlag] = opts.flush || constants.Z_NO_FLUSH\n    this[_finishFlush] = typeof opts.finishFlush !== 'undefined' ?\n      opts.finishFlush : constants.Z_FINISH\n\n    if (opts.chunkSize) {\n      if (opts.chunkSize < constants.Z_MIN_CHUNK) {\n        throw new RangeError('Invalid chunk size: ' + opts.chunkSize)\n      }\n    }\n\n    if (opts.windowBits) {\n      if (opts.windowBits < constants.Z_MIN_WINDOWBITS ||\n          opts.windowBits > constants.Z_MAX_WINDOWBITS) {\n        throw new RangeError('Invalid windowBits: ' + opts.windowBits)\n      }\n    }\n\n    if (opts.level) {\n      if (opts.level < constants.Z_MIN_LEVEL ||\n          opts.level > constants.Z_MAX_LEVEL) {\n        throw new RangeError('Invalid compression level: ' + opts.level)\n      }\n    }\n\n    if (opts.memLevel) {\n      if (opts.memLevel < constants.Z_MIN_MEMLEVEL ||\n          opts.memLevel > constants.Z_MAX_MEMLEVEL) {\n        throw new RangeError('Invalid memLevel: ' + opts.memLevel)\n      }\n    }\n\n    if (opts.strategy && !(strategies.has(opts.strategy)))\n      throw new TypeError('Invalid strategy: ' + opts.strategy)\n\n    if (opts.dictionary) {\n      if (!(opts.dictionary instanceof Buffer)) {\n        throw new TypeError('Invalid dictionary: it should be a Buffer instance')\n      }\n    }\n\n    this[_handle] = new realZlib[mode](opts)\n\n    this[_onError] = (err) => {\n      // there is no way to cleanly recover.\n      // continuing only obscures problems.\n      this.close()\n\n      const error = new ZlibError(err.message, err.errno)\n      this.emit('error', error)\n    }\n    this[_handle].on('error', this[_onError])\n\n    const level = typeof opts.level === 'number' ? opts.level\n                : constants.Z_DEFAULT_COMPRESSION\n\n    var strategy = typeof opts.strategy === 'number' ? opts.strategy\n                 : constants.Z_DEFAULT_STRATEGY\n\n    // API changed in node v9\n    /* istanbul ignore next */\n\n    this[_level] = level\n    this[_strategy] = strategy\n\n    this.once('end', this.close)\n  }\n\n  close () {\n    if (this[_handle]) {\n      this[_handle].close()\n      this[_handle] = null\n      this.emit('close')\n    }\n  }\n\n  params (level, strategy) {\n    if (!this[_handle])\n      throw new Error('cannot switch params when binding is closed')\n\n    // no way to test this without also not supporting params at all\n    /* istanbul ignore if */\n    if (!this[_handle].params)\n      throw new Error('not supported in this implementation')\n\n    if (level < constants.Z_MIN_LEVEL ||\n        level > constants.Z_MAX_LEVEL) {\n      throw new RangeError('Invalid compression level: ' + level)\n    }\n\n    if (!(strategies.has(strategy)))\n      throw new TypeError('Invalid strategy: ' + strategy)\n\n    if (this[_level] !== level || this[_strategy] !== strategy) {\n      this.flush(constants.Z_SYNC_FLUSH)\n      assert(this[_handle], 'zlib binding closed')\n      // .params() calls .flush(), but the latter is always async in the\n      // core zlib. We override .flush() temporarily to intercept that and\n      // flush synchronously.\n      const origFlush = this[_handle].flush\n      this[_handle].flush = (flushFlag, cb) => {\n        this[_handle].flush = origFlush\n        this.flush(flushFlag)\n        cb()\n      }\n      this[_handle].params(level, strategy)\n      /* istanbul ignore else */\n      if (this[_handle]) {\n        this[_level] = level\n        this[_strategy] = strategy\n      }\n    }\n  }\n\n  reset () {\n    assert(this[_handle], 'zlib binding closed')\n    return this[_handle].reset()\n  }\n\n  flush (kind) {\n    if (kind === undefined)\n      kind = constants.Z_FULL_FLUSH\n\n    if (this.ended)\n      return\n\n    const flushFlag = this[_flushFlag]\n    this[_flushFlag] = kind\n    this.write(Buffer.alloc(0))\n    this[_flushFlag] = flushFlag\n  }\n\n  end (chunk, encoding, cb) {\n    if (chunk)\n      this.write(chunk, encoding)\n    this.flush(this[_finishFlush])\n    this[_ended] = true\n    return super.end(null, null, cb)\n  }\n\n  get ended () {\n    return this[_ended]\n  }\n\n  write (chunk, encoding, cb) {\n    // process the chunk using the sync process\n    // then super.write() all the outputted chunks\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n\n    if (typeof chunk === 'string')\n      chunk = Buffer.from(chunk, encoding)\n\n    assert(this[_handle], 'zlib binding closed')\n\n    // _processChunk tries to .close() the native handle after it's done, so we\n    // intercept that by temporarily making it a no-op.\n    const nativeHandle = this[_handle]._handle\n    const originalNativeClose = nativeHandle.close\n    nativeHandle.close = () => {}\n    const originalClose = this[_handle].close\n    this[_handle].close = () => {}\n    // It also calls `Buffer.concat()` at the end, which may be convenient\n    // for some, but which we are not interested in as it slows us down.\n    Buffer.concat = (args) => args\n    let result\n    try {\n      result = this[_handle]._processChunk(chunk, this[_flushFlag])\n    } catch (err) {\n      this[_onError](err)\n    } finally {\n      Buffer.concat = OriginalBufferConcat\n      if (this[_handle]) {\n        // Core zlib resets `_handle` to null after attempting to close the\n        // native handle. Our no-op handler prevented actual closure, but we\n        // need to restore the `._handle` property.\n        this[_handle]._handle = nativeHandle\n        nativeHandle.close = originalNativeClose\n        this[_handle].close = originalClose\n        // `_processChunk()` adds an 'error' listener. If we don't remove it\n        // after each call, these handlers start piling up.\n        this[_handle].removeAllListeners('error')\n      }\n    }\n\n    let writeReturn\n    if (result) {\n      if (Array.isArray(result) && result.length > 0) {\n        // The first buffer is always `handle._outBuffer`, which would be\n        // re-used for later invocations; so, we always have to copy that one.\n        writeReturn = super.write(Buffer.from(result[0]))\n        for (let i = 1; i < result.length; i++) {\n          writeReturn = super.write(result[i])\n        }\n      } else {\n        writeReturn = super.write(Buffer.from(result))\n      }\n    }\n\n    if (cb)\n      cb()\n    return writeReturn\n  }\n}\n\n// minimal 2-byte header\nclass Deflate extends Zlib {\n  constructor (opts) {\n    super(opts, 'Deflate')\n  }\n}\n\nclass Inflate extends Zlib {\n  constructor (opts) {\n    super(opts, 'Inflate')\n  }\n}\n\n// gzip - bigger header, same deflate compression\nclass Gzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Gzip')\n  }\n}\n\nclass Gunzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Gunzip')\n  }\n}\n\n// raw - no header\nclass DeflateRaw extends Zlib {\n  constructor (opts) {\n    super(opts, 'DeflateRaw')\n  }\n}\n\nclass InflateRaw extends Zlib {\n  constructor (opts) {\n    super(opts, 'InflateRaw')\n  }\n}\n\n// auto-detect header.\nclass Unzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Unzip')\n  }\n}\n\nexports.Deflate = Deflate\nexports.Inflate = Inflate\nexports.Gzip = Gzip\nexports.Gunzip = Gunzip\nexports.DeflateRaw = DeflateRaw\nexports.InflateRaw = InflateRaw\nexports.Unzip = Unzip\n","'use strict'\nconst Buffer = require('./buffer.js')\nconst MiniPass = require('minipass')\nconst Pax = require('./pax.js')\nconst Header = require('./header.js')\nconst ReadEntry = require('./read-entry.js')\nconst fs = require('fs')\nconst path = require('path')\n\nconst types = require('./types.js')\nconst maxReadSize = 16 * 1024 * 1024\nconst PROCESS = Symbol('process')\nconst FILE = Symbol('file')\nconst DIRECTORY = Symbol('directory')\nconst SYMLINK = Symbol('symlink')\nconst HARDLINK = Symbol('hardlink')\nconst HEADER = Symbol('header')\nconst READ = Symbol('read')\nconst LSTAT = Symbol('lstat')\nconst ONLSTAT = Symbol('onlstat')\nconst ONREAD = Symbol('onread')\nconst ONREADLINK = Symbol('onreadlink')\nconst OPENFILE = Symbol('openfile')\nconst ONOPENFILE = Symbol('onopenfile')\nconst CLOSE = Symbol('close')\nconst MODE = Symbol('mode')\nconst warner = require('./warn-mixin.js')\nconst winchars = require('./winchars.js')\n\nconst modeFix = require('./mode-fix.js')\n\nconst WriteEntry = warner(class WriteEntry extends MiniPass {\n  constructor (p, opt) {\n    opt = opt || {}\n    super(opt)\n    if (typeof p !== 'string')\n      throw new TypeError('path is required')\n    this.path = p\n    // suppress atime, ctime, uid, gid, uname, gname\n    this.portable = !!opt.portable\n    // until node has builtin pwnam functions, this'll have to do\n    this.myuid = process.getuid && process.getuid()\n    this.myuser = process.env.USER || ''\n    this.maxReadSize = opt.maxReadSize || maxReadSize\n    this.linkCache = opt.linkCache || new Map()\n    this.statCache = opt.statCache || new Map()\n    this.preservePaths = !!opt.preservePaths\n    this.cwd = opt.cwd || process.cwd()\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.noMtime = !!opt.noMtime\n    this.mtime = opt.mtime || null\n\n    if (typeof opt.onwarn === 'function')\n      this.on('warn', opt.onwarn)\n\n    if (!this.preservePaths && path.win32.isAbsolute(p)) {\n      // absolutes on posix are also absolutes on win32\n      // so we only need to test this one to get both\n      const parsed = path.win32.parse(p)\n      this.warn('stripping ' + parsed.root + ' from absolute path', p)\n      this.path = p.substr(parsed.root.length)\n    }\n\n    this.win32 = !!opt.win32 || process.platform === 'win32'\n    if (this.win32) {\n      this.path = winchars.decode(this.path.replace(/\\\\/g, '/'))\n      p = p.replace(/\\\\/g, '/')\n    }\n\n    this.absolute = opt.absolute || path.resolve(this.cwd, p)\n\n    if (this.path === '')\n      this.path = './'\n\n    if (this.statCache.has(this.absolute))\n      this[ONLSTAT](this.statCache.get(this.absolute))\n    else\n      this[LSTAT]()\n  }\n\n  [LSTAT] () {\n    fs.lstat(this.absolute, (er, stat) => {\n      if (er)\n        return this.emit('error', er)\n      this[ONLSTAT](stat)\n    })\n  }\n\n  [ONLSTAT] (stat) {\n    this.statCache.set(this.absolute, stat)\n    this.stat = stat\n    if (!stat.isFile())\n      stat.size = 0\n    this.type = getType(stat)\n    this.emit('stat', stat)\n    this[PROCESS]()\n  }\n\n  [PROCESS] () {\n    switch (this.type) {\n      case 'File': return this[FILE]()\n      case 'Directory': return this[DIRECTORY]()\n      case 'SymbolicLink': return this[SYMLINK]()\n      // unsupported types are ignored.\n      default: return this.end()\n    }\n  }\n\n  [MODE] (mode) {\n    return modeFix(mode, this.type === 'Directory')\n  }\n\n  [HEADER] () {\n    if (this.type === 'Directory' && this.portable)\n      this.noMtime = true\n\n    this.header = new Header({\n      path: this.path,\n      linkpath: this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this[MODE](this.stat.mode),\n      uid: this.portable ? null : this.stat.uid,\n      gid: this.portable ? null : this.stat.gid,\n      size: this.stat.size,\n      mtime: this.noMtime ? null : this.mtime || this.stat.mtime,\n      type: this.type,\n      uname: this.portable ? null :\n        this.stat.uid === this.myuid ? this.myuser : '',\n      atime: this.portable ? null : this.stat.atime,\n      ctime: this.portable ? null : this.stat.ctime\n    })\n\n    if (this.header.encode() && !this.noPax)\n      this.write(new Pax({\n        atime: this.portable ? null : this.header.atime,\n        ctime: this.portable ? null : this.header.ctime,\n        gid: this.portable ? null : this.header.gid,\n        mtime: this.noMtime ? null : this.mtime || this.header.mtime,\n        path: this.path,\n        linkpath: this.linkpath,\n        size: this.header.size,\n        uid: this.portable ? null : this.header.uid,\n        uname: this.portable ? null : this.header.uname,\n        dev: this.portable ? null : this.stat.dev,\n        ino: this.portable ? null : this.stat.ino,\n        nlink: this.portable ? null : this.stat.nlink\n      }).encode())\n    this.write(this.header.block)\n  }\n\n  [DIRECTORY] () {\n    if (this.path.substr(-1) !== '/')\n      this.path += '/'\n    this.stat.size = 0\n    this[HEADER]()\n    this.end()\n  }\n\n  [SYMLINK] () {\n    fs.readlink(this.absolute, (er, linkpath) => {\n      if (er)\n        return this.emit('error', er)\n      this[ONREADLINK](linkpath)\n    })\n  }\n\n  [ONREADLINK] (linkpath) {\n    this.linkpath = linkpath\n    this[HEADER]()\n    this.end()\n  }\n\n  [HARDLINK] (linkpath) {\n    this.type = 'Link'\n    this.linkpath = path.relative(this.cwd, linkpath)\n    this.stat.size = 0\n    this[HEADER]()\n    this.end()\n  }\n\n  [FILE] () {\n    if (this.stat.nlink > 1) {\n      const linkKey = this.stat.dev + ':' + this.stat.ino\n      if (this.linkCache.has(linkKey)) {\n        const linkpath = this.linkCache.get(linkKey)\n        if (linkpath.indexOf(this.cwd) === 0)\n          return this[HARDLINK](linkpath)\n      }\n      this.linkCache.set(linkKey, this.absolute)\n    }\n\n    this[HEADER]()\n    if (this.stat.size === 0)\n      return this.end()\n\n    this[OPENFILE]()\n  }\n\n  [OPENFILE] () {\n    fs.open(this.absolute, 'r', (er, fd) => {\n      if (er)\n        return this.emit('error', er)\n      this[ONOPENFILE](fd)\n    })\n  }\n\n  [ONOPENFILE] (fd) {\n    const blockLen = 512 * Math.ceil(this.stat.size / 512)\n    const bufLen = Math.min(blockLen, this.maxReadSize)\n    const buf = Buffer.allocUnsafe(bufLen)\n    this[READ](fd, buf, 0, buf.length, 0, this.stat.size, blockLen)\n  }\n\n  [READ] (fd, buf, offset, length, pos, remain, blockRemain) {\n    fs.read(fd, buf, offset, length, pos, (er, bytesRead) => {\n      if (er)\n        return this[CLOSE](fd, _ => this.emit('error', er))\n      this[ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead)\n    })\n  }\n\n  [CLOSE] (fd, cb) {\n    fs.close(fd, cb)\n  }\n\n  [ONREAD] (fd, buf, offset, length, pos, remain, blockRemain, bytesRead) {\n    if (bytesRead <= 0 && remain > 0) {\n      const er = new Error('encountered unexpected EOF')\n      er.path = this.absolute\n      er.syscall = 'read'\n      er.code = 'EOF'\n      this[CLOSE](fd)\n      return this.emit('error', er)\n    }\n\n    if (bytesRead > remain) {\n      const er = new Error('did not encounter expected EOF')\n      er.path = this.absolute\n      er.syscall = 'read'\n      er.code = 'EOF'\n      this[CLOSE](fd)\n      return this.emit('error', er)\n    }\n\n    // null out the rest of the buffer, if we could fit the block padding\n    if (bytesRead === remain) {\n      for (let i = bytesRead; i < length && bytesRead < blockRemain; i++) {\n        buf[i + offset] = 0\n        bytesRead ++\n        remain ++\n      }\n    }\n\n    const writeBuf = offset === 0 && bytesRead === buf.length ?\n      buf : buf.slice(offset, offset + bytesRead)\n    remain -= bytesRead\n    blockRemain -= bytesRead\n    pos += bytesRead\n    offset += bytesRead\n\n    this.write(writeBuf)\n\n    if (!remain) {\n      if (blockRemain)\n        this.write(Buffer.alloc(blockRemain))\n      this.end()\n      this[CLOSE](fd, _ => _)\n      return\n    }\n\n    if (offset >= length) {\n      buf = Buffer.allocUnsafe(length)\n      offset = 0\n    }\n    length = buf.length - offset\n    this[READ](fd, buf, offset, length, pos, remain, blockRemain)\n  }\n})\n\nclass WriteEntrySync extends WriteEntry {\n  constructor (path, opt) {\n    super(path, opt)\n  }\n\n  [LSTAT] () {\n    this[ONLSTAT](fs.lstatSync(this.absolute))\n  }\n\n  [SYMLINK] () {\n    this[ONREADLINK](fs.readlinkSync(this.absolute))\n  }\n\n  [OPENFILE] () {\n    this[ONOPENFILE](fs.openSync(this.absolute, 'r'))\n  }\n\n  [READ] (fd, buf, offset, length, pos, remain, blockRemain) {\n    let threw = true\n    try {\n      const bytesRead = fs.readSync(fd, buf, offset, length, pos)\n      this[ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead)\n      threw = false\n    } finally {\n      if (threw)\n        try { this[CLOSE](fd) } catch (er) {}\n    }\n  }\n\n  [CLOSE] (fd) {\n    fs.closeSync(fd)\n  }\n}\n\nconst WriteEntryTar = warner(class WriteEntryTar extends MiniPass {\n  constructor (readEntry, opt) {\n    opt = opt || {}\n    super(opt)\n    this.preservePaths = !!opt.preservePaths\n    this.portable = !!opt.portable\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.noMtime = !!opt.noMtime\n\n    this.readEntry = readEntry\n    this.type = readEntry.type\n    if (this.type === 'Directory' && this.portable)\n      this.noMtime = true\n\n    this.path = readEntry.path\n    this.mode = this[MODE](readEntry.mode)\n    this.uid = this.portable ? null : readEntry.uid\n    this.gid = this.portable ? null : readEntry.gid\n    this.uname = this.portable ? null : readEntry.uname\n    this.gname = this.portable ? null : readEntry.gname\n    this.size = readEntry.size\n    this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime\n    this.atime = this.portable ? null : readEntry.atime\n    this.ctime = this.portable ? null : readEntry.ctime\n    this.linkpath = readEntry.linkpath\n\n    if (typeof opt.onwarn === 'function')\n      this.on('warn', opt.onwarn)\n\n    if (path.isAbsolute(this.path) && !this.preservePaths) {\n      const parsed = path.parse(this.path)\n      this.warn(\n        'stripping ' + parsed.root + ' from absolute path',\n        this.path\n      )\n      this.path = this.path.substr(parsed.root.length)\n    }\n\n    this.remain = readEntry.size\n    this.blockRemain = readEntry.startBlockSize\n\n    this.header = new Header({\n      path: this.path,\n      linkpath: this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this.mode,\n      uid: this.portable ? null : this.uid,\n      gid: this.portable ? null : this.gid,\n      size: this.size,\n      mtime: this.noMtime ? null : this.mtime,\n      type: this.type,\n      uname: this.portable ? null : this.uname,\n      atime: this.portable ? null : this.atime,\n      ctime: this.portable ? null : this.ctime\n    })\n\n    if (this.header.encode() && !this.noPax)\n      super.write(new Pax({\n        atime: this.portable ? null : this.atime,\n        ctime: this.portable ? null : this.ctime,\n        gid: this.portable ? null : this.gid,\n        mtime: this.noMtime ? null : this.mtime,\n        path: this.path,\n        linkpath: this.linkpath,\n        size: this.size,\n        uid: this.portable ? null : this.uid,\n        uname: this.portable ? null : this.uname,\n        dev: this.portable ? null : this.readEntry.dev,\n        ino: this.portable ? null : this.readEntry.ino,\n        nlink: this.portable ? null : this.readEntry.nlink\n      }).encode())\n\n    super.write(this.header.block)\n    readEntry.pipe(this)\n  }\n\n  [MODE] (mode) {\n    return modeFix(mode, this.type === 'Directory')\n  }\n\n  write (data) {\n    const writeLen = data.length\n    if (writeLen > this.blockRemain)\n      throw new Error('writing more to entry than is appropriate')\n    this.blockRemain -= writeLen\n    return super.write(data)\n  }\n\n  end () {\n    if (this.blockRemain)\n      this.write(Buffer.alloc(this.blockRemain))\n    return super.end()\n  }\n})\n\nWriteEntry.Sync = WriteEntrySync\nWriteEntry.Tar = WriteEntryTar\n\nconst getType = stat =>\n  stat.isFile() ? 'File'\n  : stat.isDirectory() ? 'Directory'\n  : stat.isSymbolicLink() ? 'SymbolicLink'\n  : 'Unsupported'\n\nmodule.exports = WriteEntry\n","'use strict'\n\n// When writing files on Windows, translate the characters to their\n// 0xf000 higher-encoded versions.\n\nconst raw = [\n  '|',\n  '<',\n  '>',\n  '?',\n  ':'\n]\n\nconst win = raw.map(char =>\n  String.fromCharCode(0xf000 + char.charCodeAt(0)))\n\nconst toWin = new Map(raw.map((char, i) => [char, win[i]]))\nconst toRaw = new Map(win.map((char, i) => [char, raw[i]]))\n\nmodule.exports = {\n  encode: s => raw.reduce((s, c) => s.split(c).join(toWin.get(c)), s),\n  decode: s => win.reduce((s, c) => s.split(c).join(toRaw.get(c)), s)\n}\n","'use strict'\nconst Buffer = require('./buffer.js')\n\n// tar -r\nconst hlo = require('./high-level-opt.js')\nconst Pack = require('./pack.js')\nconst Parse = require('./parse.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst t = require('./list.js')\nconst path = require('path')\n\n// starting at the head of the file, read a Header\n// If the checksum is invalid, that's our position to start writing\n// If it is, jump forward by the specified size (round up to 512)\n// and try again.\n// Write the new Pack stream starting there.\n\nconst Header = require('./header.js')\n\nconst r = module.exports = (opt_, files, cb) => {\n  const opt = hlo(opt_)\n\n  if (!opt.file)\n    throw new TypeError('file is required')\n\n  if (opt.gzip)\n    throw new TypeError('cannot append to compressed archives')\n\n  if (!files || !Array.isArray(files) || !files.length)\n    throw new TypeError('no files or directories specified')\n\n  files = Array.from(files)\n\n  return opt.sync ? replaceSync(opt, files)\n    : replace(opt, files, cb)\n}\n\nconst replaceSync = (opt, files) => {\n  const p = new Pack.Sync(opt)\n\n  let threw = true\n  let fd\n  let position\n\n  try {\n    try {\n      fd = fs.openSync(opt.file, 'r+')\n    } catch (er) {\n      if (er.code === 'ENOENT')\n        fd = fs.openSync(opt.file, 'w+')\n      else\n        throw er\n    }\n\n    const st = fs.fstatSync(fd)\n    const headBuf = Buffer.alloc(512)\n\n    POSITION: for (position = 0; position < st.size; position += 512) {\n      for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {\n        bytes = fs.readSync(\n          fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos\n        )\n\n        if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b)\n          throw new Error('cannot append to compressed archives')\n\n        if (!bytes)\n          break POSITION\n      }\n\n      let h = new Header(headBuf)\n      if (!h.cksumValid)\n        break\n      let entryBlockSize = 512 * Math.ceil(h.size / 512)\n      if (position + entryBlockSize + 512 > st.size)\n        break\n      // the 512 for the header we just parsed will be added as well\n      // also jump ahead all the blocks for the body\n      position += entryBlockSize\n      if (opt.mtimeCache)\n        opt.mtimeCache.set(h.path, h.mtime)\n    }\n    threw = false\n\n    streamSync(opt, p, position, fd, files)\n  } finally {\n    if (threw)\n      try { fs.closeSync(fd) } catch (er) {}\n  }\n}\n\nconst streamSync = (opt, p, position, fd, files) => {\n  const stream = new fsm.WriteStreamSync(opt.file, {\n    fd: fd,\n    start: position\n  })\n  p.pipe(stream)\n  addFilesSync(p, files)\n}\n\nconst replace = (opt, files, cb) => {\n  files = Array.from(files)\n  const p = new Pack(opt)\n\n  const getPos = (fd, size, cb_) => {\n    const cb = (er, pos) => {\n      if (er)\n        fs.close(fd, _ => cb_(er))\n      else\n        cb_(null, pos)\n    }\n\n    let position = 0\n    if (size === 0)\n      return cb(null, 0)\n\n    let bufPos = 0\n    const headBuf = Buffer.alloc(512)\n    const onread = (er, bytes) => {\n      if (er)\n        return cb(er)\n      bufPos += bytes\n      if (bufPos < 512 && bytes)\n        return fs.read(\n          fd, headBuf, bufPos, headBuf.length - bufPos,\n          position + bufPos, onread\n        )\n\n      if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b)\n        return cb(new Error('cannot append to compressed archives'))\n\n      // truncated header\n      if (bufPos < 512)\n        return cb(null, position)\n\n      const h = new Header(headBuf)\n      if (!h.cksumValid)\n        return cb(null, position)\n\n      const entryBlockSize = 512 * Math.ceil(h.size / 512)\n      if (position + entryBlockSize + 512 > size)\n        return cb(null, position)\n\n      position += entryBlockSize + 512\n      if (position >= size)\n        return cb(null, position)\n\n      if (opt.mtimeCache)\n        opt.mtimeCache.set(h.path, h.mtime)\n      bufPos = 0\n      fs.read(fd, headBuf, 0, 512, position, onread)\n    }\n    fs.read(fd, headBuf, 0, 512, position, onread)\n  }\n\n  const promise = new Promise((resolve, reject) => {\n    p.on('error', reject)\n    let flag = 'r+'\n    const onopen = (er, fd) => {\n      if (er && er.code === 'ENOENT' && flag === 'r+') {\n        flag = 'w+'\n        return fs.open(opt.file, flag, onopen)\n      }\n\n      if (er)\n        return reject(er)\n\n      fs.fstat(fd, (er, st) => {\n        if (er)\n          return reject(er)\n        getPos(fd, st.size, (er, position) => {\n          if (er)\n            return reject(er)\n          const stream = new fsm.WriteStream(opt.file, {\n            fd: fd,\n            start: position\n          })\n          p.pipe(stream)\n          stream.on('error', reject)\n          stream.on('close', resolve)\n          addFilesAsync(p, files)\n        })\n      })\n    }\n    fs.open(opt.file, flag, onopen)\n  })\n\n  return cb ? promise.then(cb, cb) : promise\n}\n\nconst addFilesSync = (p, files) => {\n  files.forEach(file => {\n    if (file.charAt(0) === '@')\n      t({\n        file: path.resolve(p.cwd, file.substr(1)),\n        sync: true,\n        noResume: true,\n        onentry: entry => p.add(entry)\n      })\n    else\n      p.add(file)\n  })\n  p.end()\n}\n\nconst addFilesAsync = (p, files) => {\n  while (files.length) {\n    const file = files.shift()\n    if (file.charAt(0) === '@')\n      return t({\n        file: path.resolve(p.cwd, file.substr(1)),\n        noResume: true,\n        onentry: entry => p.add(entry)\n      }).then(_ => addFilesAsync(p, files))\n    else\n      p.add(file)\n  }\n  p.end()\n}\n","'use strict'\n\nconst assert = require('assert')\nconst EE = require('events').EventEmitter\nconst Parser = require('./parse.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst path = require('path')\nconst mkdir = require('./mkdir.js')\nconst mkdirSync = mkdir.sync\nconst wc = require('./winchars.js')\n\nconst ONENTRY = Symbol('onEntry')\nconst CHECKFS = Symbol('checkFs')\nconst ISREUSABLE = Symbol('isReusable')\nconst MAKEFS = Symbol('makeFs')\nconst FILE = Symbol('file')\nconst DIRECTORY = Symbol('directory')\nconst LINK = Symbol('link')\nconst SYMLINK = Symbol('symlink')\nconst HARDLINK = Symbol('hardlink')\nconst UNSUPPORTED = Symbol('unsupported')\nconst UNKNOWN = Symbol('unknown')\nconst CHECKPATH = Symbol('checkPath')\nconst MKDIR = Symbol('mkdir')\nconst ONERROR = Symbol('onError')\nconst PENDING = Symbol('pending')\nconst PEND = Symbol('pend')\nconst UNPEND = Symbol('unpend')\nconst ENDED = Symbol('ended')\nconst MAYBECLOSE = Symbol('maybeClose')\nconst SKIP = Symbol('skip')\nconst DOCHOWN = Symbol('doChown')\nconst UID = Symbol('uid')\nconst GID = Symbol('gid')\nconst crypto = require('crypto')\n\n// Unlinks on Windows are not atomic.\n//\n// This means that if you have a file entry, followed by another\n// file entry with an identical name, and you cannot re-use the file\n// (because it's a hardlink, or because unlink:true is set, or it's\n// Windows, which does not have useful nlink values), then the unlink\n// will be committed to the disk AFTER the new file has been written\n// over the old one, deleting the new file.\n//\n// To work around this, on Windows systems, we rename the file and then\n// delete the renamed file.  It's a sloppy kludge, but frankly, I do not\n// know of a better way to do this, given windows' non-atomic unlink\n// semantics.\n//\n// See: https://github.com/npm/node-tar/issues/183\n/* istanbul ignore next */\nconst unlinkFile = (path, cb) => {\n  if (process.platform !== 'win32')\n    return fs.unlink(path, cb)\n\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')\n  fs.rename(path, name, er => {\n    if (er)\n      return cb(er)\n    fs.unlink(name, cb)\n  })\n}\n\n/* istanbul ignore next */\nconst unlinkFileSync = path => {\n  if (process.platform !== 'win32')\n    return fs.unlinkSync(path)\n\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')\n  fs.renameSync(path, name)\n  fs.unlinkSync(name)\n}\n\n// this.gid, entry.gid, this.processUid\nconst uint32 = (a, b, c) =>\n  a === a >>> 0 ? a\n  : b === b >>> 0 ? b\n  : c\n\nclass Unpack extends Parser {\n  constructor (opt) {\n    if (!opt)\n      opt = {}\n\n    opt.ondone = _ => {\n      this[ENDED] = true\n      this[MAYBECLOSE]()\n    }\n\n    super(opt)\n\n    this.transform = typeof opt.transform === 'function' ? opt.transform : null\n\n    this.writable = true\n    this.readable = false\n\n    this[PENDING] = 0\n    this[ENDED] = false\n\n    this.dirCache = opt.dirCache || new Map()\n\n    if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {\n      // need both or neither\n      if (typeof opt.uid !== 'number' || typeof opt.gid !== 'number')\n        throw new TypeError('cannot set owner without number uid and gid')\n      if (opt.preserveOwner)\n        throw new TypeError(\n          'cannot preserve owner in archive and also set owner explicitly')\n      this.uid = opt.uid\n      this.gid = opt.gid\n      this.setOwner = true\n    } else {\n      this.uid = null\n      this.gid = null\n      this.setOwner = false\n    }\n\n    // default true for root\n    if (opt.preserveOwner === undefined && typeof opt.uid !== 'number')\n      this.preserveOwner = process.getuid && process.getuid() === 0\n    else\n      this.preserveOwner = !!opt.preserveOwner\n\n    this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ?\n      process.getuid() : null\n    this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ?\n      process.getgid() : null\n\n    // mostly just for testing, but useful in some cases.\n    // Forcibly trigger a chown on every entry, no matter what\n    this.forceChown = opt.forceChown === true\n\n    // turn ><?| in filenames into 0xf000-higher encoded forms\n    this.win32 = !!opt.win32 || process.platform === 'win32'\n\n    // do not unpack over files that are newer than what's in the archive\n    this.newer = !!opt.newer\n\n    // do not unpack over ANY files\n    this.keep = !!opt.keep\n\n    // do not set mtime/atime of extracted entries\n    this.noMtime = !!opt.noMtime\n\n    // allow .., absolute path entries, and unpacking through symlinks\n    // without this, warn and skip .., relativize absolutes, and error\n    // on symlinks in extraction path\n    this.preservePaths = !!opt.preservePaths\n\n    // unlink files and links before writing. This breaks existing hard\n    // links, and removes symlink directories rather than erroring\n    this.unlink = !!opt.unlink\n\n    this.cwd = path.resolve(opt.cwd || process.cwd())\n    this.strip = +opt.strip || 0\n    this.processUmask = process.umask()\n    this.umask = typeof opt.umask === 'number' ? opt.umask : this.processUmask\n    // default mode for dirs created as parents\n    this.dmode = opt.dmode || (0o0777 & (~this.umask))\n    this.fmode = opt.fmode || (0o0666 & (~this.umask))\n    this.on('entry', entry => this[ONENTRY](entry))\n  }\n\n  [MAYBECLOSE] () {\n    if (this[ENDED] && this[PENDING] === 0) {\n      this.emit('prefinish')\n      this.emit('finish')\n      this.emit('end')\n      this.emit('close')\n    }\n  }\n\n  [CHECKPATH] (entry) {\n    if (this.strip) {\n      const parts = entry.path.split(/\\/|\\\\/)\n      if (parts.length < this.strip)\n        return false\n      entry.path = parts.slice(this.strip).join('/')\n\n      if (entry.type === 'Link') {\n        const linkparts = entry.linkpath.split(/\\/|\\\\/)\n        if (linkparts.length >= this.strip)\n          entry.linkpath = linkparts.slice(this.strip).join('/')\n      }\n    }\n\n    if (!this.preservePaths) {\n      const p = entry.path\n      if (p.match(/(^|\\/|\\\\)\\.\\.(\\\\|\\/|$)/)) {\n        this.warn('path contains \\'..\\'', p)\n        return false\n      }\n\n      // absolutes on posix are also absolutes on win32\n      // so we only need to test this one to get both\n      if (path.win32.isAbsolute(p)) {\n        const parsed = path.win32.parse(p)\n        this.warn('stripping ' + parsed.root + ' from absolute path', p)\n        entry.path = p.substr(parsed.root.length)\n      }\n    }\n\n    // only encode : chars that aren't drive letter indicators\n    if (this.win32) {\n      const parsed = path.win32.parse(entry.path)\n      entry.path = parsed.root === '' ? wc.encode(entry.path)\n        : parsed.root + wc.encode(entry.path.substr(parsed.root.length))\n    }\n\n    if (path.isAbsolute(entry.path))\n      entry.absolute = entry.path\n    else\n      entry.absolute = path.resolve(this.cwd, entry.path)\n\n    return true\n  }\n\n  [ONENTRY] (entry) {\n    if (!this[CHECKPATH](entry))\n      return entry.resume()\n\n    assert.equal(typeof entry.absolute, 'string')\n\n    switch (entry.type) {\n      case 'Directory':\n      case 'GNUDumpDir':\n        if (entry.mode)\n          entry.mode = entry.mode | 0o700\n\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n      case 'Link':\n      case 'SymbolicLink':\n        return this[CHECKFS](entry)\n\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'FIFO':\n        return this[UNSUPPORTED](entry)\n    }\n  }\n\n  [ONERROR] (er, entry) {\n    // Cwd has to exist, or else nothing works. That's serious.\n    // Other errors are warnings, which raise the error in strict\n    // mode, but otherwise continue on.\n    if (er.name === 'CwdError')\n      this.emit('error', er)\n    else {\n      this.warn(er.message, er)\n      this[UNPEND]()\n      entry.resume()\n    }\n  }\n\n  [MKDIR] (dir, mode, cb) {\n    mkdir(dir, {\n      uid: this.uid,\n      gid: this.gid,\n      processUid: this.processUid,\n      processGid: this.processGid,\n      umask: this.processUmask,\n      preserve: this.preservePaths,\n      unlink: this.unlink,\n      cache: this.dirCache,\n      cwd: this.cwd,\n      mode: mode\n    }, cb)\n  }\n\n  [DOCHOWN] (entry) {\n    // in preserve owner mode, chown if the entry doesn't match process\n    // in set owner mode, chown if setting doesn't match process\n    return this.forceChown ||\n      this.preserveOwner &&\n      ( typeof entry.uid === 'number' && entry.uid !== this.processUid ||\n        typeof entry.gid === 'number' && entry.gid !== this.processGid )\n      ||\n      ( typeof this.uid === 'number' && this.uid !== this.processUid ||\n        typeof this.gid === 'number' && this.gid !== this.processGid )\n  }\n\n  [UID] (entry) {\n    return uint32(this.uid, entry.uid, this.processUid)\n  }\n\n  [GID] (entry) {\n    return uint32(this.gid, entry.gid, this.processGid)\n  }\n\n  [FILE] (entry) {\n    const mode = entry.mode & 0o7777 || this.fmode\n    const stream = new fsm.WriteStream(entry.absolute, {\n      mode: mode,\n      autoClose: false\n    })\n    stream.on('error', er => this[ONERROR](er, entry))\n\n    let actions = 1\n    const done = er => {\n      if (er)\n        return this[ONERROR](er, entry)\n\n      if (--actions === 0)\n        fs.close(stream.fd, _ => this[UNPEND]())\n    }\n\n    stream.on('finish', _ => {\n      // if futimes fails, try utimes\n      // if utimes fails, fail with the original error\n      // same for fchown/chown\n      const abs = entry.absolute\n      const fd = stream.fd\n\n      if (entry.mtime && !this.noMtime) {\n        actions++\n        const atime = entry.atime || new Date()\n        const mtime = entry.mtime\n        fs.futimes(fd, atime, mtime, er =>\n          er ? fs.utimes(abs, atime, mtime, er2 => done(er2 && er))\n          : done())\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++\n        const uid = this[UID](entry)\n        const gid = this[GID](entry)\n        fs.fchown(fd, uid, gid, er =>\n          er ? fs.chown(abs, uid, gid, er2 => done(er2 && er))\n          : done())\n      }\n\n      done()\n    })\n\n    const tx = this.transform ? this.transform(entry) || entry : entry\n    if (tx !== entry) {\n      tx.on('error', er => this[ONERROR](er, entry))\n      entry.pipe(tx)\n    }\n    tx.pipe(stream)\n  }\n\n  [DIRECTORY] (entry) {\n    const mode = entry.mode & 0o7777 || this.dmode\n    this[MKDIR](entry.absolute, mode, er => {\n      if (er)\n        return this[ONERROR](er, entry)\n\n      let actions = 1\n      const done = _ => {\n        if (--actions === 0) {\n          this[UNPEND]()\n          entry.resume()\n        }\n      }\n\n      if (entry.mtime && !this.noMtime) {\n        actions++\n        fs.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done)\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++\n        fs.chown(entry.absolute, this[UID](entry), this[GID](entry), done)\n      }\n\n      done()\n    })\n  }\n\n  [UNSUPPORTED] (entry) {\n    this.warn('unsupported entry type: ' + entry.type, entry)\n    entry.resume()\n  }\n\n  [SYMLINK] (entry) {\n    this[LINK](entry, entry.linkpath, 'symlink')\n  }\n\n  [HARDLINK] (entry) {\n    this[LINK](entry, path.resolve(this.cwd, entry.linkpath), 'link')\n  }\n\n  [PEND] () {\n    this[PENDING]++\n  }\n\n  [UNPEND] () {\n    this[PENDING]--\n    this[MAYBECLOSE]()\n  }\n\n  [SKIP] (entry) {\n    this[UNPEND]()\n    entry.resume()\n  }\n\n  // Check if we can reuse an existing filesystem entry safely and\n  // overwrite it, rather than unlinking and recreating\n  // Windows doesn't report a useful nlink, so we just never reuse entries\n  [ISREUSABLE] (entry, st) {\n    return entry.type === 'File' &&\n      !this.unlink &&\n      st.isFile() &&\n      st.nlink <= 1 &&\n      process.platform !== 'win32'\n  }\n\n  // check if a thing is there, and if so, try to clobber it\n  [CHECKFS] (entry) {\n    this[PEND]()\n    this[MKDIR](path.dirname(entry.absolute), this.dmode, er => {\n      if (er)\n        return this[ONERROR](er, entry)\n      fs.lstat(entry.absolute, (er, st) => {\n        if (st && (this.keep || this.newer && st.mtime > entry.mtime))\n          this[SKIP](entry)\n        else if (er || this[ISREUSABLE](entry, st))\n          this[MAKEFS](null, entry)\n        else if (st.isDirectory()) {\n          if (entry.type === 'Directory') {\n            if (!entry.mode || (st.mode & 0o7777) === entry.mode)\n              this[MAKEFS](null, entry)\n            else\n              fs.chmod(entry.absolute, entry.mode, er => this[MAKEFS](er, entry))\n          } else\n            fs.rmdir(entry.absolute, er => this[MAKEFS](er, entry))\n        } else\n          unlinkFile(entry.absolute, er => this[MAKEFS](er, entry))\n      })\n    })\n  }\n\n  [MAKEFS] (er, entry) {\n    if (er)\n      return this[ONERROR](er, entry)\n\n    switch (entry.type) {\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n        return this[FILE](entry)\n\n      case 'Link':\n        return this[HARDLINK](entry)\n\n      case 'SymbolicLink':\n        return this[SYMLINK](entry)\n\n      case 'Directory':\n      case 'GNUDumpDir':\n        return this[DIRECTORY](entry)\n    }\n  }\n\n  [LINK] (entry, linkpath, link) {\n    // XXX: get the type ('file' or 'dir') for windows\n    fs[link](linkpath, entry.absolute, er => {\n      if (er)\n        return this[ONERROR](er, entry)\n      this[UNPEND]()\n      entry.resume()\n    })\n  }\n}\n\nclass UnpackSync extends Unpack {\n  constructor (opt) {\n    super(opt)\n  }\n\n  [CHECKFS] (entry) {\n    const er = this[MKDIR](path.dirname(entry.absolute), this.dmode)\n    if (er)\n      return this[ONERROR](er, entry)\n    try {\n      const st = fs.lstatSync(entry.absolute)\n      if (this.keep || this.newer && st.mtime > entry.mtime)\n        return this[SKIP](entry)\n      else if (this[ISREUSABLE](entry, st))\n        return this[MAKEFS](null, entry)\n      else {\n        try {\n          if (st.isDirectory()) {\n            if (entry.type === 'Directory') {\n              if (entry.mode && (st.mode & 0o7777) !== entry.mode)\n                fs.chmodSync(entry.absolute, entry.mode)\n            } else\n              fs.rmdirSync(entry.absolute)\n          } else\n            unlinkFileSync(entry.absolute)\n          return this[MAKEFS](null, entry)\n        } catch (er) {\n          return this[ONERROR](er, entry)\n        }\n      }\n    } catch (er) {\n      return this[MAKEFS](null, entry)\n    }\n  }\n\n  [FILE] (entry) {\n    const mode = entry.mode & 0o7777 || this.fmode\n\n    const oner = er => {\n      try { fs.closeSync(fd) } catch (_) {}\n      if (er)\n        this[ONERROR](er, entry)\n    }\n\n    let stream\n    let fd\n    try {\n      fd = fs.openSync(entry.absolute, 'w', mode)\n    } catch (er) {\n      return oner(er)\n    }\n    const tx = this.transform ? this.transform(entry) || entry : entry\n    if (tx !== entry) {\n      tx.on('error', er => this[ONERROR](er, entry))\n      entry.pipe(tx)\n    }\n\n    tx.on('data', chunk => {\n      try {\n        fs.writeSync(fd, chunk, 0, chunk.length)\n      } catch (er) {\n        oner(er)\n      }\n    })\n\n    tx.on('end', _ => {\n      let er = null\n      // try both, falling futimes back to utimes\n      // if either fails, handle the first error\n      if (entry.mtime && !this.noMtime) {\n        const atime = entry.atime || new Date()\n        const mtime = entry.mtime\n        try {\n          fs.futimesSync(fd, atime, mtime)\n        } catch (futimeser) {\n          try {\n            fs.utimesSync(entry.absolute, atime, mtime)\n          } catch (utimeser) {\n            er = futimeser\n          }\n        }\n      }\n\n      if (this[DOCHOWN](entry)) {\n        const uid = this[UID](entry)\n        const gid = this[GID](entry)\n\n        try {\n          fs.fchownSync(fd, uid, gid)\n        } catch (fchowner) {\n          try {\n            fs.chownSync(entry.absolute, uid, gid)\n          } catch (chowner) {\n            er = er || fchowner\n          }\n        }\n      }\n\n      oner(er)\n    })\n  }\n\n  [DIRECTORY] (entry) {\n    const mode = entry.mode & 0o7777 || this.dmode\n    const er = this[MKDIR](entry.absolute, mode)\n    if (er)\n      return this[ONERROR](er, entry)\n    if (entry.mtime && !this.noMtime) {\n      try {\n        fs.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime)\n      } catch (er) {}\n    }\n    if (this[DOCHOWN](entry)) {\n      try {\n        fs.chownSync(entry.absolute, this[UID](entry), this[GID](entry))\n      } catch (er) {}\n    }\n    entry.resume()\n  }\n\n  [MKDIR] (dir, mode) {\n    try {\n      return mkdir.sync(dir, {\n        uid: this.uid,\n        gid: this.gid,\n        processUid: this.processUid,\n        processGid: this.processGid,\n        umask: this.processUmask,\n        preserve: this.preservePaths,\n        unlink: this.unlink,\n        cache: this.dirCache,\n        cwd: this.cwd,\n        mode: mode\n      })\n    } catch (er) {\n      return er\n    }\n  }\n\n  [LINK] (entry, linkpath, link) {\n    try {\n      fs[link + 'Sync'](linkpath, entry.absolute)\n      entry.resume()\n    } catch (er) {\n      return this[ONERROR](er, entry)\n    }\n  }\n}\n\nUnpack.Sync = UnpackSync\nmodule.exports = Unpack\n","import * as api from './api';\n\n/**\n * Symbol under which we store the { type -> objid } map on object instances\n */\nconst OBJID_SYMBOL = Symbol('$__jsii__objid__$');\n\n/**\n * Symbol we use to tag the constructor of a JSII class\n */\nconst JSII_SYMBOL = Symbol('__jsii__');\n\n/**\n * Get the JSII fqn for an object (if available)\n *\n * This will return something if the object was constructed from a JSII-enabled\n * class/constructor, or if a literal object was annotated with type\n * information.\n */\nexport function jsiiTypeFqn(obj: any): string | undefined {\n    const jsii = obj.constructor[JSII_SYMBOL];\n    return jsii && jsii.fqn;\n}\n\n/**\n * If this object was previously serialized under a given reference, return the same reference\n *\n * This is to retain object identity across invocations.\n */\nexport function objectReference(obj: object): api.ObjRef | undefined {\n    // If this object as already returned\n    if ((obj as any)[OBJID_SYMBOL]) {\n        return { [api.TOKEN_REF]: (obj as any)[OBJID_SYMBOL] };\n    }\n\n    return undefined;\n}\n\nfunction tagObject(obj: object, objid: string) {\n    (obj as any)[OBJID_SYMBOL] = objid;\n}\n\n/**\n * Ensure there's a hidden map with the given symbol name on the given object, and return it\n */\nexport function hiddenMap<T>(obj: any, mapSymbol: symbol): {[key: string]: T} {\n  let map: any = obj[mapSymbol];\n  if (!map) {\n    map = {};\n    Object.defineProperty(obj, mapSymbol, {\n        value: map,\n        configurable: false,\n        enumerable: false,\n        writable: false\n    });\n  }\n  return map;\n}\n\n/**\n * Set the JSII FQN for classes produced by a given constructor\n */\nexport function tagJsiiConstructor(constructor: any, fqn: string) {\n    Object.defineProperty(constructor, JSII_SYMBOL, {\n        configurable: false,\n        enumerable: false,\n        writable: false,\n        value: { fqn }\n    });\n}\n\n/**\n * Table of JSII objects\n *\n * There can be multiple references to the same object, each under a different requested\n * type.\n */\nexport class ObjectTable {\n    private objects: { [objid: string]: RegisteredObject } = { };\n    private nextid = 10000;\n\n    /**\n     * Register the given object with the given type\n     *\n     * Return the existing registration if available.\n     */\n    public registerObject(obj: object, fqn: string): api.ObjRef {\n        if (fqn === undefined) {\n            throw new Error('FQN cannot be undefined');\n        }\n\n        const existingRef = objectReference(obj);\n        if (existingRef) {\n            return existingRef;\n        }\n\n        const objid = this.makeId(fqn);\n        this.objects[objid] = { instance: obj, fqn };\n        tagObject(obj, objid);\n\n        return { [api.TOKEN_REF]: objid };\n    }\n\n    /**\n     * Find the object and registered type for the given ObjRef\n     */\n    public findObject(objref: api.ObjRef): RegisteredObject {\n        if (typeof(objref) !== 'object' || !(api.TOKEN_REF in objref)) {\n            throw new Error(`Malformed object reference: ${JSON.stringify(objref)}`);\n        }\n\n        const objid = objref[api.TOKEN_REF];\n        const obj = this.objects[objid];\n        if (!obj) {\n            throw new Error(`Object ${objid} not found`);\n        }\n        return obj;\n    }\n\n    /**\n     * Delete the registration with the given objref\n     */\n    public deleteObject(objref: api.ObjRef) {\n        this.findObject(objref); // make sure object exists\n        delete this.objects[objref[api.TOKEN_REF]];\n    }\n\n    public get count(): number {\n        return Object.keys(this.objects).length;\n    }\n\n    private makeId(fqn: string) {\n        return `${fqn}@${this.nextid++}`;\n    }\n}\n\nexport interface RegisteredObject {\n    instance: any;\n    fqn: string;\n}\n","import packageInfo = require('../package.json');\nimport { KernelHost } from './host';\nimport { InputOutput } from './in-out';\n\nconst name = packageInfo.name;\nconst version = packageInfo.version;\n\nconst noStack = !!process.env.JSII_NOSTACK;\nconst debug = !!process.env.JSII_DEBUG;\n\nconst inout = new InputOutput();\nconst host = new KernelHost(inout, { debug, noStack });\n\n// say hello\ninout.write({ hello: `${name}@${version}` });\ninout.debug = debug; // we don't want \"hello\" emitted\n\nhost.run();\n","import { api, Kernel } from 'jsii-kernel';\nimport { Input, InputOutput } from './in-out';\n\nexport class KernelHost {\n    private kernel = new Kernel(cb => this.callbackHandler(cb));\n\n    constructor(readonly inout: InputOutput, readonly opts: { debug?: boolean, noStack?: boolean } = { }) {\n        this.kernel.traceEnabled = opts.debug ? true : false;\n    }\n\n    public run() {\n        const req = this.inout.read();\n        if (!req) {\n            return; // done\n        }\n\n        this.processRequest(req, () => this.run());\n    }\n\n    private callbackHandler(callback: api.Callback) {\n\n        // write a \"callback\" response, which is a special response that tells\n        // the client that there's synchonous callback it needs to invoke and\n        // bring back the result via a \"complete\" request.\n        this.inout.write({ callback });\n\n        const self = this;\n\n        return completeCallback();\n\n        function completeCallback() {\n            const req = self.inout.read();\n            if (!req) {\n                throw new Error('Interrupted before callback returned');\n            }\n\n            // if this is a completion for the current callback, then we can\n            // finally stop this nonsense and return the result.\n            const completeReq = req as { complete: api.CompleteRequest };\n            if ('complete' in completeReq && completeReq.complete.cbid === callback.cbid) {\n                if (completeReq.complete.err) {\n                    throw new Error(completeReq.complete.err);\n                }\n\n                return completeReq.complete.result;\n            }\n\n            // otherwise, process the request normally, but continue to wait for\n            // our callback to be completed. sync=true to enforce that `completeCallback`\n            // will be called synchronously and return value will be chained back so we can\n            // return it to the callback handler.\n            return self.processRequest(req, completeCallback, /* sync */ true);\n        }\n    }\n\n    /**\n     * Processes the input request `req` and writes the output response to\n     * stdout. This method invokes `next` when the request was fully processed.\n     * This either happens synchronously or asynchronously depending on the api\n     * (e.g. the \"end\" api will wait for an async promise to be fulfilled before\n     * it writes the response)\n     *\n     * @param req The input request\n     * @param next A callback to invoke to continue\n     * @param sync If this is 'true', \"next\" must be called synchronously. This means\n     *             that we won't process any async activity (begin/complete). The kernel\n     *             doesn't allow any async operations during a sync callback, so this shouldn't\n     *             happen, so we assert in this case to find bugs.\n     */\n    private processRequest(req: Input, next: () => void, sync = false) {\n        if ('callback' in req) {\n            throw new Error('Unexpected `callback` result. This request should have been processed by a callback handler');\n        }\n\n        if (!('api' in req)) {\n            throw new Error('Malformed request, \"api\" field is required');\n        }\n\n        const apiReq = req as { api: string } & api.KernelRequest;\n        const fn = this.findApi(apiReq.api);\n\n        try {\n            const ret = fn.call(this.kernel, req);\n\n            // special case for 'begin' and 'complete' which are on an async\n            // promise path. in order to allow the kernel to actually fulfill\n            // the promise, and continue any async flows (which may potentially\n            // start other promises), we respond only within a setImmediate\n            // block, which is scheduled in the same micro-tasks queue as\n            // promises. see the kernel test 'async overrides: two overrides'\n            // for an example for this use case.\n            if (apiReq.api === 'begin' || apiReq.api === 'complete') {\n                checkIfAsyncIsAllowed();\n\n                this.debug('processing pending promises before responding');\n\n                setImmediate(() => {\n                    this.writeOkay(ret);\n                    next();\n                });\n\n                return;\n            }\n\n            // if this is an async method, return immediately and\n            // call next only when the promise is fulfilled.\n            if (this.isPromise(ret)) {\n                checkIfAsyncIsAllowed();\n\n                this.debug('waiting for promise to be fulfilled');\n\n                const promise = ret;\n                promise\n                    .then(val => {\n                        this.debug('promise succeeded:', val);\n                        this.writeOkay(val);\n                        next();\n                    })\n                    .catch(e => {\n                        this.debug('promise failed:', e);\n                        this.writeError(e);\n                        next();\n                    });\n\n                return;\n            }\n\n            this.writeOkay(ret);\n        } catch (e) {\n            this.writeError(e);\n        }\n\n        // indicate this request was processed (synchronously).\n        return next();\n\n        function checkIfAsyncIsAllowed() {\n            if (sync) {\n                throw new Error('Cannot handle async operations while waiting for a sync callback to return');\n            }\n        }\n    }\n\n    /**\n     * Writes an \"ok\" result to stdout.\n     */\n    private writeOkay(result: any) {\n        const res = { ok: result };\n        this.inout.write(res);\n    }\n\n    /**\n     * Writes an \"error\" result to stdout.\n     */\n    private writeError(error: any) {\n        const res = { error: error.message, stack: undefined };\n        if (!this.opts.noStack) {\n            res.stack = error.stack;\n        }\n        this.inout.write(res);\n    }\n\n    /**\n     * Returns true if the value is a promise.\n     */\n    private isPromise(v: any): v is Promise<any> {\n        return v && v.then && typeof(v.then) === 'function';\n    }\n\n    /**\n     * Given a kernel api name, returns the function to invoke.\n     */\n    private findApi(apiName: string): (this: Kernel, arg: Input) => any {\n        const fn = (this.kernel as any)[apiName];\n        if (typeof fn !== 'function') {\n            throw new Error('Invalid kernel api call: ' + apiName);\n        }\n        return fn;\n    }\n\n    private debug(...args: any[]) {\n        if (!this.opts.debug) {\n            return;\n        }\n        // tslint:disable-next-line: no-console\n        console.error(...args);\n    }\n}\n","import * as fs from 'fs-extra';\nimport * as spec from 'jsii-spec';\nimport * as os from 'os';\nimport * as path from 'path';\nimport { SourceMapConsumer } from 'source-map';\nimport * as tar from 'tar';\nimport * as vm from 'vm';\nimport * as api from './api';\nimport { TOKEN_REF } from './api';\nimport { ObjectTable, tagJsiiConstructor } from './objects';\nimport wire = require('./serialization');\n\nexport class Kernel {\n    /**\n     * Set to true for verbose debugging.\n     */\n    public traceEnabled = false;\n\n    private assemblies: { [name: string]: Assembly } = { };\n    private objects = new ObjectTable();\n    private cbs: { [cbid: string]: Callback } = { };\n    private waiting: { [cbid: string]: Callback } = { };\n    private promises: { [prid: string]: AsyncInvocation } = { };\n    private nextid = 20000; // incrementing counter for objid, cbid, promiseid\n    private syncInProgress?: string; // forbids async calls (begin) while processing sync calls (get/set/invoke)\n    private installDir?: string;\n\n    private readonly sandbox: vm.Context;\n    private readonly sourceMaps: { [assm: string]: SourceMapConsumer } = {};\n\n    /**\n     * Creates a jsii kernel object.\n     *\n     * @param callbackHandler This handler is invoked when a synchronous callback is called.\n     *                        It's responsibility is to execute the callback and return it's\n     *                        result (or throw an error).\n     */\n    constructor(public callbackHandler: (callback: api.Callback) => any) {\n        // `setImmediate` is required for tests to pass (it is otherwise\n        // impossible to wait for in-VM promises to complete)\n\n        // `Buffer` is required when using simple-resource-bundler.\n\n        // HACK: when we webpack jsii-runtime, all \"require\" statements get transpiled,\n        // so modules can be resolved within the pack. However, here we actually want to\n        // let loaded modules to use the native node \"require\" method.\n        // I wonder if webpack has some pragma that allows opting-out at certain points\n        // in the code.\n        const moduleLoad = require('module').Module._load;\n        const nodeRequire = (p: string) => moduleLoad(p, module, false);\n\n        this.sandbox = vm.createContext({\n            Buffer, // to use simple-resource-bundler\n            setImmediate, // async tests\n            require: nodeRequire // modules need to \"require\"\n        });\n    }\n\n    public async load(req: api.LoadRequest): Promise<api.LoadResponse> {\n        this._debug('load', req);\n\n        if ('assembly' in req) {\n            throw new Error('`assembly` field is deprecated for \"load\", use `name`, `version` and `tarball` instead');\n        }\n\n        if (!this.installDir) {\n            this.installDir  = await fs.mkdtemp(path.join(os.tmpdir(), 'jsii-kernel-'));\n            await fs.mkdirp(path.join(this.installDir, 'node_modules'));\n            this._debug('creating jsii-kernel modules workdir:', this.installDir);\n\n            process.on('exit', () => {\n                if (this.installDir) {\n                    this._debug('removing install dir', this.installDir);\n                    fs.removeSync(this.installDir); // can't use async version during exit\n                }\n            });\n        }\n\n        const pkgname = req.name;\n        const pkgver  = req.version;\n\n        // check if we already have such a module\n        const packageDir = path.join(this.installDir, 'node_modules', pkgname);\n        if (await fs.pathExists(packageDir)) {\n            // module exists, verify version\n            const epkg = await fs.readJson(path.join(packageDir, 'package.json'));\n            if (epkg.version !== pkgver) {\n                throw new Error(`Multiple versions ${pkgver} and ${epkg.version} of the `\n                + `package '${pkgname}' cannot be loaded together since this is unsupported by `\n                + `some runtime environments`);\n            }\n\n            // same version, no-op\n            this._debug('look up already-loaded assembly', pkgname);\n            const assm = this.assemblies[pkgname];\n\n            return {\n                assembly: assm.metadata.name,\n                types: Object.keys(assm.metadata.types || {}).length,\n            };\n        } else {\n            // untar the archive to a staging directory, read the jsii spec from it\n            // and then move it to the node_modules directory of the kernel.\n            const staging = await fs.mkdtemp(path.join(os.tmpdir(), 'jsii-kernel-install-staging-'));\n            try {\n                await tar.extract({ strict: true, file: req.tarball, cwd: staging });\n\n                // read .jsii metadata from the root of the package\n                const  jsiiMetadataFile = path.join(staging, 'package', spec.SPEC_FILE_NAME);\n                if (!(await fs.pathExists(jsiiMetadataFile))) {\n                    throw new Error(`Package tarball ${req.tarball} must have a file named ${spec.SPEC_FILE_NAME} at the root`);\n                }\n                const assmSpec = await fs.readJson(jsiiMetadataFile) as spec.Assembly;\n\n                // \"install\" to \"node_modules\" directory\n                await fs.move(path.join(staging, 'package'), packageDir);\n\n                // load the module and capture it's closure\n                const closure = this._execute(`require(String.raw\\`${packageDir}\\`)`, packageDir);\n                const assm = new Assembly(assmSpec, closure);\n                this._addAssembly(assm);\n\n                return {\n                    assembly: assmSpec.name,\n                    types: Object.keys(assmSpec.types || {}).length,\n                };\n            } finally {\n                this._debug('removing staging directory:', staging);\n                await fs.remove(staging);\n            }\n        }\n    }\n\n    public create(req: api.CreateRequest): api.CreateResponse {\n        return this._create(req);\n    }\n\n    public del(req: api.DelRequest): api.DelResponse {\n        const { objref } = req;\n\n        this._debug('del', objref);\n        this.objects.deleteObject(objref);\n\n        return { };\n    }\n\n    public sget(req: api.StaticGetRequest): api.GetResponse {\n        const { fqn, property } = req;\n        const symbol = `${fqn}.${property}`;\n        this._debug('sget', symbol);\n        const ti = this._typeInfoForProperty(fqn, property);\n\n        if (!ti.static) {\n            throw new Error(`property ${symbol} is not static`);\n        }\n\n        const prototype = this._findSymbol(fqn);\n\n        const value = this._ensureSync(`property ${property}`, () =>\n            this._wrapSandboxCode(() => prototype[property]));\n\n        this._debug('value:', value);\n        const ret = this._fromSandbox(value, ti);\n        this._debug('ret', ret);\n        return { value: ret };\n    }\n\n    public sset(req: api.StaticSetRequest): api.SetResponse {\n        const { fqn, property, value } = req;\n        const symbol = `${fqn}.${property}`;\n        this._debug('sset', symbol);\n        const ti = this._typeInfoForProperty(fqn, property);\n\n        if (!ti.static) {\n            throw new Error(`property ${symbol} is not static`);\n        }\n\n        if (ti.immutable) {\n            throw new Error(`static property ${symbol} is readonly`);\n        }\n\n        const prototype = this._findSymbol(fqn);\n\n        this._ensureSync(`property ${property}`, () =>\n            this._wrapSandboxCode(() => prototype[property] = this._toSandbox(value, ti)));\n\n        return {};\n    }\n\n    public get(req: api.GetRequest): api.GetResponse {\n        const { objref, property } = req;\n        this._debug('get', objref, property);\n        const { instance, fqn } = this.objects.findObject(objref);\n        const ti = this._typeInfoForProperty(fqn, property);\n\n        // if the property is overridden by the native code and \"get\" is called on the object, it\n        // means that the native code is trying to access the \"super\" property. in order to enable\n        // that, we actually keep a copy of the original property descriptor when we override,\n        // so `findPropertyTarget` will return either the original property name (\"property\") or\n        // the \"super\" property name (somehing like \"$jsii$super$<property>$\").\n        const propertyToGet = this._findPropertyTarget(instance, property);\n\n        // make the actual \"get\", and block any async calls that might be performed\n        // by jsii overrides.\n        const value = this._ensureSync(`property '${objref[TOKEN_REF]}.${propertyToGet}'`,\n                                       () => this._wrapSandboxCode(() => instance[propertyToGet]));\n        this._debug('value:', value);\n        const ret = this._fromSandbox(value, ti);\n        this._debug('ret:', ret);\n        return { value:  ret };\n    }\n\n    public set(req: api.SetRequest): api.SetResponse {\n        const { objref, property, value } = req;\n        this._debug('set', objref, property, value);\n        const { instance, fqn } = this.objects.findObject(objref);\n\n        const propInfo = this._typeInfoForProperty(fqn, req.property);\n\n        if (propInfo.immutable) {\n            throw new Error(`Cannot set value of immutable property ${req.property} to ${req.value}`);\n        }\n\n        const propertyToSet = this._findPropertyTarget(instance, property);\n\n        this._ensureSync(`property '${objref[TOKEN_REF]}.${propertyToSet}'`,\n                         () => this._wrapSandboxCode(() => instance[propertyToSet] = this._toSandbox(value, propInfo)));\n\n        return { };\n    }\n\n    public invoke(req: api.InvokeRequest): api.InvokeResponse {\n        const { objref, method } = req;\n        const args = req.args || [ ];\n\n        this._debug('invoke', objref, method, args);\n        const { ti, obj, fn } = this._findInvokeTarget(objref, method, args);\n\n        // verify this is not an async method\n        if (ti.async) {\n            throw new Error(`${method} is an async method, use \"begin\" instead`);\n        }\n\n        const ret = this._ensureSync(`method '${objref[TOKEN_REF]}.${method}'`, () => {\n            return this._wrapSandboxCode(() => fn.apply(obj, this._toSandboxValues(args, ti.parameters)));\n        });\n\n        const result = this._fromSandbox(ret, ti.returns || 'void');\n        this._debug('invoke result', result);\n\n        return { result };\n    }\n\n    public sinvoke(req: api.StaticInvokeRequest): api.InvokeResponse {\n        const { fqn, method } = req;\n        const args = req.args || [ ];\n\n        this._debug('sinvoke', fqn, method, args);\n\n        const ti = this._typeInfoForMethod(fqn, method);\n\n        if (!ti.static) {\n            throw new Error(`${fqn}.${method} is not a static method`);\n        }\n\n        // verify this is not an async method\n        if (ti.async) {\n            throw new Error(`${method} is an async method, use \"begin\" instead`);\n        }\n\n        const prototype = this._findSymbol(fqn);\n        const fn = prototype[method] as (...params: any[]) => any;\n\n        const ret = this._ensureSync(`method '${fqn}.${method}'`, () => {\n            return this._wrapSandboxCode(() => fn.apply(prototype, this._toSandboxValues(args, ti.parameters)));\n        });\n\n        this._debug('method returned:', ret);\n        return { result: this._fromSandbox(ret, ti.returns || 'void') };\n    }\n\n    public begin(req: api.BeginRequest): api.BeginResponse {\n        const { objref, method } = req;\n        const args = req.args || [ ];\n\n        this._debug('begin', objref, method, args);\n\n        if (this.syncInProgress) {\n            // tslint:disable-next-line:max-line-length\n            throw new Error(`Cannot invoke async method '${req.objref[TOKEN_REF]}.${req.method}' while sync ${this.syncInProgress} is being processed`);\n        }\n\n        const { ti, obj, fn } = this._findInvokeTarget(objref, method, args);\n\n        // verify this is indeed an async method\n        if (!ti.async) {\n            throw new Error(`Method ${method} is expected to be an async method`);\n        }\n\n        const promise = this._wrapSandboxCode(() => fn.apply(obj, this._toSandboxValues(args, ti.parameters))) as Promise<any>;\n\n        // since we are planning to resolve this promise in a different scope\n        // we need to handle rejections here [1]\n        // [1]: https://stackoverflow.com/questions/40920179/should-i-refrain-from-handling-promise-rejection-asynchronously/40921505\n        promise.catch(_ => undefined);\n\n        const prid = this._makeprid();\n        this.promises[prid] = {\n            promise,\n            method: ti\n        };\n\n        return { promiseid: prid };\n    }\n\n    public async end(req: api.EndRequest): Promise<api.EndResponse> {\n        const { promiseid } = req;\n\n        this._debug('end', promiseid);\n\n        const { promise, method } = this.promises[promiseid];\n        if (!promise) {\n            throw new Error(`Cannot find promise with ID: ${promiseid}`);\n        }\n\n        let result;\n        try {\n            result = await promise;\n            this._debug('promise result:', result);\n        } catch (e) {\n            this._debug('promise error:', e);\n            throw mapSource(e, this.sourceMaps);\n        }\n\n        return { result: this._fromSandbox(result, method.returns || 'void') };\n    }\n\n    public callbacks(_req?: api.CallbacksRequest): api.CallbacksResponse {\n        this._debug('callbacks');\n        const ret = Object.keys(this.cbs).map(cbid => {\n            const cb = this.cbs[cbid];\n            this.waiting[cbid] = cb; // move to waiting\n            const callback: api.Callback = {\n                cbid,\n                cookie: cb.override.cookie,\n                invoke: {\n                    objref: cb.objref,\n                    method: cb.override.method,\n                    args: cb.args\n                },\n            };\n            return callback;\n        });\n\n        // move all callbacks to the wait queue and clean the callback queue.\n        this.cbs = { };\n        return { callbacks: ret };\n    }\n\n    public complete(req: api.CompleteRequest): api.CompleteResponse {\n        const { cbid, err, result } = req;\n\n        this._debug('complete', cbid, err, result);\n\n        if (!(cbid in this.waiting)) {\n            throw new Error(`Callback ${cbid} not found`);\n        }\n\n        const cb = this.waiting[cbid];\n        if (err) {\n            this._debug('completed with error:', err);\n            cb.fail(new Error(err));\n        } else {\n            const sandoxResult = this._toSandbox(result, cb.expectedReturnType || 'void');\n            this._debug('completed with result:', sandoxResult);\n            cb.succeed(sandoxResult);\n        }\n\n        delete this.waiting[cbid];\n\n        return { cbid };\n    }\n\n    /**\n     * Returns the language-specific names for a jsii module.\n     * @param assemblyName The name of the jsii module (i.e. jsii$jsii_calculator_lib$)\n     */\n    public naming(req: api.NamingRequest): api.NamingResponse {\n        const assemblyName = req.assembly;\n\n        this._debug('naming', assemblyName);\n\n        const assembly = this._assemblyFor(assemblyName);\n        const targets = assembly.metadata.targets;\n        if (!targets) {\n            throw new Error(`Unexpected - \"targets\" for ${assemblyName} is missing!`);\n        }\n\n        return { naming: targets };\n    }\n\n    public stats(_req?: api.StatsRequest): api.StatsResponse {\n        return {\n            objectCount: this.objects.count\n        };\n    }\n\n    private _addAssembly(assm: Assembly) {\n        this.assemblies[assm.metadata.name] = assm;\n\n        // add the __jsii__.fqn property on every constructor. this allows\n        // traversing between the javascript and jsii worlds given any object.\n        for (const fqn of Object.keys(assm.metadata.types || {})) {\n            const typedef = assm.metadata.types![fqn];\n            switch (typedef.kind) {\n                case spec.TypeKind.Interface:\n                    continue; // interfaces don't really exist\n                case spec.TypeKind.Class:\n                case spec.TypeKind.Enum:\n                    const constructor = this._findSymbol(fqn);\n                    tagJsiiConstructor(constructor, fqn);\n            }\n        }\n    }\n\n    // find the javascript constructor function for a jsii FQN.\n    private _findCtor(fqn: string, args: any[]): { ctor: any, parameters?: spec.Parameter[] } {\n        if (fqn === wire.EMPTY_OBJECT_FQN) {\n            return { ctor: Object };\n        }\n\n        const typeinfo = this._typeInfoForFqn(fqn);\n\n        switch (typeinfo.kind) {\n            case spec.TypeKind.Class:\n                const classType = typeinfo as spec.ClassType;\n                this._validateMethodArguments(classType.initializer, args);\n                return { ctor: this._findSymbol(fqn), parameters: classType.initializer && classType.initializer.parameters };\n\n            case spec.TypeKind.Interface:\n                throw new Error(`Cannot create an object with an FQN of an interface: ${fqn}`);\n\n            default:\n                throw new Error(`Unexpected FQN kind: ${fqn}`);\n        }\n    }\n\n    // prefixed with _ to allow calling this method internally without\n    // getting it recorded for testing.\n    private _create(req: api.CreateRequest): api.CreateResponse {\n        this._debug('create', req);\n        const { fqn, overrides } = req;\n\n        const requestArgs = req.args || [];\n\n        const ctorResult = this._findCtor(fqn, requestArgs);\n        const ctor = ctorResult.ctor;\n        const obj = this._wrapSandboxCode(() => new ctor(...this._toSandboxValues(requestArgs, ctorResult.parameters)));\n        const objref = this.objects.registerObject(obj, fqn);\n\n        // overrides: for each one of the override method names, installs a\n        // method on the newly created object which represents the remote \"reverse proxy\".\n\n        if (overrides) {\n            this._debug('overrides', overrides);\n\n            const overrideTypeErrorMessage = 'Override can either be \"method\" or \"property\"';\n            const methods = new Set<string>();\n            const properties = new Set<string>();\n\n            for (const override of overrides) {\n                if (api.isMethodOverride(override)) {\n                    if (api.isPropertyOverride(override)) { throw new Error(overrideTypeErrorMessage); }\n                    if (methods.has(override.method)) { throw new Error(`Duplicate override for method '${override.method}'`); }\n                    methods.add(override.method);\n\n                    this._applyMethodOverride(obj, objref, fqn, override);\n                } else if (api.isPropertyOverride(override)) {\n                    if (api.isMethodOverride(override)) { throw new Error(overrideTypeErrorMessage); }\n                    if (properties.has(override.property)) { throw Error(`Duplicate override for property '${override.property}'`); }\n                    properties.add(override.property);\n\n                    this._applyPropertyOverride(obj, objref, fqn, override);\n                } else {\n                    throw new Error(overrideTypeErrorMessage);\n                }\n            }\n        }\n\n        return objref;\n    }\n\n    private _getSuperPropertyName(name: string) {\n        return `$jsii$super$${name}$`;\n    }\n\n    private _applyPropertyOverride(obj: any, objref: api.ObjRef, typeFqn: string, override: api.PropertyOverride) {\n        let propInfo;\n        if (typeFqn !== wire.EMPTY_OBJECT_FQN) {\n            // error if we can find a method with this name\n            if (this._tryTypeInfoForMethod(typeFqn, override.property)) {\n                throw new Error(`Trying to override method '${override.property}' as a property`);\n            }\n\n            propInfo = this._tryTypeInfoForProperty(typeFqn, override.property);\n        }\n\n        // if this is a private property (i.e. doesn't have `propInfo` the object has a key)\n        if (!propInfo && override.property in obj) {\n            this._debug(`Skipping override of private property ${override.property}`);\n            return;\n        }\n\n        if (!propInfo) {\n            // We've overriding a property on an object we have NO type information on (probably\n            // because it's an anonymous object).\n            // Pretend it's 'prop: any';\n            //\n            // FIXME: We could do better type checking during the conversion if JSII clients\n            // would tell us the intended interface type.\n            propInfo = {\n                name: override.property,\n                type: spec.CANONICAL_ANY,\n            };\n        }\n\n        this._defineOverridenProperty(obj, objref, override, propInfo);\n    }\n\n    private _defineOverridenProperty(obj: any, objref: api.ObjRef, override: api.PropertyOverride, propInfo: spec.Property) {\n        const self = this;\n        const propertyName = override.property!;\n\n        this._debug('apply override', propertyName);\n\n        // save the old property under $jsii$super$<prop>$ so that property overrides\n        // can still access it via `super.<prop>`.\n        const prev = Object.getOwnPropertyDescriptor(obj, propertyName) || {\n            value: undefined,\n            writable: true,\n            enumerable: true,\n            configurable: true\n        };\n\n        const prevEnumerable = prev.enumerable;\n        prev.enumerable = false;\n        Object.defineProperty(obj, this._getSuperPropertyName(propertyName), prev);\n\n        // we add callbacks for both 'get' and 'set', even if the property\n        // is readonly. this is fine because if you try to set() a readonly\n        // property, it will fail.\n        Object.defineProperty(obj, propertyName, {\n            enumerable: prevEnumerable,\n            configurable: prev.configurable,\n            get: () => {\n                self._debug('virtual get', objref, propertyName, { cookie: override.cookie });\n                const result = self.callbackHandler({\n                    cookie: override.cookie,\n                    cbid: self._makecbid(),\n                    get: { objref, property: propertyName }\n                });\n                this._debug('callback returned', result);\n                return this._toSandbox(result, propInfo);\n            },\n            set: (value: any) => {\n                self._debug('virtual set', objref, propertyName, { cookie: override.cookie });\n                self.callbackHandler({\n                    cookie: override.cookie,\n                    cbid: self._makecbid(),\n                    set: { objref, property: propertyName, value: self._fromSandbox(value, propInfo) }\n                });\n            }\n        });\n    }\n\n    private _applyMethodOverride(obj: any, objref: api.ObjRef, typeFqn: string, override: api.MethodOverride) {\n        let methodInfo;\n        if (typeFqn !== wire.EMPTY_OBJECT_FQN) {\n            // error if we can find a property with this name\n            if (this._tryTypeInfoForProperty(typeFqn, override.method)) {\n                throw new Error(`Trying to override property '${override.method}' as a method`);\n            }\n\n            methodInfo = this._tryTypeInfoForMethod(typeFqn, override.method);\n        }\n\n        // If this is a private method (doesn't have methodInfo, key resolves on the object), we\n        // are going to skip the override.\n        if (!methodInfo && obj[override.method]) {\n            this._debug(`Skipping override of private method ${override.method}`);\n            return;\n        }\n\n        if (!methodInfo) {\n            // We've overriding a method on an object we have NO type information on (probably\n            // because it's an anonymous object).\n            // Pretend it's an (...args: any[]) => any\n            //\n            // FIXME: We could do better type checking during the conversion if JSII clients\n            // would tell us the intended interface type.\n            methodInfo = {\n                name: override.method,\n                returns: { type: spec.CANONICAL_ANY },\n                parameters: [{\n                    name: 'args',\n                    type: spec.CANONICAL_ANY,\n                    variadic: true\n                }],\n                variadic: true\n            };\n        }\n\n        this._defineOverridenMethod(obj, objref, override, methodInfo);\n    }\n\n    private _defineOverridenMethod(obj: any, objref: api.ObjRef, override: api.MethodOverride, methodInfo: spec.Method) {\n        const self = this;\n        const methodName = override.method;\n\n        if (methodInfo.async) {\n            // async method override\n            Object.defineProperty(obj, methodName, {\n                enumerable: false,\n                configurable: false,\n                writable: false,\n                value: (...methodArgs: any[]) => {\n                    self._debug('invoke async method override', override);\n                    const args = self._toSandboxValues(methodArgs, methodInfo.parameters);\n                    return new Promise<any>((succeed, fail) => {\n                        const cbid = self._makecbid();\n                        self._debug('adding callback to queue', cbid);\n                        self.cbs[cbid] = {\n                            objref,\n                            override,\n                            args,\n                            expectedReturnType: methodInfo.returns || 'void',\n                            succeed,\n                            fail\n                        };\n                    });\n                }\n            });\n        } else {\n            // sync method override (method info is not required)\n            Object.defineProperty(obj, methodName, {\n                enumerable: false,\n                configurable: false,\n                writable: false,\n                value: (...methodArgs: any[]) => {\n                    self._debug('invoke sync method override', override, 'args', methodArgs);\n                    // We should be validating the actual arguments according to the\n                    // declared parameters here, but let's just assume the JSII runtime on the\n                    // other end has done its work.\n                    const result = self.callbackHandler({\n                        cookie: override.cookie,\n                        cbid: self._makecbid(),\n                        invoke: {\n                            objref,\n                            method: methodName,\n                            args: this._fromSandboxValues(methodArgs, methodInfo.parameters),\n                        }\n                    });\n                    self._debug('Result', result);\n                    return this._toSandbox(result, methodInfo.returns || 'void');\n                }\n            });\n        }\n    }\n\n    private _findInvokeTarget(objref: any, methodName: string, args: any[]) {\n        const { instance, fqn } = this.objects.findObject(objref);\n        const ti = this._typeInfoForMethod(fqn, methodName);\n        this._validateMethodArguments(ti, args);\n\n        // always first look up the method in the prototype. this practically bypasses\n        // any methods overridden by derived classes (which are by definition native\n        // methods). this serves to allow native call to invoke \"super.method()\" when\n        // overriding the method.\n        // if we didn't find the method on the prototype, it could be a literal object\n        // that implements an interface, so we look if we have the method on the object\n        // itself. if we do, we invoke it.\n        let fn = instance.constructor.prototype[methodName];\n        if (!fn) {\n            fn = instance[methodName];\n            if (!fn) {\n                throw new Error(`Cannot find ${methodName} on object`);\n            }\n        }\n        return { ti, obj: instance, fn };\n    }\n\n    private _validateMethodArguments(method: spec.Callable | undefined, args: any[]) {\n        const params: spec.Parameter[] = (method && method.parameters) || [];\n\n        // error if args > params\n        if (args.length > params.length && !(method && method.variadic)) {\n            throw new Error(`Too many arguments (method accepts ${params.length} parameters, got ${args.length} arguments)`);\n        }\n\n        for (let i = 0; i < params.length; ++i) {\n            const param = params[i];\n            const arg = args[i];\n\n            if (param.variadic) {\n                if (params.length <= i) { return; } // No vararg was provided\n                for (let j = i ; j < params.length ; j++) {\n                    if (!param.optional && params[j] === undefined) {\n                        // tslint:disable-next-line:max-line-length\n                        throw new Error(`Unexpected 'undefined' value at index ${j - i} of variadic argument '${param.name}' of type '${spec.describeTypeReference(param.type)}'`);\n                    }\n                }\n            } else if (!param.optional && arg === undefined) {\n                // tslint:disable-next-line:max-line-length\n                throw new Error(`Not enough arguments. Missing argument for the required parameter '${param.name}' of type '${spec.describeTypeReference(param.type)}'`);\n            }\n        }\n    }\n\n    private _assemblyFor(assemblyName: string) {\n        const assembly = this.assemblies[assemblyName];\n        if (!assembly) {\n            throw new Error(`Could not find assembly: ${assemblyName}`);\n        }\n        return assembly;\n    }\n\n    private _findSymbol(fqn: string) {\n        const [ assemblyName, ...parts ] = fqn.split('.');\n        const assembly = this._assemblyFor(assemblyName);\n\n        let curr = assembly.closure;\n        while (true) {\n            const name = parts.shift();\n            if (!name) {\n                break;\n            }\n\n            curr = curr[name];\n        }\n        if (!curr) {\n            throw new Error(`Could not find symbol ${fqn}`);\n        }\n        return curr;\n    }\n\n    private _typeInfoForFqn(fqn: string): spec.Type {\n        const components = fqn.split('.');\n        const moduleName = components[0];\n\n        const assembly = this.assemblies[moduleName];\n        if (!assembly) {\n            throw new Error(`Module '${moduleName}' not found`);\n        }\n\n        const types = assembly.metadata.types || {};\n        const fqnInfo = types[fqn];\n        if (!fqnInfo) {\n            throw new Error(`Type '${fqn}' not found`);\n        }\n\n        return fqnInfo;\n    }\n\n    private _typeInfoForMethod(fqn: string, methodName: string): spec.Method {\n        const ti = this._tryTypeInfoForMethod(fqn, methodName);\n        if (!ti) {\n            throw new Error(`Class ${fqn} doesn't have a method '${methodName}'`);\n        }\n        return ti;\n    }\n\n    private _tryTypeInfoForMethod(fqn: string, methodName: string): spec.Method | undefined {\n        const typeinfo = this._typeInfoForFqn(fqn);\n\n        const methods = (typeinfo as (spec.ClassType | spec.InterfaceType)).methods || [];\n        const bases = [\n            (typeinfo as spec.ClassType).base,\n            ...((typeinfo as spec.InterfaceType).interfaces || []) ];\n\n        for (const m of methods) {\n            if (m.name === methodName) {\n                return m;\n            }\n        }\n\n        // recursion to parent type (if exists)\n        for (const base of bases) {\n            if (!base) { continue; }\n\n            const found = this._tryTypeInfoForMethod(base, methodName);\n            if (found) {\n                return found;\n            }\n        }\n\n        return undefined;\n    }\n\n    private _tryTypeInfoForProperty(fqn: string, property: string): spec.Property | undefined {\n        if (!fqn) {\n            throw new Error('missing \"fqn\"');\n        }\n        const typeInfo = this._typeInfoForFqn(fqn);\n\n        let properties;\n        let bases;\n\n        if (spec.isClassType(typeInfo)) {\n            const classTypeInfo = typeInfo as spec.ClassType;\n            properties = classTypeInfo.properties;\n            bases = classTypeInfo.base ? [ classTypeInfo.base ] : [];\n        } else if (spec.isInterfaceType(typeInfo)) {\n            const interfaceTypeInfo = typeInfo as spec.InterfaceType;\n            properties = interfaceTypeInfo.properties;\n            bases = interfaceTypeInfo.interfaces || [];\n        } else {\n            throw new Error(`Type of kind ${typeInfo.kind} does not have properties`);\n        }\n\n        for (const p of properties || []) {\n            if (p.name === property) {\n                return p;\n            }\n        }\n\n        // recurse to parent type (if exists)\n        for (const baseFqn of bases) {\n            const ret = this._tryTypeInfoForProperty(baseFqn, property);\n            if (ret) {\n                return ret;\n            }\n        }\n\n        return undefined;\n    }\n\n    private _typeInfoForProperty(fqn: string, property: string): spec.Property {\n        const typeInfo = this._tryTypeInfoForProperty(fqn, property);\n        if (!typeInfo) {\n            throw new Error(`Type ${fqn} doesn't have a property '${property}'`);\n        }\n        return typeInfo;\n    }\n\n    private _toSandbox(v: any, expectedType: wire.OptionalValueOrVoid): any {\n        const serTypes = wire.serializationType(expectedType, this._typeInfoForFqn.bind(this));\n        this._debug('toSandbox', v, JSON.stringify(serTypes));\n\n        const host: wire.SerializerHost = {\n            objects: this.objects,\n            debug: this._debug.bind(this),\n            findSymbol: this._findSymbol.bind(this),\n            lookupType: this._typeInfoForFqn.bind(this),\n            recurse: this._toSandbox.bind(this),\n        };\n\n        const errors = new Array<string>();\n        for (const { serializationClass, typeRef } of serTypes) {\n            try {\n                return wire.SERIALIZERS[serializationClass].deserialize(v, typeRef, host);\n            } catch (e) {\n                // If no union (99% case), rethrow immediately to preserve stack trace\n                if (serTypes.length === 1) { throw e; }\n                errors.push(e.message);\n            }\n        }\n\n        throw new Error(`Value did not match any type in union: ${errors}`);\n    }\n\n    private _fromSandbox(v: any, targetType: wire.OptionalValueOrVoid): any {\n        const serTypes = wire.serializationType(targetType, this._typeInfoForFqn.bind(this));\n        this._debug('fromSandbox', v, JSON.stringify(serTypes));\n\n        const host: wire.SerializerHost = {\n            objects: this.objects,\n            debug: this._debug.bind(this),\n            findSymbol: this._findSymbol.bind(this),\n            lookupType: this._typeInfoForFqn.bind(this),\n            recurse: this._fromSandbox.bind(this),\n        };\n\n        const errors = new Array<string>();\n        for (const { serializationClass, typeRef } of serTypes) {\n            try {\n                return wire.SERIALIZERS[serializationClass].serialize(v, typeRef, host);\n            } catch (e) {\n                // If no union (99% case), rethrow immediately to preserve stack trace\n                if (serTypes.length === 1) { throw e; }\n                errors.push(e.message);\n            }\n        }\n\n        throw new Error(`Value did not match any type in union: ${errors}`);\n    }\n\n    private _toSandboxValues(xs: any[], parameters?: spec.Parameter[]) {\n        return this._boxUnboxParameters(xs, parameters, this._toSandbox.bind(this));\n    }\n\n    private _fromSandboxValues(xs: any[], parameters?: spec.Parameter[]) {\n        return this._boxUnboxParameters(xs, parameters, this._fromSandbox.bind(this));\n    }\n\n    private _boxUnboxParameters(xs: any[], parameters: spec.Parameter[] | undefined, boxUnbox: (x: any, t: wire.OptionalValueOrVoid) => any) {\n        parameters = [...(parameters || [])];\n        const variadic = parameters.length > 0 && !!parameters[parameters.length - 1].variadic;\n        // Repeat the last (variadic) type to match the number of actual arguments\n        while (variadic && parameters.length < xs.length) {\n            parameters.push(parameters[parameters.length - 1]);\n        }\n        if (xs.length > parameters.length) {\n            throw new Error(`Argument list (${JSON.stringify(xs)}) not same size as expected argument list (length ${parameters.length})`);\n        }\n        return xs.map((x, i) => boxUnbox(x, parameters![i]));\n    }\n\n    private _debug(...args: any[]) {\n        if (this.traceEnabled) {\n            // tslint:disable-next-line:no-console\n            console.error.apply(console, [\n                '[jsii-kernel]',\n                ...args\n            ]);\n        }\n    }\n\n    /**\n     * Ensures that `fn` is called and defends against beginning to invoke\n     * async methods until fn finishes (successfully or not).\n     */\n    private _ensureSync<T>(desc: string, fn: () => T): T {\n        this.syncInProgress = desc;\n        try {\n            return fn();\n        } catch (e) {\n            throw e;\n        } finally {\n            delete this.syncInProgress;\n        }\n    }\n\n    private _findPropertyTarget(obj: any, property: string) {\n        const superProp = this._getSuperPropertyName(property);\n        if (superProp in obj) {\n            return superProp;\n        } else {\n            return property;\n        }\n    }\n\n    //\n    // type information\n    //\n\n    private _makecbid() {\n        return `jsii::callback::${this.nextid++}`;\n    }\n\n    private _makeprid() {\n        return `jsii::promise::${this.nextid++}`;\n    }\n\n    private _wrapSandboxCode<T>(fn: () => T): T {\n        try {\n            return fn();\n        } catch (err) {\n            throw mapSource(err, this.sourceMaps);\n        }\n    }\n\n    /**\n     * Executes arbitrary code in a VM sandbox.\n     *\n     * @param code       JavaScript code to be executed in the VM\n     * @param sandbox    a VM context to use for running the code\n     * @param sourceMaps source maps to be used in case an exception is thrown\n     * @param filename   the file name to use for the executed code\n     *\n     * @returns the result of evaluating the code\n     */\n    private _execute(code: string, filename: string) {\n        const script = new vm.Script(code, { filename });\n        try {\n            return script.runInContext(this.sandbox, { displayErrors: true });\n        } catch (err) {\n            throw mapSource(err, this.sourceMaps);\n        }\n    }\n}\n\ninterface Callback {\n    objref: api.ObjRef;\n    override: api.MethodOverride;\n    args: any[];\n    expectedReturnType: wire.OptionalValueOrVoid;\n\n    // completion callbacks\n    succeed: (...args: any[]) => any;\n    fail: (...args: any[]) => any;\n}\n\ninterface AsyncInvocation {\n    method: spec.Method\n    promise: Promise<any>\n}\n\nclass Assembly {\n    constructor(public readonly metadata: spec.Assembly,\n                public readonly closure: any) {\n    }\n}\n\n/**\n * Applies source maps to an error's stack trace and returns the mapped error,\n * and stitches stack trace elements to adapt the context to the current trace.\n *\n * @param err        is the error to be mapped\n * @param sourceMaps the source maps to be used\n *\n * @returns the mapped error\n */\nfunction mapSource(err: Error, sourceMaps: { [assm: string]: SourceMapConsumer }): Error {\n    if (!err.stack) { return err; }\n    const oldFrames = err.stack.split(\"\\n\");\n    const obj = { stack: '' };\n    const previousLimit = Error.stackTraceLimit;\n    try {\n        Error.stackTraceLimit = err.stack.split(\"\\n\").length;\n        Error.captureStackTrace(obj, mapSource);\n        const realFrames = obj.stack.split('\\n').slice(1);\n        const topFrame = realFrames[0].substring(0, realFrames[0].indexOf(' ('));\n        err.stack = [\n            ...oldFrames.slice(0, oldFrames.findIndex(frame => frame.startsWith(topFrame))).map(applyMaps),\n            ...realFrames\n        ].join(\"\\n\");\n        return err;\n    } finally {\n        Error.stackTraceLimit = previousLimit;\n    }\n\n    function applyMaps(frame: string): string {\n        const mappable = /^(\\s*at\\s+.+)\\(jsii\\/(.+)\\.js:(\\d+):(\\d+)\\)$/;\n        const matches = mappable.exec(frame);\n        if (!matches) { return frame; }\n        const assm = matches[2];\n        if (!(assm in sourceMaps)) { return frame; }\n        const prefix = matches[1];\n        const line = parseInt(matches[3], 10);\n        const column = parseInt(matches[4], 10);\n        const sourceMap = sourceMaps[assm];\n        const pos = sourceMap.originalPositionFor({ line, column });\n        if (pos.source != null && pos.line != null) {\n            const source = pos.source.replace(/^webpack:\\/\\//, `${assm}`);\n            return `${prefix}(${source}:${pos.line}:${pos.column || 0})`;\n        }\n        return frame;\n    }\n}\n","module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","'use strict'\n\nmodule.exports = Object.assign(\n  {},\n  // Export promiseified graceful-fs:\n  require('./fs'),\n  // Export extra methods:\n  require('./copy-sync'),\n  require('./copy'),\n  require('./empty'),\n  require('./ensure'),\n  require('./json'),\n  require('./mkdirs'),\n  require('./move-sync'),\n  require('./move'),\n  require('./output'),\n  require('./path-exists'),\n  require('./remove')\n)\n\n// Export fs.promises as a getter property so that we don't trigger\n// ExperimentalWarning before fs.promises is actually accessed.\nconst fs = require('fs')\nif (Object.getOwnPropertyDescriptor(fs, 'promises')) {\n  Object.defineProperty(module.exports, 'promises', {\n    get () { return fs.promises }\n  })\n}\n","var constants = require('constants')\n\nvar origCwd = process.cwd\nvar cwd = null\n\nvar platform = process.env.GRACEFUL_FS_PLATFORM || process.platform\n\nprocess.cwd = function() {\n  if (!cwd)\n    cwd = origCwd.call(process)\n  return cwd\n}\ntry {\n  process.cwd()\n} catch (er) {}\n\nvar chdir = process.chdir\nprocess.chdir = function(d) {\n  cwd = null\n  chdir.call(process, d)\n}\n\nmodule.exports = patch\n\nfunction patch (fs) {\n  // (re-)implement some things that are known busted or missing.\n\n  // lchmod, broken prior to 0.6.2\n  // back-port the fix here.\n  if (constants.hasOwnProperty('O_SYMLINK') &&\n      process.version.match(/^v0\\.6\\.[0-2]|^v0\\.5\\./)) {\n    patchLchmod(fs)\n  }\n\n  // lutimes implementation, or no-op\n  if (!fs.lutimes) {\n    patchLutimes(fs)\n  }\n\n  // https://github.com/isaacs/node-graceful-fs/issues/4\n  // Chown should not fail on einval or eperm if non-root.\n  // It should not fail on enosys ever, as this just indicates\n  // that a fs doesn't support the intended operation.\n\n  fs.chown = chownFix(fs.chown)\n  fs.fchown = chownFix(fs.fchown)\n  fs.lchown = chownFix(fs.lchown)\n\n  fs.chmod = chmodFix(fs.chmod)\n  fs.fchmod = chmodFix(fs.fchmod)\n  fs.lchmod = chmodFix(fs.lchmod)\n\n  fs.chownSync = chownFixSync(fs.chownSync)\n  fs.fchownSync = chownFixSync(fs.fchownSync)\n  fs.lchownSync = chownFixSync(fs.lchownSync)\n\n  fs.chmodSync = chmodFixSync(fs.chmodSync)\n  fs.fchmodSync = chmodFixSync(fs.fchmodSync)\n  fs.lchmodSync = chmodFixSync(fs.lchmodSync)\n\n  fs.stat = statFix(fs.stat)\n  fs.fstat = statFix(fs.fstat)\n  fs.lstat = statFix(fs.lstat)\n\n  fs.statSync = statFixSync(fs.statSync)\n  fs.fstatSync = statFixSync(fs.fstatSync)\n  fs.lstatSync = statFixSync(fs.lstatSync)\n\n  // if lchmod/lchown do not exist, then make them no-ops\n  if (!fs.lchmod) {\n    fs.lchmod = function (path, mode, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchmodSync = function () {}\n  }\n  if (!fs.lchown) {\n    fs.lchown = function (path, uid, gid, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchownSync = function () {}\n  }\n\n  // on Windows, A/V software can lock the directory, causing this\n  // to fail with an EACCES or EPERM if the directory contains newly\n  // created files.  Try again on failure, for up to 60 seconds.\n\n  // Set the timeout this long because some Windows Anti-Virus, such as Parity\n  // bit9, may lock files for up to a minute, causing npm package install\n  // failures. Also, take care to yield the scheduler. Windows scheduling gives\n  // CPU to a busy looping process, which can cause the program causing the lock\n  // contention to be starved of CPU by node, so the contention doesn't resolve.\n  if (platform === \"win32\") {\n    fs.rename = (function (fs$rename) { return function (from, to, cb) {\n      var start = Date.now()\n      var backoff = 0;\n      fs$rename(from, to, function CB (er) {\n        if (er\n            && (er.code === \"EACCES\" || er.code === \"EPERM\")\n            && Date.now() - start < 60000) {\n          setTimeout(function() {\n            fs.stat(to, function (stater, st) {\n              if (stater && stater.code === \"ENOENT\")\n                fs$rename(from, to, CB);\n              else\n                cb(er)\n            })\n          }, backoff)\n          if (backoff < 100)\n            backoff += 10;\n          return;\n        }\n        if (cb) cb(er)\n      })\n    }})(fs.rename)\n  }\n\n  // if read() returns EAGAIN, then just try it again.\n  fs.read = (function (fs$read) { return function (fd, buffer, offset, length, position, callback_) {\n    var callback\n    if (callback_ && typeof callback_ === 'function') {\n      var eagCounter = 0\n      callback = function (er, _, __) {\n        if (er && er.code === 'EAGAIN' && eagCounter < 10) {\n          eagCounter ++\n          return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n        }\n        callback_.apply(this, arguments)\n      }\n    }\n    return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n  }})(fs.read)\n\n  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {\n    var eagCounter = 0\n    while (true) {\n      try {\n        return fs$readSync.call(fs, fd, buffer, offset, length, position)\n      } catch (er) {\n        if (er.code === 'EAGAIN' && eagCounter < 10) {\n          eagCounter ++\n          continue\n        }\n        throw er\n      }\n    }\n  }})(fs.readSync)\n\n  function patchLchmod (fs) {\n    fs.lchmod = function (path, mode, callback) {\n      fs.open( path\n             , constants.O_WRONLY | constants.O_SYMLINK\n             , mode\n             , function (err, fd) {\n        if (err) {\n          if (callback) callback(err)\n          return\n        }\n        // prefer to return the chmod error, if one occurs,\n        // but still try to close, and report closing errors if they occur.\n        fs.fchmod(fd, mode, function (err) {\n          fs.close(fd, function(err2) {\n            if (callback) callback(err || err2)\n          })\n        })\n      })\n    }\n\n    fs.lchmodSync = function (path, mode) {\n      var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)\n\n      // prefer to return the chmod error, if one occurs,\n      // but still try to close, and report closing errors if they occur.\n      var threw = true\n      var ret\n      try {\n        ret = fs.fchmodSync(fd, mode)\n        threw = false\n      } finally {\n        if (threw) {\n          try {\n            fs.closeSync(fd)\n          } catch (er) {}\n        } else {\n          fs.closeSync(fd)\n        }\n      }\n      return ret\n    }\n  }\n\n  function patchLutimes (fs) {\n    if (constants.hasOwnProperty(\"O_SYMLINK\")) {\n      fs.lutimes = function (path, at, mt, cb) {\n        fs.open(path, constants.O_SYMLINK, function (er, fd) {\n          if (er) {\n            if (cb) cb(er)\n            return\n          }\n          fs.futimes(fd, at, mt, function (er) {\n            fs.close(fd, function (er2) {\n              if (cb) cb(er || er2)\n            })\n          })\n        })\n      }\n\n      fs.lutimesSync = function (path, at, mt) {\n        var fd = fs.openSync(path, constants.O_SYMLINK)\n        var ret\n        var threw = true\n        try {\n          ret = fs.futimesSync(fd, at, mt)\n          threw = false\n        } finally {\n          if (threw) {\n            try {\n              fs.closeSync(fd)\n            } catch (er) {}\n          } else {\n            fs.closeSync(fd)\n          }\n        }\n        return ret\n      }\n\n    } else {\n      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }\n      fs.lutimesSync = function () {}\n    }\n  }\n\n  function chmodFix (orig) {\n    if (!orig) return orig\n    return function (target, mode, cb) {\n      return orig.call(fs, target, mode, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chmodFixSync (orig) {\n    if (!orig) return orig\n    return function (target, mode) {\n      try {\n        return orig.call(fs, target, mode)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n\n  function chownFix (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid, cb) {\n      return orig.call(fs, target, uid, gid, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chownFixSync (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid) {\n      try {\n        return orig.call(fs, target, uid, gid)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n  function statFix (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target, options, cb) {\n      if (typeof options === 'function') {\n        cb = options\n        options = null\n      }\n      function callback (er, stats) {\n        if (stats) {\n          if (stats.uid < 0) stats.uid += 0x100000000\n          if (stats.gid < 0) stats.gid += 0x100000000\n        }\n        if (cb) cb.apply(this, arguments)\n      }\n      return options ? orig.call(fs, target, options, callback)\n        : orig.call(fs, target, callback)\n    }\n  }\n\n  function statFixSync (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target, options) {\n      var stats = options ? orig.call(fs, target, options)\n        : orig.call(fs, target)\n      if (stats.uid < 0) stats.uid += 0x100000000\n      if (stats.gid < 0) stats.gid += 0x100000000\n      return stats;\n    }\n  }\n\n  // ENOSYS means that the fs doesn't support the op. Just ignore\n  // that, because it doesn't matter.\n  //\n  // if there's no getuid, or if getuid() is something other\n  // than 0, and the error is EINVAL or EPERM, then just ignore\n  // it.\n  //\n  // This specific case is a silent failure in cp, install, tar,\n  // and most other unix tools that manage permissions.\n  //\n  // When running as root, or if other types of errors are\n  // encountered, then it's strict.\n  function chownErOk (er) {\n    if (!er)\n      return true\n\n    if (er.code === \"ENOSYS\")\n      return true\n\n    var nonroot = !process.getuid || process.getuid() !== 0\n    if (nonroot) {\n      if (er.code === \"EINVAL\" || er.code === \"EPERM\")\n        return true\n    }\n\n    return false\n  }\n}\n","module.exports = require(\"constants\");","var Stream = require('stream').Stream\n\nmodule.exports = legacy\n\nfunction legacy (fs) {\n  return {\n    ReadStream: ReadStream,\n    WriteStream: WriteStream\n  }\n\n  function ReadStream (path, options) {\n    if (!(this instanceof ReadStream)) return new ReadStream(path, options);\n\n    Stream.call(this);\n\n    var self = this;\n\n    this.path = path;\n    this.fd = null;\n    this.readable = true;\n    this.paused = false;\n\n    this.flags = 'r';\n    this.mode = 438; /*=0666*/\n    this.bufferSize = 64 * 1024;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.encoding) this.setEncoding(this.encoding);\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.end === undefined) {\n        this.end = Infinity;\n      } else if ('number' !== typeof this.end) {\n        throw TypeError('end must be a Number');\n      }\n\n      if (this.start > this.end) {\n        throw new Error('start must be <= end');\n      }\n\n      this.pos = this.start;\n    }\n\n    if (this.fd !== null) {\n      process.nextTick(function() {\n        self._read();\n      });\n      return;\n    }\n\n    fs.open(this.path, this.flags, this.mode, function (err, fd) {\n      if (err) {\n        self.emit('error', err);\n        self.readable = false;\n        return;\n      }\n\n      self.fd = fd;\n      self.emit('open', fd);\n      self._read();\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (!(this instanceof WriteStream)) return new WriteStream(path, options);\n\n    Stream.call(this);\n\n    this.path = path;\n    this.fd = null;\n    this.writable = true;\n\n    this.flags = 'w';\n    this.encoding = 'binary';\n    this.mode = 438; /*=0666*/\n    this.bytesWritten = 0;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.start < 0) {\n        throw new Error('start must be >= zero');\n      }\n\n      this.pos = this.start;\n    }\n\n    this.busy = false;\n    this._queue = [];\n\n    if (this.fd === null) {\n      this._open = fs.open;\n      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);\n      this.flush();\n    }\n  }\n}\n","module.exports = require(\"stream\");","'use strict'\n\nmodule.exports = clone\n\nfunction clone (obj) {\n  if (obj === null || typeof obj !== 'object')\n    return obj\n\n  if (obj instanceof Object)\n    var copy = { __proto__: obj.__proto__ }\n  else\n    var copy = Object.create(null)\n\n  Object.getOwnPropertyNames(obj).forEach(function (key) {\n    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))\n  })\n\n  return copy\n}\n","module.exports = require(\"util\");","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdirpSync = require('../mkdirs').mkdirsSync\nconst utimesSync = require('../util/utimes.js').utimesMillisSync\nconst stat = require('../util/stat')\n\nfunction copySync (src, dest, opts) {\n  if (typeof opts === 'function') {\n    opts = { filter: opts }\n  }\n\n  opts = opts || {}\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269`)\n  }\n\n  const { srcStat, destStat } = stat.checkPathsSync(src, dest, 'copy')\n  stat.checkParentPathsSync(src, srcStat, dest, 'copy')\n  return handleFilterAndCopy(destStat, src, dest, opts)\n}\n\nfunction handleFilterAndCopy (destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return\n  const destParent = path.dirname(dest)\n  if (!fs.existsSync(destParent)) mkdirpSync(destParent)\n  return startCopy(destStat, src, dest, opts)\n}\n\nfunction startCopy (destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return\n  return getStats(destStat, src, dest, opts)\n}\n\nfunction getStats (destStat, src, dest, opts) {\n  const statSync = opts.dereference ? fs.statSync : fs.lstatSync\n  const srcStat = statSync(src)\n\n  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isFile() ||\n           srcStat.isCharacterDevice() ||\n           srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts)\n  return mayCopyFile(srcStat, src, dest, opts)\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts) {\n  if (opts.overwrite) {\n    fs.unlinkSync(dest)\n    return copyFile(srcStat, src, dest, opts)\n  } else if (opts.errorOnExist) {\n    throw new Error(`'${dest}' already exists`)\n  }\n}\n\nfunction copyFile (srcStat, src, dest, opts) {\n  if (typeof fs.copyFileSync === 'function') {\n    fs.copyFileSync(src, dest)\n    fs.chmodSync(dest, srcStat.mode)\n    if (opts.preserveTimestamps) {\n      return utimesSync(dest, srcStat.atime, srcStat.mtime)\n    }\n    return\n  }\n  return copyFileFallback(srcStat, src, dest, opts)\n}\n\nfunction copyFileFallback (srcStat, src, dest, opts) {\n  const BUF_LENGTH = 64 * 1024\n  const _buff = require('../util/buffer')(BUF_LENGTH)\n\n  const fdr = fs.openSync(src, 'r')\n  const fdw = fs.openSync(dest, 'w', srcStat.mode)\n  let pos = 0\n\n  while (pos < srcStat.size) {\n    const bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos)\n    fs.writeSync(fdw, _buff, 0, bytesRead)\n    pos += bytesRead\n  }\n\n  if (opts.preserveTimestamps) fs.futimesSync(fdw, srcStat.atime, srcStat.mtime)\n\n  fs.closeSync(fdr)\n  fs.closeSync(fdw)\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return mkDirAndCopy(srcStat, src, dest, opts)\n  if (destStat && !destStat.isDirectory()) {\n    throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)\n  }\n  return copyDir(src, dest, opts)\n}\n\nfunction mkDirAndCopy (srcStat, src, dest, opts) {\n  fs.mkdirSync(dest)\n  copyDir(src, dest, opts)\n  return fs.chmodSync(dest, srcStat.mode)\n}\n\nfunction copyDir (src, dest, opts) {\n  fs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts))\n}\n\nfunction copyDirItem (item, src, dest, opts) {\n  const srcItem = path.join(src, item)\n  const destItem = path.join(dest, item)\n  const { destStat } = stat.checkPathsSync(srcItem, destItem, 'copy')\n  return startCopy(destStat, srcItem, destItem, opts)\n}\n\nfunction onLink (destStat, src, dest, opts) {\n  let resolvedSrc = fs.readlinkSync(src)\n  if (opts.dereference) {\n    resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n  }\n\n  if (!destStat) {\n    return fs.symlinkSync(resolvedSrc, dest)\n  } else {\n    let resolvedDest\n    try {\n      resolvedDest = fs.readlinkSync(dest)\n    } catch (err) {\n      // dest exists and is a regular file or directory,\n      // Windows may throw UNKNOWN error. If dest already exists,\n      // fs throws error anyway, so no need to guard against it here.\n      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest)\n      throw err\n    }\n    if (opts.dereference) {\n      resolvedDest = path.resolve(process.cwd(), resolvedDest)\n    }\n    if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)\n    }\n\n    // prevent copy if src is a subdir of dest since unlinking\n    // dest in this case would result in removing src contents\n    // and therefore a broken symlink would be created.\n    if (fs.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)\n    }\n    return copyLink(resolvedSrc, dest)\n  }\n}\n\nfunction copyLink (resolvedSrc, dest) {\n  fs.unlinkSync(dest)\n  return fs.symlinkSync(resolvedSrc, dest)\n}\n\nmodule.exports = copySync\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst invalidWin32Path = require('./win32').invalidWin32Path\n\nconst o777 = parseInt('0777', 8)\n\nfunction mkdirs (p, opts, callback, made) {\n  if (typeof opts === 'function') {\n    callback = opts\n    opts = {}\n  } else if (!opts || typeof opts !== 'object') {\n    opts = { mode: opts }\n  }\n\n  if (process.platform === 'win32' && invalidWin32Path(p)) {\n    const errInval = new Error(p + ' contains invalid WIN32 path characters.')\n    errInval.code = 'EINVAL'\n    return callback(errInval)\n  }\n\n  let mode = opts.mode\n  const xfs = opts.fs || fs\n\n  if (mode === undefined) {\n    mode = o777 & (~process.umask())\n  }\n  if (!made) made = null\n\n  callback = callback || function () {}\n  p = path.resolve(p)\n\n  xfs.mkdir(p, mode, er => {\n    if (!er) {\n      made = made || p\n      return callback(null, made)\n    }\n    switch (er.code) {\n      case 'ENOENT':\n        if (path.dirname(p) === p) return callback(er)\n        mkdirs(path.dirname(p), opts, (er, made) => {\n          if (er) callback(er, made)\n          else mkdirs(p, opts, callback, made)\n        })\n        break\n\n      // In the case of any other error, just see if there's a dir\n      // there already.  If so, then hooray!  If not, then something\n      // is borked.\n      default:\n        xfs.stat(p, (er2, stat) => {\n          // if the stat fails, then that's super weird.\n          // let the original error be the failure reason.\n          if (er2 || !stat.isDirectory()) callback(er, made)\n          else callback(null, made)\n        })\n        break\n    }\n  })\n}\n\nmodule.exports = mkdirs\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst invalidWin32Path = require('./win32').invalidWin32Path\n\nconst o777 = parseInt('0777', 8)\n\nfunction mkdirsSync (p, opts, made) {\n  if (!opts || typeof opts !== 'object') {\n    opts = { mode: opts }\n  }\n\n  let mode = opts.mode\n  const xfs = opts.fs || fs\n\n  if (process.platform === 'win32' && invalidWin32Path(p)) {\n    const errInval = new Error(p + ' contains invalid WIN32 path characters.')\n    errInval.code = 'EINVAL'\n    throw errInval\n  }\n\n  if (mode === undefined) {\n    mode = o777 & (~process.umask())\n  }\n  if (!made) made = null\n\n  p = path.resolve(p)\n\n  try {\n    xfs.mkdirSync(p, mode)\n    made = made || p\n  } catch (err0) {\n    if (err0.code === 'ENOENT') {\n      if (path.dirname(p) === p) throw err0\n      made = mkdirsSync(path.dirname(p), opts, made)\n      mkdirsSync(p, opts, made)\n    } else {\n      // In the case of any other error, just see if there's a dir there\n      // already. If so, then hooray!  If not, then something is borked.\n      let stat\n      try {\n        stat = xfs.statSync(p)\n      } catch (err1) {\n        throw err0\n      }\n      if (!stat.isDirectory()) throw err0\n    }\n  }\n\n  return made\n}\n\nmodule.exports = mkdirsSync\n","'use strict'\n/* eslint-disable node/no-deprecated-api */\nmodule.exports = function (size) {\n  if (typeof Buffer.allocUnsafe === 'function') {\n    try {\n      return Buffer.allocUnsafe(size)\n    } catch (e) {\n      return new Buffer(size)\n    }\n  }\n  return new Buffer(size)\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdirp = require('../mkdirs').mkdirs\nconst pathExists = require('../path-exists').pathExists\nconst utimes = require('../util/utimes').utimesMillis\nconst stat = require('../util/stat')\n\nfunction copy (src, dest, opts, cb) {\n  if (typeof opts === 'function' && !cb) {\n    cb = opts\n    opts = {}\n  } else if (typeof opts === 'function') {\n    opts = { filter: opts }\n  }\n\n  cb = cb || function () {}\n  opts = opts || {}\n\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269`)\n  }\n\n  stat.checkPaths(src, dest, 'copy', (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat, destStat } = stats\n    stat.checkParentPaths(src, srcStat, dest, 'copy', err => {\n      if (err) return cb(err)\n      if (opts.filter) return handleFilter(checkParentDir, destStat, src, dest, opts, cb)\n      return checkParentDir(destStat, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction checkParentDir (destStat, src, dest, opts, cb) {\n  const destParent = path.dirname(dest)\n  pathExists(destParent, (err, dirExists) => {\n    if (err) return cb(err)\n    if (dirExists) return startCopy(destStat, src, dest, opts, cb)\n    mkdirp(destParent, err => {\n      if (err) return cb(err)\n      return startCopy(destStat, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction handleFilter (onInclude, destStat, src, dest, opts, cb) {\n  Promise.resolve(opts.filter(src, dest)).then(include => {\n    if (include) return onInclude(destStat, src, dest, opts, cb)\n    return cb()\n  }, error => cb(error))\n}\n\nfunction startCopy (destStat, src, dest, opts, cb) {\n  if (opts.filter) return handleFilter(getStats, destStat, src, dest, opts, cb)\n  return getStats(destStat, src, dest, opts, cb)\n}\n\nfunction getStats (destStat, src, dest, opts, cb) {\n  const stat = opts.dereference ? fs.stat : fs.lstat\n  stat(src, (err, srcStat) => {\n    if (err) return cb(err)\n\n    if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb)\n    else if (srcStat.isFile() ||\n             srcStat.isCharacterDevice() ||\n             srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts, cb)\n    else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb)\n  })\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts, cb) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts, cb)\n  return mayCopyFile(srcStat, src, dest, opts, cb)\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts, cb) {\n  if (opts.overwrite) {\n    fs.unlink(dest, err => {\n      if (err) return cb(err)\n      return copyFile(srcStat, src, dest, opts, cb)\n    })\n  } else if (opts.errorOnExist) {\n    return cb(new Error(`'${dest}' already exists`))\n  } else return cb()\n}\n\nfunction copyFile (srcStat, src, dest, opts, cb) {\n  if (typeof fs.copyFile === 'function') {\n    return fs.copyFile(src, dest, err => {\n      if (err) return cb(err)\n      return setDestModeAndTimestamps(srcStat, dest, opts, cb)\n    })\n  }\n  return copyFileFallback(srcStat, src, dest, opts, cb)\n}\n\nfunction copyFileFallback (srcStat, src, dest, opts, cb) {\n  const rs = fs.createReadStream(src)\n  rs.on('error', err => cb(err)).once('open', () => {\n    const ws = fs.createWriteStream(dest, { mode: srcStat.mode })\n    ws.on('error', err => cb(err))\n      .on('open', () => rs.pipe(ws))\n      .once('close', () => setDestModeAndTimestamps(srcStat, dest, opts, cb))\n  })\n}\n\nfunction setDestModeAndTimestamps (srcStat, dest, opts, cb) {\n  fs.chmod(dest, srcStat.mode, err => {\n    if (err) return cb(err)\n    if (opts.preserveTimestamps) {\n      return utimes(dest, srcStat.atime, srcStat.mtime, cb)\n    }\n    return cb()\n  })\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts, cb) {\n  if (!destStat) return mkDirAndCopy(srcStat, src, dest, opts, cb)\n  if (destStat && !destStat.isDirectory()) {\n    return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`))\n  }\n  return copyDir(src, dest, opts, cb)\n}\n\nfunction mkDirAndCopy (srcStat, src, dest, opts, cb) {\n  fs.mkdir(dest, err => {\n    if (err) return cb(err)\n    copyDir(src, dest, opts, err => {\n      if (err) return cb(err)\n      return fs.chmod(dest, srcStat.mode, cb)\n    })\n  })\n}\n\nfunction copyDir (src, dest, opts, cb) {\n  fs.readdir(src, (err, items) => {\n    if (err) return cb(err)\n    return copyDirItems(items, src, dest, opts, cb)\n  })\n}\n\nfunction copyDirItems (items, src, dest, opts, cb) {\n  const item = items.pop()\n  if (!item) return cb()\n  return copyDirItem(items, item, src, dest, opts, cb)\n}\n\nfunction copyDirItem (items, item, src, dest, opts, cb) {\n  const srcItem = path.join(src, item)\n  const destItem = path.join(dest, item)\n  stat.checkPaths(srcItem, destItem, 'copy', (err, stats) => {\n    if (err) return cb(err)\n    const { destStat } = stats\n    startCopy(destStat, srcItem, destItem, opts, err => {\n      if (err) return cb(err)\n      return copyDirItems(items, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction onLink (destStat, src, dest, opts, cb) {\n  fs.readlink(src, (err, resolvedSrc) => {\n    if (err) return cb(err)\n    if (opts.dereference) {\n      resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n    }\n\n    if (!destStat) {\n      return fs.symlink(resolvedSrc, dest, cb)\n    } else {\n      fs.readlink(dest, (err, resolvedDest) => {\n        if (err) {\n          // dest exists and is a regular file or directory,\n          // Windows may throw UNKNOWN error. If dest already exists,\n          // fs throws error anyway, so no need to guard against it here.\n          if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest, cb)\n          return cb(err)\n        }\n        if (opts.dereference) {\n          resolvedDest = path.resolve(process.cwd(), resolvedDest)\n        }\n        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`))\n        }\n\n        // do not copy if src is a subdir of dest since unlinking\n        // dest in this case would result in removing src contents\n        // and therefore a broken symlink would be created.\n        if (destStat.isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`))\n        }\n        return copyLink(resolvedSrc, dest, cb)\n      })\n    }\n  })\n}\n\nfunction copyLink (resolvedSrc, dest, cb) {\n  fs.unlink(dest, err => {\n    if (err) return cb(err)\n    return fs.symlink(resolvedSrc, dest, cb)\n  })\n}\n\nmodule.exports = copy\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdir = require('../mkdirs')\nconst remove = require('../remove')\n\nconst emptyDir = u(function emptyDir (dir, callback) {\n  callback = callback || function () {}\n  fs.readdir(dir, (err, items) => {\n    if (err) return mkdir.mkdirs(dir, callback)\n\n    items = items.map(item => path.join(dir, item))\n\n    deleteItem()\n\n    function deleteItem () {\n      const item = items.pop()\n      if (!item) return callback()\n      remove.remove(item, err => {\n        if (err) return callback(err)\n        deleteItem()\n      })\n    }\n  })\n})\n\nfunction emptyDirSync (dir) {\n  let items\n  try {\n    items = fs.readdirSync(dir)\n  } catch (err) {\n    return mkdir.mkdirsSync(dir)\n  }\n\n  items.forEach(item => {\n    item = path.join(dir, item)\n    remove.removeSync(item)\n  })\n}\n\nmodule.exports = {\n  emptyDirSync,\n  emptydirSync: emptyDirSync,\n  emptyDir,\n  emptydir: emptyDir\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst assert = require('assert')\n\nconst isWindows = (process.platform === 'win32')\n\nfunction defaults (options) {\n  const methods = [\n    'unlink',\n    'chmod',\n    'stat',\n    'lstat',\n    'rmdir',\n    'readdir'\n  ]\n  methods.forEach(m => {\n    options[m] = options[m] || fs[m]\n    m = m + 'Sync'\n    options[m] = options[m] || fs[m]\n  })\n\n  options.maxBusyTries = options.maxBusyTries || 3\n}\n\nfunction rimraf (p, options, cb) {\n  let busyTries = 0\n\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  assert(p, 'rimraf: missing path')\n  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')\n  assert.strictEqual(typeof cb, 'function', 'rimraf: callback function required')\n  assert(options, 'rimraf: invalid options argument provided')\n  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')\n\n  defaults(options)\n\n  rimraf_(p, options, function CB (er) {\n    if (er) {\n      if ((er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') &&\n          busyTries < options.maxBusyTries) {\n        busyTries++\n        const time = busyTries * 100\n        // try again, with the same exact callback as this one.\n        return setTimeout(() => rimraf_(p, options, CB), time)\n      }\n\n      // already gone\n      if (er.code === 'ENOENT') er = null\n    }\n\n    cb(er)\n  })\n}\n\n// Two possible strategies.\n// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR\n// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR\n//\n// Both result in an extra syscall when you guess wrong.  However, there\n// are likely far more normal files in the world than directories.  This\n// is based on the assumption that a the average number of files per\n// directory is >= 1.\n//\n// If anyone ever complains about this, then I guess the strategy could\n// be made configurable somehow.  But until then, YAGNI.\nfunction rimraf_ (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  // sunos lets the root user unlink directories, which is... weird.\n  // so we have to lstat here and make sure it's not a dir.\n  options.lstat(p, (er, st) => {\n    if (er && er.code === 'ENOENT') {\n      return cb(null)\n    }\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er && er.code === 'EPERM' && isWindows) {\n      return fixWinEPERM(p, options, er, cb)\n    }\n\n    if (st && st.isDirectory()) {\n      return rmdir(p, options, er, cb)\n    }\n\n    options.unlink(p, er => {\n      if (er) {\n        if (er.code === 'ENOENT') {\n          return cb(null)\n        }\n        if (er.code === 'EPERM') {\n          return (isWindows)\n            ? fixWinEPERM(p, options, er, cb)\n            : rmdir(p, options, er, cb)\n        }\n        if (er.code === 'EISDIR') {\n          return rmdir(p, options, er, cb)\n        }\n      }\n      return cb(er)\n    })\n  })\n}\n\nfunction fixWinEPERM (p, options, er, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n  if (er) {\n    assert(er instanceof Error)\n  }\n\n  options.chmod(p, 0o666, er2 => {\n    if (er2) {\n      cb(er2.code === 'ENOENT' ? null : er)\n    } else {\n      options.stat(p, (er3, stats) => {\n        if (er3) {\n          cb(er3.code === 'ENOENT' ? null : er)\n        } else if (stats.isDirectory()) {\n          rmdir(p, options, er, cb)\n        } else {\n          options.unlink(p, cb)\n        }\n      })\n    }\n  })\n}\n\nfunction fixWinEPERMSync (p, options, er) {\n  let stats\n\n  assert(p)\n  assert(options)\n  if (er) {\n    assert(er instanceof Error)\n  }\n\n  try {\n    options.chmodSync(p, 0o666)\n  } catch (er2) {\n    if (er2.code === 'ENOENT') {\n      return\n    } else {\n      throw er\n    }\n  }\n\n  try {\n    stats = options.statSync(p)\n  } catch (er3) {\n    if (er3.code === 'ENOENT') {\n      return\n    } else {\n      throw er\n    }\n  }\n\n  if (stats.isDirectory()) {\n    rmdirSync(p, options, er)\n  } else {\n    options.unlinkSync(p)\n  }\n}\n\nfunction rmdir (p, options, originalEr, cb) {\n  assert(p)\n  assert(options)\n  if (originalEr) {\n    assert(originalEr instanceof Error)\n  }\n  assert(typeof cb === 'function')\n\n  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)\n  // if we guessed wrong, and it's not a directory, then\n  // raise the original error.\n  options.rmdir(p, er => {\n    if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {\n      rmkids(p, options, cb)\n    } else if (er && er.code === 'ENOTDIR') {\n      cb(originalEr)\n    } else {\n      cb(er)\n    }\n  })\n}\n\nfunction rmkids (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  options.readdir(p, (er, files) => {\n    if (er) return cb(er)\n\n    let n = files.length\n    let errState\n\n    if (n === 0) return options.rmdir(p, cb)\n\n    files.forEach(f => {\n      rimraf(path.join(p, f), options, er => {\n        if (errState) {\n          return\n        }\n        if (er) return cb(errState = er)\n        if (--n === 0) {\n          options.rmdir(p, cb)\n        }\n      })\n    })\n  })\n}\n\n// this looks simpler, and is strictly *faster*, but will\n// tie up the JavaScript thread and fail on excessively\n// deep directory trees.\nfunction rimrafSync (p, options) {\n  let st\n\n  options = options || {}\n  defaults(options)\n\n  assert(p, 'rimraf: missing path')\n  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')\n  assert(options, 'rimraf: missing options')\n  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')\n\n  try {\n    st = options.lstatSync(p)\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      return\n    }\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er.code === 'EPERM' && isWindows) {\n      fixWinEPERMSync(p, options, er)\n    }\n  }\n\n  try {\n    // sunos lets the root user unlink directories, which is... weird.\n    if (st && st.isDirectory()) {\n      rmdirSync(p, options, null)\n    } else {\n      options.unlinkSync(p)\n    }\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      return\n    } else if (er.code === 'EPERM') {\n      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)\n    } else if (er.code !== 'EISDIR') {\n      throw er\n    }\n    rmdirSync(p, options, er)\n  }\n}\n\nfunction rmdirSync (p, options, originalEr) {\n  assert(p)\n  assert(options)\n  if (originalEr) {\n    assert(originalEr instanceof Error)\n  }\n\n  try {\n    options.rmdirSync(p)\n  } catch (er) {\n    if (er.code === 'ENOTDIR') {\n      throw originalEr\n    } else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {\n      rmkidsSync(p, options)\n    } else if (er.code !== 'ENOENT') {\n      throw er\n    }\n  }\n}\n\nfunction rmkidsSync (p, options) {\n  assert(p)\n  assert(options)\n  options.readdirSync(p).forEach(f => rimrafSync(path.join(p, f), options))\n\n  if (isWindows) {\n    // We only end up here once we got ENOTEMPTY at least once, and\n    // at this point, we are guaranteed to have removed all the kids.\n    // So, we know that it won't be ENOENT or ENOTDIR or anything else.\n    // try really hard to delete stuff on windows, because it has a\n    // PROFOUNDLY annoying habit of not closing handles promptly when\n    // files are deleted, resulting in spurious ENOTEMPTY errors.\n    const startTime = Date.now()\n    do {\n      try {\n        const ret = options.rmdirSync(p, options)\n        return ret\n      } catch (er) { }\n    } while (Date.now() - startTime < 500) // give up after 500ms\n  } else {\n    const ret = options.rmdirSync(p, options)\n    return ret\n  }\n}\n\nmodule.exports = rimraf\nrimraf.sync = rimrafSync\n","'use strict'\n\nconst file = require('./file')\nconst link = require('./link')\nconst symlink = require('./symlink')\n\nmodule.exports = {\n  // file\n  createFile: file.createFile,\n  createFileSync: file.createFileSync,\n  ensureFile: file.createFile,\n  ensureFileSync: file.createFileSync,\n  // link\n  createLink: link.createLink,\n  createLinkSync: link.createLinkSync,\n  ensureLink: link.createLink,\n  ensureLinkSync: link.createLinkSync,\n  // symlink\n  createSymlink: symlink.createSymlink,\n  createSymlinkSync: symlink.createSymlinkSync,\n  ensureSymlink: symlink.createSymlink,\n  ensureSymlinkSync: symlink.createSymlinkSync\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst path = require('path')\nconst fs = require('graceful-fs')\nconst mkdir = require('../mkdirs')\nconst pathExists = require('../path-exists').pathExists\n\nfunction createFile (file, callback) {\n  function makeFile () {\n    fs.writeFile(file, '', err => {\n      if (err) return callback(err)\n      callback()\n    })\n  }\n\n  fs.stat(file, (err, stats) => { // eslint-disable-line handle-callback-err\n    if (!err && stats.isFile()) return callback()\n    const dir = path.dirname(file)\n    pathExists(dir, (err, dirExists) => {\n      if (err) return callback(err)\n      if (dirExists) return makeFile()\n      mkdir.mkdirs(dir, err => {\n        if (err) return callback(err)\n        makeFile()\n      })\n    })\n  })\n}\n\nfunction createFileSync (file) {\n  let stats\n  try {\n    stats = fs.statSync(file)\n  } catch (e) {}\n  if (stats && stats.isFile()) return\n\n  const dir = path.dirname(file)\n  if (!fs.existsSync(dir)) {\n    mkdir.mkdirsSync(dir)\n  }\n\n  fs.writeFileSync(file, '')\n}\n\nmodule.exports = {\n  createFile: u(createFile),\n  createFileSync\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst path = require('path')\nconst fs = require('graceful-fs')\nconst mkdir = require('../mkdirs')\nconst pathExists = require('../path-exists').pathExists\n\nfunction createLink (srcpath, dstpath, callback) {\n  function makeLink (srcpath, dstpath) {\n    fs.link(srcpath, dstpath, err => {\n      if (err) return callback(err)\n      callback(null)\n    })\n  }\n\n  pathExists(dstpath, (err, destinationExists) => {\n    if (err) return callback(err)\n    if (destinationExists) return callback(null)\n    fs.lstat(srcpath, (err) => {\n      if (err) {\n        err.message = err.message.replace('lstat', 'ensureLink')\n        return callback(err)\n      }\n\n      const dir = path.dirname(dstpath)\n      pathExists(dir, (err, dirExists) => {\n        if (err) return callback(err)\n        if (dirExists) return makeLink(srcpath, dstpath)\n        mkdir.mkdirs(dir, err => {\n          if (err) return callback(err)\n          makeLink(srcpath, dstpath)\n        })\n      })\n    })\n  })\n}\n\nfunction createLinkSync (srcpath, dstpath) {\n  const destinationExists = fs.existsSync(dstpath)\n  if (destinationExists) return undefined\n\n  try {\n    fs.lstatSync(srcpath)\n  } catch (err) {\n    err.message = err.message.replace('lstat', 'ensureLink')\n    throw err\n  }\n\n  const dir = path.dirname(dstpath)\n  const dirExists = fs.existsSync(dir)\n  if (dirExists) return fs.linkSync(srcpath, dstpath)\n  mkdir.mkdirsSync(dir)\n\n  return fs.linkSync(srcpath, dstpath)\n}\n\nmodule.exports = {\n  createLink: u(createLink),\n  createLinkSync\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst path = require('path')\nconst fs = require('graceful-fs')\nconst _mkdirs = require('../mkdirs')\nconst mkdirs = _mkdirs.mkdirs\nconst mkdirsSync = _mkdirs.mkdirsSync\n\nconst _symlinkPaths = require('./symlink-paths')\nconst symlinkPaths = _symlinkPaths.symlinkPaths\nconst symlinkPathsSync = _symlinkPaths.symlinkPathsSync\n\nconst _symlinkType = require('./symlink-type')\nconst symlinkType = _symlinkType.symlinkType\nconst symlinkTypeSync = _symlinkType.symlinkTypeSync\n\nconst pathExists = require('../path-exists').pathExists\n\nfunction createSymlink (srcpath, dstpath, type, callback) {\n  callback = (typeof type === 'function') ? type : callback\n  type = (typeof type === 'function') ? false : type\n\n  pathExists(dstpath, (err, destinationExists) => {\n    if (err) return callback(err)\n    if (destinationExists) return callback(null)\n    symlinkPaths(srcpath, dstpath, (err, relative) => {\n      if (err) return callback(err)\n      srcpath = relative.toDst\n      symlinkType(relative.toCwd, type, (err, type) => {\n        if (err) return callback(err)\n        const dir = path.dirname(dstpath)\n        pathExists(dir, (err, dirExists) => {\n          if (err) return callback(err)\n          if (dirExists) return fs.symlink(srcpath, dstpath, type, callback)\n          mkdirs(dir, err => {\n            if (err) return callback(err)\n            fs.symlink(srcpath, dstpath, type, callback)\n          })\n        })\n      })\n    })\n  })\n}\n\nfunction createSymlinkSync (srcpath, dstpath, type) {\n  const destinationExists = fs.existsSync(dstpath)\n  if (destinationExists) return undefined\n\n  const relative = symlinkPathsSync(srcpath, dstpath)\n  srcpath = relative.toDst\n  type = symlinkTypeSync(relative.toCwd, type)\n  const dir = path.dirname(dstpath)\n  const exists = fs.existsSync(dir)\n  if (exists) return fs.symlinkSync(srcpath, dstpath, type)\n  mkdirsSync(dir)\n  return fs.symlinkSync(srcpath, dstpath, type)\n}\n\nmodule.exports = {\n  createSymlink: u(createSymlink),\n  createSymlinkSync\n}\n","'use strict'\n\nconst path = require('path')\nconst fs = require('graceful-fs')\nconst pathExists = require('../path-exists').pathExists\n\n/**\n * Function that returns two types of paths, one relative to symlink, and one\n * relative to the current working directory. Checks if path is absolute or\n * relative. If the path is relative, this function checks if the path is\n * relative to symlink or relative to current working directory. This is an\n * initiative to find a smarter `srcpath` to supply when building symlinks.\n * This allows you to determine which path to use out of one of three possible\n * types of source paths. The first is an absolute path. This is detected by\n * `path.isAbsolute()`. When an absolute path is provided, it is checked to\n * see if it exists. If it does it's used, if not an error is returned\n * (callback)/ thrown (sync). The other two options for `srcpath` are a\n * relative url. By default Node's `fs.symlink` works by creating a symlink\n * using `dstpath` and expects the `srcpath` to be relative to the newly\n * created symlink. If you provide a `srcpath` that does not exist on the file\n * system it results in a broken symlink. To minimize this, the function\n * checks to see if the 'relative to symlink' source file exists, and if it\n * does it will use it. If it does not, it checks if there's a file that\n * exists that is relative to the current working directory, if does its used.\n * This preserves the expectations of the original fs.symlink spec and adds\n * the ability to pass in `relative to current working direcotry` paths.\n */\n\nfunction symlinkPaths (srcpath, dstpath, callback) {\n  if (path.isAbsolute(srcpath)) {\n    return fs.lstat(srcpath, (err) => {\n      if (err) {\n        err.message = err.message.replace('lstat', 'ensureSymlink')\n        return callback(err)\n      }\n      return callback(null, {\n        'toCwd': srcpath,\n        'toDst': srcpath\n      })\n    })\n  } else {\n    const dstdir = path.dirname(dstpath)\n    const relativeToDst = path.join(dstdir, srcpath)\n    return pathExists(relativeToDst, (err, exists) => {\n      if (err) return callback(err)\n      if (exists) {\n        return callback(null, {\n          'toCwd': relativeToDst,\n          'toDst': srcpath\n        })\n      } else {\n        return fs.lstat(srcpath, (err) => {\n          if (err) {\n            err.message = err.message.replace('lstat', 'ensureSymlink')\n            return callback(err)\n          }\n          return callback(null, {\n            'toCwd': srcpath,\n            'toDst': path.relative(dstdir, srcpath)\n          })\n        })\n      }\n    })\n  }\n}\n\nfunction symlinkPathsSync (srcpath, dstpath) {\n  let exists\n  if (path.isAbsolute(srcpath)) {\n    exists = fs.existsSync(srcpath)\n    if (!exists) throw new Error('absolute srcpath does not exist')\n    return {\n      'toCwd': srcpath,\n      'toDst': srcpath\n    }\n  } else {\n    const dstdir = path.dirname(dstpath)\n    const relativeToDst = path.join(dstdir, srcpath)\n    exists = fs.existsSync(relativeToDst)\n    if (exists) {\n      return {\n        'toCwd': relativeToDst,\n        'toDst': srcpath\n      }\n    } else {\n      exists = fs.existsSync(srcpath)\n      if (!exists) throw new Error('relative srcpath does not exist')\n      return {\n        'toCwd': srcpath,\n        'toDst': path.relative(dstdir, srcpath)\n      }\n    }\n  }\n}\n\nmodule.exports = {\n  symlinkPaths,\n  symlinkPathsSync\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\n\nfunction symlinkType (srcpath, type, callback) {\n  callback = (typeof type === 'function') ? type : callback\n  type = (typeof type === 'function') ? false : type\n  if (type) return callback(null, type)\n  fs.lstat(srcpath, (err, stats) => {\n    if (err) return callback(null, 'file')\n    type = (stats && stats.isDirectory()) ? 'dir' : 'file'\n    callback(null, type)\n  })\n}\n\nfunction symlinkTypeSync (srcpath, type) {\n  let stats\n\n  if (type) return type\n  try {\n    stats = fs.lstatSync(srcpath)\n  } catch (e) {\n    return 'file'\n  }\n  return (stats && stats.isDirectory()) ? 'dir' : 'file'\n}\n\nmodule.exports = {\n  symlinkType,\n  symlinkTypeSync\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst jsonFile = require('./jsonfile')\n\njsonFile.outputJson = u(require('./output-json'))\njsonFile.outputJsonSync = require('./output-json-sync')\n// aliases\njsonFile.outputJSON = jsonFile.outputJson\njsonFile.outputJSONSync = jsonFile.outputJsonSync\njsonFile.writeJSON = jsonFile.writeJson\njsonFile.writeJSONSync = jsonFile.writeJsonSync\njsonFile.readJSON = jsonFile.readJson\njsonFile.readJSONSync = jsonFile.readJsonSync\n\nmodule.exports = jsonFile\n","var _fs\ntry {\n  _fs = require('graceful-fs')\n} catch (_) {\n  _fs = require('fs')\n}\n\nfunction readFile (file, options, callback) {\n  if (callback == null) {\n    callback = options\n    options = {}\n  }\n\n  if (typeof options === 'string') {\n    options = {encoding: options}\n  }\n\n  options = options || {}\n  var fs = options.fs || _fs\n\n  var shouldThrow = true\n  if ('throws' in options) {\n    shouldThrow = options.throws\n  }\n\n  fs.readFile(file, options, function (err, data) {\n    if (err) return callback(err)\n\n    data = stripBom(data)\n\n    var obj\n    try {\n      obj = JSON.parse(data, options ? options.reviver : null)\n    } catch (err2) {\n      if (shouldThrow) {\n        err2.message = file + ': ' + err2.message\n        return callback(err2)\n      } else {\n        return callback(null, null)\n      }\n    }\n\n    callback(null, obj)\n  })\n}\n\nfunction readFileSync (file, options) {\n  options = options || {}\n  if (typeof options === 'string') {\n    options = {encoding: options}\n  }\n\n  var fs = options.fs || _fs\n\n  var shouldThrow = true\n  if ('throws' in options) {\n    shouldThrow = options.throws\n  }\n\n  try {\n    var content = fs.readFileSync(file, options)\n    content = stripBom(content)\n    return JSON.parse(content, options.reviver)\n  } catch (err) {\n    if (shouldThrow) {\n      err.message = file + ': ' + err.message\n      throw err\n    } else {\n      return null\n    }\n  }\n}\n\nfunction stringify (obj, options) {\n  var spaces\n  var EOL = '\\n'\n  if (typeof options === 'object' && options !== null) {\n    if (options.spaces) {\n      spaces = options.spaces\n    }\n    if (options.EOL) {\n      EOL = options.EOL\n    }\n  }\n\n  var str = JSON.stringify(obj, options ? options.replacer : null, spaces)\n\n  return str.replace(/\\n/g, EOL) + EOL\n}\n\nfunction writeFile (file, obj, options, callback) {\n  if (callback == null) {\n    callback = options\n    options = {}\n  }\n  options = options || {}\n  var fs = options.fs || _fs\n\n  var str = ''\n  try {\n    str = stringify(obj, options)\n  } catch (err) {\n    // Need to return whether a callback was passed or not\n    if (callback) callback(err, null)\n    return\n  }\n\n  fs.writeFile(file, str, options, callback)\n}\n\nfunction writeFileSync (file, obj, options) {\n  options = options || {}\n  var fs = options.fs || _fs\n\n  var str = stringify(obj, options)\n  // not sure if fs.writeFileSync returns anything, but just in case\n  return fs.writeFileSync(file, str, options)\n}\n\nfunction stripBom (content) {\n  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified\n  if (Buffer.isBuffer(content)) content = content.toString('utf8')\n  content = content.replace(/^\\uFEFF/, '')\n  return content\n}\n\nvar jsonfile = {\n  readFile: readFile,\n  readFileSync: readFileSync,\n  writeFile: writeFile,\n  writeFileSync: writeFileSync\n}\n\nmodule.exports = jsonfile\n","'use strict'\n\nconst path = require('path')\nconst mkdir = require('../mkdirs')\nconst pathExists = require('../path-exists').pathExists\nconst jsonFile = require('./jsonfile')\n\nfunction outputJson (file, data, options, callback) {\n  if (typeof options === 'function') {\n    callback = options\n    options = {}\n  }\n\n  const dir = path.dirname(file)\n\n  pathExists(dir, (err, itDoes) => {\n    if (err) return callback(err)\n    if (itDoes) return jsonFile.writeJson(file, data, options, callback)\n\n    mkdir.mkdirs(dir, err => {\n      if (err) return callback(err)\n      jsonFile.writeJson(file, data, options, callback)\n    })\n  })\n}\n\nmodule.exports = outputJson\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdir = require('../mkdirs')\nconst jsonFile = require('./jsonfile')\n\nfunction outputJsonSync (file, data, options) {\n  const dir = path.dirname(file)\n\n  if (!fs.existsSync(dir)) {\n    mkdir.mkdirsSync(dir)\n  }\n\n  jsonFile.writeJsonSync(file, data, options)\n}\n\nmodule.exports = outputJsonSync\n","'use strict'\n\nmodule.exports = {\n  moveSync: require('./move-sync')\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst copySync = require('../copy-sync').copySync\nconst removeSync = require('../remove').removeSync\nconst mkdirpSync = require('../mkdirs').mkdirpSync\nconst stat = require('../util/stat')\n\nfunction moveSync (src, dest, opts) {\n  opts = opts || {}\n  const overwrite = opts.overwrite || opts.clobber || false\n\n  const { srcStat } = stat.checkPathsSync(src, dest, 'move')\n  stat.checkParentPathsSync(src, srcStat, dest, 'move')\n  mkdirpSync(path.dirname(dest))\n  return doRename(src, dest, overwrite)\n}\n\nfunction doRename (src, dest, overwrite) {\n  if (overwrite) {\n    removeSync(dest)\n    return rename(src, dest, overwrite)\n  }\n  if (fs.existsSync(dest)) throw new Error('dest already exists.')\n  return rename(src, dest, overwrite)\n}\n\nfunction rename (src, dest, overwrite) {\n  try {\n    fs.renameSync(src, dest)\n  } catch (err) {\n    if (err.code !== 'EXDEV') throw err\n    return moveAcrossDevice(src, dest, overwrite)\n  }\n}\n\nfunction moveAcrossDevice (src, dest, overwrite) {\n  const opts = {\n    overwrite,\n    errorOnExist: true\n  }\n  copySync(src, dest, opts)\n  return removeSync(src)\n}\n\nmodule.exports = moveSync\n","'use strict'\n\nconst u = require('universalify').fromCallback\nmodule.exports = {\n  move: u(require('./move'))\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst copy = require('../copy').copy\nconst remove = require('../remove').remove\nconst mkdirp = require('../mkdirs').mkdirp\nconst pathExists = require('../path-exists').pathExists\nconst stat = require('../util/stat')\n\nfunction move (src, dest, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  }\n\n  const overwrite = opts.overwrite || opts.clobber || false\n\n  stat.checkPaths(src, dest, 'move', (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat } = stats\n    stat.checkParentPaths(src, srcStat, dest, 'move', err => {\n      if (err) return cb(err)\n      mkdirp(path.dirname(dest), err => {\n        if (err) return cb(err)\n        return doRename(src, dest, overwrite, cb)\n      })\n    })\n  })\n}\n\nfunction doRename (src, dest, overwrite, cb) {\n  if (overwrite) {\n    return remove(dest, err => {\n      if (err) return cb(err)\n      return rename(src, dest, overwrite, cb)\n    })\n  }\n  pathExists(dest, (err, destExists) => {\n    if (err) return cb(err)\n    if (destExists) return cb(new Error('dest already exists.'))\n    return rename(src, dest, overwrite, cb)\n  })\n}\n\nfunction rename (src, dest, overwrite, cb) {\n  fs.rename(src, dest, err => {\n    if (!err) return cb()\n    if (err.code !== 'EXDEV') return cb(err)\n    return moveAcrossDevice(src, dest, overwrite, cb)\n  })\n}\n\nfunction moveAcrossDevice (src, dest, overwrite, cb) {\n  const opts = {\n    overwrite,\n    errorOnExist: true\n  }\n  copy(src, dest, opts, err => {\n    if (err) return cb(err)\n    return remove(src, cb)\n  })\n}\n\nmodule.exports = move\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdir = require('../mkdirs')\nconst pathExists = require('../path-exists').pathExists\n\nfunction outputFile (file, data, encoding, callback) {\n  if (typeof encoding === 'function') {\n    callback = encoding\n    encoding = 'utf8'\n  }\n\n  const dir = path.dirname(file)\n  pathExists(dir, (err, itDoes) => {\n    if (err) return callback(err)\n    if (itDoes) return fs.writeFile(file, data, encoding, callback)\n\n    mkdir.mkdirs(dir, err => {\n      if (err) return callback(err)\n\n      fs.writeFile(file, data, encoding, callback)\n    })\n  })\n}\n\nfunction outputFileSync (file, ...args) {\n  const dir = path.dirname(file)\n  if (fs.existsSync(dir)) {\n    return fs.writeFileSync(file, ...args)\n  }\n  mkdir.mkdirsSync(dir)\n  fs.writeFileSync(file, ...args)\n}\n\nmodule.exports = {\n  outputFile: u(outputFile),\n  outputFileSync\n}\n","export const SPEC_FILE_NAME = '.jsii';\n\n/**\n * A JSII assembly specification.\n */\nexport interface Assembly extends Documentable {\n    /**\n     * The version of the spec schema\n     */\n    schema: SchemaVersion.LATEST;\n\n    /**\n     * The name of the assembly\n     *\n     * @minLength 1\n     */\n    name: string;\n\n    /**\n     * Description of the assembly, maps to \"description\" from package.json\n     * This is required since some package managers (like Maven) require it.\n     */\n    description: string;\n\n    /**\n     * The url to the project homepage. Maps to \"homepage\" from package.json.\n     */\n    homepage: string;\n\n    /**\n     * The module repository, maps to \"repository\" from package.json\n     * This is required since some package managers (like Maven) require it.\n     */\n    repository: {\n        /**\n         * The type of the repository (``git``, ``svn``, ...)\n         */\n        type: string;\n\n        /**\n         * The URL of the repository.\n         */\n        url: string;\n\n        /**\n         * If the package is not in the root directory (for example, when part\n         * of a monorepo), you should specify the directory in which it lives.\n         *\n         * @default the root of the repository\n         */\n        directory?: string;\n    };\n\n    /**\n     * The main author of this package.\n     */\n    author: Person;\n\n    /**\n     * Additional contributors to this package.\n     *\n     * @default none\n     */\n    contributors?: Person[];\n\n    /**\n     * A fingerprint that can be used to determine if the specification has\n     * changed.\n     *\n     * @minLength 1\n     */\n    fingerprint: string;\n\n    /**\n     * The version of the assembly\n     * @minLength 1\n     */\n    version: string;\n\n    /**\n     * The version of the jsii compiler that was used to produce this Assembly.\n     * @minLength 1\n     */\n    jsiiVersion: string;\n\n    /**\n     * The SPDX name of the license this assembly is distributed on.\n     */\n    license: string;\n\n    /**\n     * A map of target name to configuration, which is used when generating\n     * packages for various languages.\n     *\n     * @default none\n     */\n    targets?: AssemblyTargets;\n\n    /**\n     * Arbitrary key-value pairs of metadata, which the maintainer chose to\n     * document with the assembly. These entries do not carry normative\n     * semantics and their interpretation is up to the assembly maintainer.\n     *\n     * @default none\n     */\n    metadata?: { [key: string]: any };\n\n    /**\n     * Direct dependencies on other assemblies (with semver), the key is the JSII\n     * assembly name.\n     *\n     * @default none\n     */\n    dependencies?: { [assembly: string]: PackageVersion };\n\n    /**\n     * Closure of all dependency assemblies, direct and transitive.\n     *\n     * @default none\n     */\n    dependencyClosure?: { [assembly: string]: PackageVersion };\n\n    /**\n     * List if bundled dependencies (these are not expected to be jsii\n     * assemblies).\n     *\n     * @default none\n     */\n    bundled?: { [module: string]: string };\n\n    /**\n     * All types in the assembly, keyed by their fully-qualified-name\n     *\n     * @default none\n     */\n    types?: { [fqn: string]: Type };\n\n    /**\n     * The top-level readme document for this assembly (if any).\n     *\n     * @default none\n     */\n    readme?: { markdown: string };\n}\n\n/**\n * Versions of the JSII Assembly Specification.\n */\nexport enum SchemaVersion {\n    LATEST = 'jsii/0.10.0'\n}\n\n/**\n * Fully Qualified Name\n */\nexport type FQN = string;\n\n/**\n * Metadata about people or organizations associated with the project that\n * resulted in the Assembly. Some of this metadata is required in order to\n * publish to certain package repositories (for example, Maven Central), but is\n * not normalized, and the meaning of fields (role, for example), is up to each\n * project maintainer.\n */\nexport interface Person {\n    /**\n     * The name of the person\n     */\n    name: string;\n\n    /**\n     * A list of roles this person has in the project, for example `maintainer`,\n     * `contributor`, `owner`, ...\n     */\n    roles: string[];\n\n    /**\n     * The email of the person\n     *\n     * @default none\n     */\n    email?: string;\n\n    /**\n     * The URL for the person\n     *\n     * @default none\n     */\n    url?: string;\n\n    /**\n     * If true, this person is, in fact, an organization\n     *\n     * @default false\n     */\n    organization?: boolean;\n}\n\n/**\n * Configurable targets for an asembly.\n */\nexport interface AssemblyTargets {\n    /**\n     * Information about a particular language's targets\n     */\n    [language: string]: { [key: string]: any } | undefined;\n}\n\n/**\n * The version of a package.\n */\nexport interface PackageVersion {\n    /**\n     * Version of the package.\n     *\n     * @minLength 1\n     */\n    version: string;\n\n    /**\n     * Targets for a given assembly.\n     *\n     * @default none\n     */\n    targets?: AssemblyTargets;\n}\n\n/**\n * Where in the module source the definition for this API item was found\n */\nexport interface SourceLocation {\n    /**\n     * Relative filename\n     */\n    filename: string;\n\n    /**\n     * 1-based line number in the indicated file\n     */\n    line: number;\n}\n\n/**\n * Key value pairs of documentation nodes.\n * Based on TSDoc.\n */\nexport interface Docs {\n    /**\n     * Summary documentation for an API item.\n     *\n     * The first part of the documentation before hitting a `@remarks` tags, or\n     * the first line of the doc comment block if there is no `@remarks` tag.\n     *\n     * @default none\n     */\n    summary?: string;\n\n    /**\n     * Detailed information about an API item.\n     *\n     * Either the explicitly tagged `@remarks` section, otherwise everything\n     * past the first paragraph if there is no `@remarks` tag.\n     *\n     * @default none\n     */\n    remarks?: string;\n\n    /**\n     * If present, this block indicates that an API item is no longer supported\n     * and may be removed in a future release.  The `@deprecated` tag must be\n     * followed by a sentence describing the recommended alternative.\n     * Deprecation recursively applies to members of a container. For example,\n     * if a class is deprecated, then so are all of its members.\n     *\n     * @default none\n     */\n    deprecated?: string;\n\n    /**\n     * The `@returns` block for this doc comment, or undefined if there is not\n     * one.\n     *\n     * @default none\n     */\n    returns?: string;\n\n    /**\n     * Whether the API item is beta/experimental quality\n     */\n    stability?: Stability;\n\n    /**\n     * Example showing the usage of this API item\n     *\n     * Starts off in running text mode, may switch to code using fenced code\n     * blocks.\n     *\n     * @default none\n     */\n    example?: string;\n\n    /**\n     * A `@see` link with more information\n     *\n     * @default none\n     */\n    see?: string;\n\n    /**\n     * Whether this class or interface was intended to be subclassed/implemented\n     * by library users.\n     *\n     * Classes intended for subclassing, and interfaces intended to be\n     * implemented by consumers, are held to stricter standards of API\n     * compatibility.\n     *\n     * @default false\n     */\n    subclassable?: boolean;\n\n    /**\n     * Description of the default\n     *\n     * @default none\n     */\n    default?: string;\n\n    /**\n     * Custom tags that are not any of the default ones\n     *\n     * @default none\n     */\n    custom?: {[tag: string]: string};\n}\n\n/**\n * API Stability levels. These are modeled after the `node` stability index.\n *\n * @see https://nodejs.org/api/documentation.html#documentation_stability_index.\n */\nexport enum Stability {\n    /**\n     * The API may emit warnings. Backward compatibility is not guaranteed.\n     *\n     * More information about the deprecation can usually be found in the\n     * `deprecated` field.\n     */\n    Deprecated = 'deprecated',\n\n    /**\n     * This API is still under active development and subject to non-backward\n     * compatible changes or removal in any future version. Use of the API is\n     * not recommended in production environments. Experimental APIs are not\n     * subject to the Semantic Versioning model.\n     */\n    Experimental = 'experimental',\n\n    /**\n     * This API is subject to the Semantic Versioning model and may not change\n     * in breaking ways in a subsequent minor or patch version.\n     */\n    Stable = 'stable',\n\n    /**\n     * This API is an representation of an API managed elsewhere and follows\n     * the other API's versioning model.\n     */\n    External = 'external',\n}\n\n/**\n * Indicates that an entity is documentable.\n */\nexport interface Documentable {\n    /**\n     * Documentation for this entity.\n     *\n     * @default none\n     */\n    docs?: Docs;\n}\n\n/**\n * Indicates that an entity has a source location\n */\nexport interface SourceLocatable {\n    /**\n     * Where in the module this definition was found\n     *\n     * Why is this not `locationInAssembly`? Because the assembly is the JSII\n     * file combining compiled code and its manifest, whereas this is referring\n     * to the location of the source in the module the assembly was built from.\n     *\n     * @default none\n     */\n    locationInModule?: SourceLocation;\n}\n\n/**\n * Kinds of collections.\n */\nexport enum CollectionKind {\n    /**\n     * An array, or a list of some element type.\n     */\n    Array = 'array',\n    /**\n     * A map of a string to some element type.\n     */\n    Map = 'map',\n}\n\n/**\n * Kinds of primitive types.\n */\nexport enum PrimitiveType {\n    /**\n     * A JSON date (represented as it's ISO-8601 string form).\n     */\n    Date = 'date',\n\n    /**\n     * A plain string.\n     */\n    String = 'string',\n\n    /**\n     * A number (integer or float).\n     */\n    Number = 'number',\n\n    /**\n     * A boolean value.\n     */\n    Boolean = 'boolean',\n\n    /**\n     * A JSON object\n     */\n    Json = 'json',\n\n    /**\n     * Value with \"any\" or \"unknown\" type (aka Object). Values typed `any` may\n     * be `null` or `undefined`.\n     */\n    Any = 'any'\n}\n\n/**\n * A value that can possibly be optional.\n */\nexport interface OptionalValue {\n    /**\n     * Determines whether the value is, indeed, optional.\n     *\n     * @default false\n     */\n    optional?: boolean;\n\n    /**\n     * The declared type of the value, when it's present.\n     */\n    type: TypeReference;\n}\n\n/**\n * A reference to a type (primitive, collection or fqn).\n */\nexport type TypeReference = NamedTypeReference | PrimitiveTypeReference | CollectionTypeReference | UnionTypeReference;\n\n/**\n * The standard representation of the `any` type (includes optionality marker).\n */\nexport const CANONICAL_ANY: Readonly<PrimitiveTypeReference> = { primitive: PrimitiveType.Any };\n\n/**\n * Reference to a named type, defined by this assembly or one of its\n * dependencies.\n */\nexport interface NamedTypeReference {\n    /**\n     * The fully-qualified-name of the type (can be located in the\n     * ``spec.types[fqn]``` of the assembly that defines the type).\n     */\n    fqn: FQN;\n}\nexport function isNamedTypeReference(ref: TypeReference | undefined): ref is NamedTypeReference {\n    return ref != null && !!(ref as NamedTypeReference).fqn;\n}\n\n/**\n * Reference to a primitive type.\n */\nexport interface PrimitiveTypeReference {\n    /**\n     * If this is a reference to a primitive type, this will include the\n     * primitive type kind.\n     */\n    primitive: PrimitiveType;\n}\nexport function isPrimitiveTypeReference(ref: TypeReference | undefined): ref is PrimitiveTypeReference {\n    return ref != null && !!(ref as PrimitiveTypeReference).primitive;\n}\n\n/**\n * Reference to a collection type.\n */\nexport interface CollectionTypeReference {\n    collection: {\n        /**\n         * The kind of collection.\n         */\n        kind: CollectionKind;\n\n        /**\n         * The type of an element (map keys are always strings).\n         */\n        elementtype: TypeReference;\n    };\n}\nexport function isCollectionTypeReference(ref: TypeReference | undefined): ref is CollectionTypeReference {\n    return ref != null && !!(ref as CollectionTypeReference).collection;\n}\n\n/**\n * Reference to a union type.\n */\nexport interface UnionTypeReference {\n    /**\n     * Indicates that this is a union type, which means it can be one of a set\n     * of types.\n     */\n    union: {\n        /**\n         * All the possible types (including the primary type).\n         *\n         * @minItems 2\n         */\n        types: TypeReference[];\n    }\n}\nexport function isUnionTypeReference(ref: TypeReference | undefined): ref is UnionTypeReference {\n    return ref != null && !!(ref as UnionTypeReference).union;\n}\n\n/**\n * Methods and properties can be overridden from parent classes or implemented\n * from interfaces.\n */\nexport interface Overridable {\n    /**\n     * The FQN of the parent type (class or interface) that this entity\n     * overrides or implements. If undefined, then this entity is the first in\n     * it's hierarchy to declare this entity.\n     *\n     * @default this member is not overriding anything\n     */\n    overrides?: FQN;\n}\n\n/**\n * A class property.\n */\nexport interface Property extends Documentable, OptionalValue, Overridable, SourceLocatable {\n    /**\n     * The name of the property.\n     *\n     * @minLength 1\n     */\n    name: string;\n\n    /**\n     * Indicates if this property only has a getter (immutable).\n     *\n     * @default false\n     */\n    immutable?: boolean;\n\n    /**\n     * Indicates if this property is protected (otherwise it is public)\n     *\n     * @default false\n     */\n    protected?: boolean;\n\n    /**\n     * Indicates if this property is abstract\n     *\n     * @default false\n     */\n    abstract?: boolean;\n\n    /**\n     * Indicates if this is a static property.\n     *\n     * @default false\n     */\n    static?: boolean;\n\n    /**\n     * A hint that indicates that this static, immutable property is initialized\n     * during startup. This allows emitting \"const\" idioms in different target\n     * languages. Implies `static` and `immutable`.\n     *\n     * @default false\n     */\n    const?: boolean;\n}\n\n/**\n * Represents a method parameter.\n */\nexport interface Parameter extends Documentable, OptionalValue {\n\n    /**\n     * The name of the parameter.\n     *\n     * @minLength 1\n     */\n    name: string;\n\n    /**\n     * Whether this is the last parameter of a variadic method. In such cases,\n     * the `#type` attribute is the type of each individual item of the variadic\n     * arguments list (as opposed to some array type, as for example TypeScript\n     * would model it).\n     *\n     * @default false\n     */\n    variadic?: boolean;\n}\n\n/**\n * An Initializer or a Method.\n */\nexport interface Callable extends Documentable, Overridable, SourceLocatable {\n    /**\n     * The parameters of the Initializer or Method.\n     *\n     * @default none\n     */\n    parameters?: Parameter[];\n\n    /**\n     * Indicates if this Initializer or Method is protected (otherwise it is\n     * public, since private members are not modeled).\n     *\n     * @default false\n     */\n    protected?: boolean;\n\n    /**\n     * Indicates whether this Initializer or Method is variadic or not. When\n     * ``true``, the last element of ``#parameters`` will also be flagged\n     * ``#variadic``.\n     *\n     * @default false\n     */\n    variadic?: boolean;\n}\n\n/**\n * An initializer.\n */\nexport type Initializer = Callable;\n\n/**\n * A method with a name (i.e: not an initializer).\n */\nexport interface Method extends Callable {\n    /**\n     * The name of the method. Undefined if this method is a initializer.\n     */\n    name: string;\n\n    /**\n     * The return type of the method (`undefined` if `void`)\n     *\n     * @default void\n     */\n    returns?: OptionalValue;\n\n    /**\n     * Is this method an abstract method (this means the class will also be an abstract class)\n     *\n     * @default false\n     */\n    abstract?: boolean;\n\n    /**\n     * Indicates if this is an asynchronous method (it will return a promise).\n     *\n     * @default false\n     */\n    async?: boolean;\n\n    /**\n     * Indicates if this is a static method.\n     *\n     * @default false\n     */\n    static?: boolean;\n}\n/**\n * Determines whether a Callable is a Method or not.\n *\n * @param callable the callable to be checked.\n */\nexport function isMethod(callable: Callable): callable is Method {\n    return !!(callable as Method).name;\n}\n\n/**\n * Represents a type definition (not a type reference).\n */\nexport type Type = TypeBase & (ClassType | EnumType | InterfaceType);\n\n/**\n * Common attributes of a type definition.\n */\nexport interface TypeBase extends Documentable, SourceLocatable {\n    /**\n     * The fully qualified name of the type (``<assembly>.<namespace>.<name>``)\n     *\n     * @minLength 3\n     */\n    fqn: FQN;\n\n    /**\n     * The name of the assembly the type belongs to.\n     *\n     * @minLength 1\n     */\n    assembly: string;\n\n    /**\n     * The namespace of the type (``foo.bar.baz``). When undefined, the type is located at the root of the assembly\n     * (it's ``fqn`` would be like ``<assembly>.<name>``). If the `namespace` corresponds to an existing type's\n     * namespace-qualified (e.g: ``<namespace>.<name>``), then the current type is a nested type.\n     *\n     * @default none\n     */\n    namespace?: string;\n\n    /**\n     * The simple name of the type (MyClass).\n     *\n     * @minLength 1\n     */\n    name: string;\n\n    /**\n     * The kind of the type.\n     */\n    kind: TypeKind;\n}\n\n/**\n * Kinds of types.\n */\nexport enum TypeKind {\n    Class = 'class',\n    Enum = 'enum',\n    Interface = 'interface'\n}\n\n/**\n * Represents classes.\n */\nexport interface ClassType extends TypeBase {\n    kind: TypeKind.Class;\n\n    /**\n     * The FQN of the base class of this class, if it has one.\n     *\n     * @default no base class\n     */\n    base?: FQN;\n\n    /**\n     * Initializer (constructor) method.\n     *\n     * @default no initializer\n     */\n    initializer?: Initializer;\n\n    /**\n     * List of properties.\n     *\n     * @default none\n     */\n    properties?: Property[];\n\n    /**\n     * List of methods.\n     *\n     * @default none\n     */\n    methods?: Method[];\n\n    /**\n     * Indicates if this class is an abstract class.\n     *\n     * @default false\n     */\n    abstract?: boolean;\n\n    /**\n     * The FQNs of the interfaces this class implements, if any.\n     *\n     * @default none\n     * @uniqueItems true\n     */\n    interfaces?: FQN[];\n}\n\nexport function isClassType(type: Type | undefined): type is ClassType {\n    return type != null && type.kind === TypeKind.Class;\n}\n\nexport interface InterfaceType extends TypeBase {\n    kind: TypeKind.Interface;\n\n    /**\n     * The FQNs of the interfaces this interface extends, if any.\n     *\n     * @default none\n     * @uniqueItems true\n     */\n    interfaces?: FQN[];\n\n    /**\n     * List of methods.\n     *\n     * @default none\n     */\n    methods?: Method[];\n\n    /**\n     * List of properties.\n     *\n     * @default none\n     */\n    properties?: Property[];\n\n    /**\n     * True if this interface only contains properties. Different backends might\n     * have idiomatic ways to allow defining concrete instances such interfaces.\n     * For example, in Java, the generator will produce a PoJo and a builder\n     * which will allow users to create a concrete object with data which\n     * adheres to this interface.\n     *\n     * @default false\n     */\n    datatype?: boolean;\n}\n\nexport function isInterfaceType(type: Type | undefined): type is InterfaceType {\n    return type != null && type.kind === TypeKind.Interface;\n}\n\n/**\n * Represents a member of an enum.\n */\nexport interface EnumMember extends Documentable {\n    /**\n     * The name/symbol of the member.\n     */\n    name: string;\n}\n\n/**\n * Represents an enum type.\n */\nexport interface EnumType extends TypeBase {\n    kind: TypeKind.Enum;\n\n    /**\n     * Members of the enum.\n     */\n    members: EnumMember[];\n}\n\nexport function isEnumType(type: Type | undefined): type is EnumType {\n    return type != null && type.kind === TypeKind.Enum;\n}\n\n/**\n * Return whether this type is a class or interface type\n */\nexport function isClassOrInterfaceType(type: Type | undefined): type is (InterfaceType | ClassType) {\n    return isClassType(type) || isInterfaceType(type);\n}\n\n/**\n * Return a string representation of the given type reference.\n */\nexport function describeTypeReference(type?: TypeReference): string {\n    if (type === undefined) { return 'void'; }\n\n    if (isNamedTypeReference(type)) {\n        return type.fqn;\n    }\n\n    if (isPrimitiveTypeReference(type)) {\n        return type.primitive;\n    }\n\n    if (isCollectionTypeReference(type)) {\n        return `${type.collection.kind}<${describeTypeReference(type.collection.elementtype)}>`;\n    }\n\n    if (isUnionTypeReference(type)) {\n        const unionType = type.union.types.map(describeTypeReference).join(' | ');\n        return unionType;\n    }\n\n    throw new Error('Unrecognized type reference');\n}\n\n/**\n * Determines whether an entity is deprecated.\n *\n * @param entity the entity to be checked.\n *\n * @returns true if the entity is marked as deprecated.\n */\nexport function isDeprecated(entity: Documentable): boolean {\n    return entity.docs != null && entity.docs.stability === Stability.Deprecated;\n}\n","import * as spec from './assembly';\n\n/**\n * A tree of all names in a module. A node represent a type (terminal)\n * and may represent another node in the namespace (at the same time).\n * Therefore, a key of '_' represents a terminal and references the fqn\n * of the type.\n *\n * For example, say we have the following types:\n *   - aws.ec2.Host\n *   - aws.ec2.Instance\n *   - aws.ec2.Instance.Subtype\n *\n * the the name tree will look like this:\n *\n * module: {\n *   children: {\n *     aws: {\n *       children {\n *         ec2: {\n *           children: {\n *             Host: {\n *               fqn: 'aws.ec2.Host',\n *               children: {}\n *             },\n *             Instance: {\n *               fqn: 'aws.ec2.Host',\n *               children: {\n *                 Subtype: {\n *                   fqn: 'aws.ec2.Host.Subtype',\n *                   children: {}\n *                 }\n *               }\n *             }\n *           }\n *         }\n *       }\n *     }\n *   }\n * }\n */\nexport class NameTree {\n    public static of(assm: spec.Assembly): NameTree {\n        const nameTree = new NameTree();\n        for (const type of Object.values(assm.types || {})) {\n            nameTree.register(type.fqn);\n        }\n        return nameTree;\n    }\n\n    private _children: { [name: string]: NameTree } = {};\n    private _fqn?: string;\n\n    /* NameTree.of(assembly) should be used. */\n    private constructor() {}\n\n    /** The children of this node, by name. */\n    public get children(): { readonly [name: string]: NameTree } {\n        return this._children;\n    }\n\n    /** The fully qualified name of the type at this node, if there is one. */\n    public get fqn(): string | undefined {\n        return this._fqn;\n    }\n\n    /**\n     * Adds a type to this ``NameTree``.\n     *\n     * @param type the type to be added.\n     * @param path the path at which to add the node under this tree.\n     */\n    private register(fqn: string, path: string[] = fqn.split('.')): this {\n        if (path.length === 0) {\n            this._fqn = fqn;\n        } else {\n            const [head, ...rest] = path;\n            if (!this._children[head]) {\n                this._children[head] = new NameTree();\n            }\n            this._children[head]!.register(fqn, rest);\n        }\n        return this;\n    }\n}\n","import jsonschema = require('jsonschema');\nimport { Assembly } from './assembly';\n\n// tslint:disable-next-line:no-var-requires\nexport const schema: jsonschema.Schema = require('../schema/jsii-spec.schema.json');\n\nexport function validateAssembly(obj: any): Assembly {\n    const validator = new jsonschema.Validator();\n    validator.addSchema(schema); // For definitions\n    const result = validator.validate(obj, schema, { nestedErrors: true } as any); // nestedErrors does exist but is not in the TypeScript definitions\n    if (result.valid) { return obj; }\n    throw new Error(`Invalid assembly:\\n${result}`);\n}\n","'use strict';\n\nvar Validator = module.exports.Validator = require('./validator');\n\nmodule.exports.ValidatorResult = require('./helpers').ValidatorResult;\nmodule.exports.ValidationError = require('./helpers').ValidationError;\nmodule.exports.SchemaError = require('./helpers').SchemaError;\nmodule.exports.SchemaScanResult = require('./scan').SchemaScanResult;\nmodule.exports.scan = require('./scan').scan;\n\nmodule.exports.validate = function (instance, schema, options) {\n  var v = new Validator();\n  return v.validate(instance, schema, options);\n};\n","'use strict';\n\nvar urilib = require('url');\n\nvar attribute = require('./attribute');\nvar helpers = require('./helpers');\nvar scanSchema = require('./scan').scan;\nvar ValidatorResult = helpers.ValidatorResult;\nvar SchemaError = helpers.SchemaError;\nvar SchemaContext = helpers.SchemaContext;\n//var anonymousBase = 'vnd.jsonschema:///';\nvar anonymousBase = '/';\n\n/**\n * Creates a new Validator object\n * @name Validator\n * @constructor\n */\nvar Validator = function Validator () {\n  // Allow a validator instance to override global custom formats or to have their\n  // own custom formats.\n  this.customFormats = Object.create(Validator.prototype.customFormats);\n  this.schemas = {};\n  this.unresolvedRefs = [];\n\n  // Use Object.create to make this extensible without Validator instances stepping on each other's toes.\n  this.types = Object.create(types);\n  this.attributes = Object.create(attribute.validators);\n};\n\n// Allow formats to be registered globally.\nValidator.prototype.customFormats = {};\n\n// Hint at the presence of a property\nValidator.prototype.schemas = null;\nValidator.prototype.types = null;\nValidator.prototype.attributes = null;\nValidator.prototype.unresolvedRefs = null;\n\n/**\n * Adds a schema with a certain urn to the Validator instance.\n * @param schema\n * @param urn\n * @return {Object}\n */\nValidator.prototype.addSchema = function addSchema (schema, base) {\n  var self = this;\n  if (!schema) {\n    return null;\n  }\n  var scan = scanSchema(base||anonymousBase, schema);\n  var ourUri = base || schema.id;\n  for(var uri in scan.id){\n    this.schemas[uri] = scan.id[uri];\n  }\n  for(var uri in scan.ref){\n    this.unresolvedRefs.push(uri);\n  }\n  this.unresolvedRefs = this.unresolvedRefs.filter(function(uri){\n    return typeof self.schemas[uri]==='undefined';\n  });\n  return this.schemas[ourUri];\n};\n\nValidator.prototype.addSubSchemaArray = function addSubSchemaArray(baseuri, schemas) {\n  if(!(schemas instanceof Array)) return;\n  for(var i=0; i<schemas.length; i++){\n    this.addSubSchema(baseuri, schemas[i]);\n  }\n};\n\nValidator.prototype.addSubSchemaObject = function addSubSchemaArray(baseuri, schemas) {\n  if(!schemas || typeof schemas!='object') return;\n  for(var p in schemas){\n    this.addSubSchema(baseuri, schemas[p]);\n  }\n};\n\n\n\n/**\n * Sets all the schemas of the Validator instance.\n * @param schemas\n */\nValidator.prototype.setSchemas = function setSchemas (schemas) {\n  this.schemas = schemas;\n};\n\n/**\n * Returns the schema of a certain urn\n * @param urn\n */\nValidator.prototype.getSchema = function getSchema (urn) {\n  return this.schemas[urn];\n};\n\n/**\n * Validates instance against the provided schema\n * @param instance\n * @param schema\n * @param [options]\n * @param [ctx]\n * @return {Array}\n */\nValidator.prototype.validate = function validate (instance, schema, options, ctx) {\n  if (!options) {\n    options = {};\n  }\n  var propertyName = options.propertyName || 'instance';\n  // This will work so long as the function at uri.resolve() will resolve a relative URI to a relative URI\n  var base = urilib.resolve(options.base||anonymousBase, schema.id||'');\n  if(!ctx){\n    ctx = new SchemaContext(schema, options, propertyName, base, Object.create(this.schemas));\n    if (!ctx.schemas[base]) {\n      ctx.schemas[base] = schema;\n    }\n    var found = scanSchema(base, schema);\n    for(var n in found.id){\n      var sch = found.id[n];\n      ctx.schemas[n] = sch;\n    }\n  }\n  if (schema) {\n    var result = this.validateSchema(instance, schema, options, ctx);\n    if (!result) {\n      throw new Error('Result undefined');\n    }\n    return result;\n  }\n  throw new SchemaError('no schema specified', schema);\n};\n\n/**\n* @param Object schema\n* @return mixed schema uri or false\n*/\nfunction shouldResolve(schema) {\n  var ref = (typeof schema === 'string') ? schema : schema.$ref;\n  if (typeof ref=='string') return ref;\n  return false;\n}\n\n/**\n * Validates an instance against the schema (the actual work horse)\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @private\n * @return {ValidatorResult}\n */\nValidator.prototype.validateSchema = function validateSchema (instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n    // Support for the true/false schemas\n  if(typeof schema==='boolean') {\n    if(schema===true){\n      // `true` is always valid\n      schema = {};\n    }else if(schema===false){\n      // `false` is always invalid\n      schema = {type: []};\n    }\n  }else if(!schema){\n    // This might be a string\n    throw new Error(\"schema is undefined\");\n  }\n\n  if (schema['extends']) {\n    if (schema['extends'] instanceof Array) {\n      var schemaobj = {schema: schema, ctx: ctx};\n      schema['extends'].forEach(this.schemaTraverser.bind(this, schemaobj));\n      schema = schemaobj.schema;\n      schemaobj.schema = null;\n      schemaobj.ctx = null;\n      schemaobj = null;\n    } else {\n      schema = helpers.deepMerge(schema, this.superResolve(schema['extends'], ctx));\n    }\n  }\n\n  // If passed a string argument, load that schema URI\n  var switchSchema;\n  if (switchSchema = shouldResolve(schema)) {\n    var resolved = this.resolve(schema, switchSchema, ctx);\n    var subctx = new SchemaContext(resolved.subschema, options, ctx.propertyPath, resolved.switchSchema, ctx.schemas);\n    return this.validateSchema(instance, resolved.subschema, options, subctx);\n  }\n\n  var skipAttributes = options && options.skipAttributes || [];\n  // Validate each schema attribute against the instance\n  for (var key in schema) {\n    if (!attribute.ignoreProperties[key] && skipAttributes.indexOf(key) < 0) {\n      var validatorErr = null;\n      var validator = this.attributes[key];\n      if (validator) {\n        validatorErr = validator.call(this, instance, schema, options, ctx);\n      } else if (options.allowUnknownAttributes === false) {\n        // This represents an error with the schema itself, not an invalid instance\n        throw new SchemaError(\"Unsupported attribute: \" + key, schema);\n      }\n      if (validatorErr) {\n        result.importErrors(validatorErr);\n      }\n    }\n  }\n\n  if (typeof options.rewrite == 'function') {\n    var value = options.rewrite.call(this, instance, schema, options, ctx);\n    result.instance = value;\n  }\n  return result;\n};\n\n/**\n* @private\n* @param Object schema\n* @param SchemaContext ctx\n* @returns Object schema or resolved schema\n*/\nValidator.prototype.schemaTraverser = function schemaTraverser (schemaobj, s) {\n  schemaobj.schema = helpers.deepMerge(schemaobj.schema, this.superResolve(s, schemaobj.ctx));\n}\n\n/**\n* @private\n* @param Object schema\n* @param SchemaContext ctx\n* @returns Object schema or resolved schema\n*/\nValidator.prototype.superResolve = function superResolve (schema, ctx) {\n  var ref;\n  if(ref = shouldResolve(schema)) {\n    return this.resolve(schema, ref, ctx).subschema;\n  }\n  return schema;\n}\n\n/**\n* @private\n* @param Object schema\n* @param Object switchSchema\n* @param SchemaContext ctx\n* @return Object resolved schemas {subschema:String, switchSchema: String}\n* @throws SchemaError\n*/\nValidator.prototype.resolve = function resolve (schema, switchSchema, ctx) {\n  switchSchema = ctx.resolve(switchSchema);\n  // First see if the schema exists under the provided URI\n  if (ctx.schemas[switchSchema]) {\n    return {subschema: ctx.schemas[switchSchema], switchSchema: switchSchema};\n  }\n  // Else try walking the property pointer\n  var parsed = urilib.parse(switchSchema);\n  var fragment = parsed && parsed.hash;\n  var document = fragment && fragment.length && switchSchema.substr(0, switchSchema.length - fragment.length);\n  if (!document || !ctx.schemas[document]) {\n    throw new SchemaError(\"no such schema <\" + switchSchema + \">\", schema);\n  }\n  var subschema = helpers.objectGetPath(ctx.schemas[document], fragment.substr(1));\n  if(subschema===undefined){\n    throw new SchemaError(\"no such schema \" + fragment + \" located in <\" + document + \">\", schema);\n  }\n  return {subschema: subschema, switchSchema: switchSchema};\n};\n\n/**\n * Tests whether the instance if of a certain type.\n * @private\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @param type\n * @return {boolean}\n */\nValidator.prototype.testType = function validateType (instance, schema, options, ctx, type) {\n  if (typeof this.types[type] == 'function') {\n    return this.types[type].call(this, instance);\n  }\n  if (type && typeof type == 'object') {\n    var res = this.validateSchema(instance, type, options, ctx);\n    return res === undefined || !(res && res.errors.length);\n  }\n  // Undefined or properties not on the list are acceptable, same as not being defined\n  return true;\n};\n\nvar types = Validator.prototype.types = {};\ntypes.string = function testString (instance) {\n  return typeof instance == 'string';\n};\ntypes.number = function testNumber (instance) {\n  // isFinite returns false for NaN, Infinity, and -Infinity\n  return typeof instance == 'number' && isFinite(instance);\n};\ntypes.integer = function testInteger (instance) {\n  return (typeof instance == 'number') && instance % 1 === 0;\n};\ntypes.boolean = function testBoolean (instance) {\n  return typeof instance == 'boolean';\n};\ntypes.array = function testArray (instance) {\n  return Array.isArray(instance);\n};\ntypes['null'] = function testNull (instance) {\n  return instance === null;\n};\ntypes.date = function testDate (instance) {\n  return instance instanceof Date;\n};\ntypes.any = function testAny (instance) {\n  return true;\n};\ntypes.object = function testObject (instance) {\n  // TODO: fix this - see #15\n  return instance && (typeof instance) === 'object' && !(instance instanceof Array) && !(instance instanceof Date);\n};\n\nmodule.exports = Validator;\n","'use strict';\n\nvar helpers = require('./helpers');\n\n/** @type ValidatorResult */\nvar ValidatorResult = helpers.ValidatorResult;\n/** @type SchemaError */\nvar SchemaError = helpers.SchemaError;\n\nvar attribute = {};\n\nattribute.ignoreProperties = {\n  // informative properties\n  'id': true,\n  'default': true,\n  'description': true,\n  'title': true,\n  // arguments to other properties\n  'exclusiveMinimum': true,\n  'exclusiveMaximum': true,\n  'additionalItems': true,\n  // special-handled properties\n  '$schema': true,\n  '$ref': true,\n  'extends': true\n};\n\n/**\n * @name validators\n */\nvar validators = attribute.validators = {};\n\n/**\n * Validates whether the instance if of a certain type\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {ValidatorResult|null}\n */\nvalidators.type = function validateType (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var types = Array.isArray(schema.type) ? schema.type : [schema.type];\n  if (!types.some(this.testType.bind(this, instance, schema, options, ctx))) {\n    var list = types.map(function (v) {\n      return v.id && ('<' + v.id + '>') || (v+'');\n    });\n    result.addError({\n      name: 'type',\n      argument: list,\n      message: \"is not of a type(s) \" + list,\n    });\n  }\n  return result;\n};\n\nfunction testSchemaNoThrow(instance, options, ctx, callback, schema){\n  var throwError = options.throwError;\n  options.throwError = false;\n  var res = this.validateSchema(instance, schema, options, ctx);\n  options.throwError = throwError;\n\n  if (! res.valid && callback instanceof Function) {\n    callback(res);\n  }\n  return res.valid;\n}\n\n/**\n * Validates whether the instance matches some of the given schemas\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {ValidatorResult|null}\n */\nvalidators.anyOf = function validateAnyOf (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var inner = new ValidatorResult(instance, schema, options, ctx);\n  if (!Array.isArray(schema.anyOf)){\n    throw new SchemaError(\"anyOf must be an array\");\n  }\n  if (!schema.anyOf.some(\n    testSchemaNoThrow.bind(\n      this, instance, options, ctx, function(res){inner.importErrors(res);}\n      ))) {\n    var list = schema.anyOf.map(function (v, i) {\n      return (v.id && ('<' + v.id + '>')) || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';\n    });\n    if (options.nestedErrors) {\n      result.importErrors(inner);\n    }\n    result.addError({\n      name: 'anyOf',\n      argument: list,\n      message: \"is not any of \" + list.join(','),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance matches every given schema\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\nvalidators.allOf = function validateAllOf (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  if (!Array.isArray(schema.allOf)){\n    throw new SchemaError(\"allOf must be an array\");\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var self = this;\n  schema.allOf.forEach(function(v, i){\n    var valid = self.validateSchema(instance, v, options, ctx);\n    if(!valid.valid){\n      var msg = (v.id && ('<' + v.id + '>')) || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';\n      result.addError({\n        name: 'allOf',\n        argument: { id: msg, length: valid.errors.length, valid: valid },\n        message: 'does not match allOf schema ' + msg + ' with ' + valid.errors.length + ' error[s]:',\n      });\n      result.importErrors(valid);\n    }\n  });\n  return result;\n};\n\n/**\n * Validates whether the instance matches exactly one of the given schemas\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\nvalidators.oneOf = function validateOneOf (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  if (!Array.isArray(schema.oneOf)){\n    throw new SchemaError(\"oneOf must be an array\");\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var inner = new ValidatorResult(instance, schema, options, ctx);\n  var count = schema.oneOf.filter(\n    testSchemaNoThrow.bind(\n      this, instance, options, ctx, function(res) {inner.importErrors(res);}\n      ) ).length;\n  var list = schema.oneOf.map(function (v, i) {\n    return (v.id && ('<' + v.id + '>')) || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';\n  });\n  if (count!==1) {\n    if (options.nestedErrors) {\n      result.importErrors(inner);\n    }\n    result.addError({\n      name: 'oneOf',\n      argument: list,\n      message: \"is not exactly one from \" + list.join(','),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates properties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.properties = function validateProperties (instance, schema, options, ctx) {\n  if(!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var properties = schema.properties || {};\n  for (var property in properties) {\n    if (typeof options.preValidateProperty == 'function') {\n      options.preValidateProperty(instance, property, properties[property], options, ctx);\n    }\n\n    var prop = Object.hasOwnProperty.call(instance, property) ? instance[property] : undefined;\n    var res = this.validateSchema(prop, properties[property], options, ctx.makeChild(properties[property], property));\n    if(res.instance !== result.instance[property]) result.instance[property] = res.instance;\n    result.importErrors(res);\n  }\n  return result;\n};\n\n/**\n * Test a specific property within in instance against the additionalProperties schema attribute\n * This ignores properties with definitions in the properties schema attribute, but no other attributes.\n * If too many more types of property-existance tests pop up they may need their own class of tests (like `type` has)\n * @private\n * @return {boolean}\n */\nfunction testAdditionalProperty (instance, schema, options, ctx, property, result) {\n  if(!this.types.object(instance)) return;\n  if (schema.properties && schema.properties[property] !== undefined) {\n    return;\n  }\n  if (schema.additionalProperties === false) {\n    result.addError({\n      name: 'additionalProperties',\n      argument: property,\n      message: \"additionalProperty \" + JSON.stringify(property) + \" exists in instance when not allowed\",\n    });\n  } else {\n    var additionalProperties = schema.additionalProperties || {};\n\n    if (typeof options.preValidateProperty == 'function') {\n      options.preValidateProperty(instance, property, additionalProperties, options, ctx);\n    }\n\n    var res = this.validateSchema(instance[property], additionalProperties, options, ctx.makeChild(additionalProperties, property));\n    if(res.instance !== result.instance[property]) result.instance[property] = res.instance;\n    result.importErrors(res);\n  }\n}\n\n/**\n * Validates patternProperties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.patternProperties = function validatePatternProperties (instance, schema, options, ctx) {\n  if(!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var patternProperties = schema.patternProperties || {};\n\n  for (var property in instance) {\n    var test = true;\n    for (var pattern in patternProperties) {\n      var expr = new RegExp(pattern);\n      if (!expr.test(property)) {\n        continue;\n      }\n      test = false;\n\n      if (typeof options.preValidateProperty == 'function') {\n        options.preValidateProperty(instance, property, patternProperties[pattern], options, ctx);\n      }\n\n      var res = this.validateSchema(instance[property], patternProperties[pattern], options, ctx.makeChild(patternProperties[pattern], property));\n      if(res.instance !== result.instance[property]) result.instance[property] = res.instance;\n      result.importErrors(res);\n    }\n    if (test) {\n      testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);\n    }\n  }\n\n  return result;\n};\n\n/**\n * Validates additionalProperties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.additionalProperties = function validateAdditionalProperties (instance, schema, options, ctx) {\n  if(!this.types.object(instance)) return;\n  // if patternProperties is defined then we'll test when that one is called instead\n  if (schema.patternProperties) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  for (var property in instance) {\n    testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at least of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minProperties = function validateMinProperties (instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var keys = Object.keys(instance);\n  if (!(keys.length >= schema.minProperties)) {\n    result.addError({\n      name: 'minProperties',\n      argument: schema.minProperties,\n      message: \"does not meet minimum property length of \" + schema.minProperties,\n    })\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at most of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maxProperties = function validateMaxProperties (instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var keys = Object.keys(instance);\n  if (!(keys.length <= schema.maxProperties)) {\n    result.addError({\n      name: 'maxProperties',\n      argument: schema.maxProperties,\n      message: \"does not meet maximum property length of \" + schema.maxProperties,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates items when instance is an array\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.items = function validateItems (instance, schema, options, ctx) {\n  var self = this;\n  if (!this.types.array(instance)) return;\n  if (!schema.items) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  instance.every(function (value, i) {\n    var items = Array.isArray(schema.items) ? (schema.items[i] || schema.additionalItems) : schema.items;\n    if (items === undefined) {\n      return true;\n    }\n    if (items === false) {\n      result.addError({\n        name: 'items',\n        message: \"additionalItems not permitted\",\n      });\n      return false;\n    }\n    var res = self.validateSchema(value, items, options, ctx.makeChild(items, i));\n    if(res.instance !== result.instance[i]) result.instance[i] = res.instance;\n    result.importErrors(res);\n    return true;\n  });\n  return result;\n};\n\n/**\n * Validates minimum and exclusiveMinimum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minimum = function validateMinimum (instance, schema, options, ctx) {\n  if (!this.types.number(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var valid = true;\n  if (schema.exclusiveMinimum && schema.exclusiveMinimum === true) {\n    valid = instance > schema.minimum;\n  } else {\n    valid = instance >= schema.minimum;\n  }\n  if (!valid) {\n    result.addError({\n      name: 'minimum',\n      argument: schema.minimum,\n      message: \"must have a minimum value of \" + schema.minimum,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates maximum and exclusiveMaximum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maximum = function validateMaximum (instance, schema, options, ctx) {\n  if (!this.types.number(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var valid;\n  if (schema.exclusiveMaximum && schema.exclusiveMaximum === true) {\n    valid = instance < schema.maximum;\n  } else {\n    valid = instance <= schema.maximum;\n  }\n  if (!valid) {\n    result.addError({\n      name: 'maximum',\n      argument: schema.maximum,\n      message: \"must have a maximum value of \" + schema.maximum,\n    });\n  }\n  return result;\n};\n\n/**\n * Perform validation for multipleOf and divisibleBy, which are essentially the same.\n * @param instance\n * @param schema\n * @param validationType\n * @param errorMessage\n * @returns {String|null}\n */\nvar validateMultipleOfOrDivisbleBy = function validateMultipleOfOrDivisbleBy (instance, schema, options, ctx, validationType, errorMessage) {\n  if (!this.types.number(instance)) return;\n\n  var validationArgument = schema[validationType];\n  if (validationArgument == 0) {\n    throw new SchemaError(validationType + \" cannot be zero\");\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  var instanceDecimals = helpers.getDecimalPlaces(instance);\n  var divisorDecimals = helpers.getDecimalPlaces(validationArgument);\n\n  var maxDecimals = Math.max(instanceDecimals , divisorDecimals);\n  var multiplier = Math.pow(10, maxDecimals);\n\n  if (Math.round(instance * multiplier) % Math.round(validationArgument * multiplier) !== 0) {\n    result.addError({\n      name: validationType,\n      argument:  validationArgument,\n      message: errorMessage + JSON.stringify(validationArgument)\n    });\n  }\n\n  return result;\n};\n\n/**\n * Validates divisibleBy when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.multipleOf = function validateMultipleOf (instance, schema, options, ctx) {\n return validateMultipleOfOrDivisbleBy.call(this, instance, schema, options, ctx, \"multipleOf\", \"is not a multiple of (divisible by) \");\n};\n\n/**\n * Validates multipleOf when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.divisibleBy = function validateDivisibleBy (instance, schema, options, ctx) {\n  return validateMultipleOfOrDivisbleBy.call(this, instance, schema, options, ctx, \"divisibleBy\", \"is not divisible by (multiple of) \");\n};\n\n/**\n * Validates whether the instance value is present.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.required = function validateRequired (instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (instance === undefined && schema.required === true) {\n    // A boolean form is implemented for reverse-compatability with schemas written against older drafts\n    result.addError({\n      name: 'required',\n      message: \"is required\"\n    });\n  } else if (this.types.object(instance) && Array.isArray(schema.required)) {\n    schema.required.forEach(function(n){\n      if(instance[n]===undefined){\n        result.addError({\n          name: 'required',\n          argument: n,\n          message: \"requires property \" + JSON.stringify(n),\n        });\n      }\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value matches the regular expression, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.pattern = function validatePattern (instance, schema, options, ctx) {\n  if (!this.types.string(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!instance.match(schema.pattern)) {\n    result.addError({\n      name: 'pattern',\n      argument: schema.pattern,\n      message: \"does not match pattern \" + JSON.stringify(schema.pattern),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is of a certain defined format or a custom\n * format.\n * The following formats are supported for string types:\n *   - date-time\n *   - date\n *   - time\n *   - ip-address\n *   - ipv6\n *   - uri\n *   - color\n *   - host-name\n *   - alpha\n *   - alpha-numeric\n *   - utc-millisec\n * @param instance\n * @param schema\n * @param [options]\n * @param [ctx]\n * @return {String|null}\n */\nvalidators.format = function validateFormat (instance, schema, options, ctx) {\n  if (instance===undefined) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!result.disableFormat && !helpers.isFormat(instance, schema.format, this)) {\n    result.addError({\n      name: 'format',\n      argument: schema.format,\n      message: \"does not conform to the \" + JSON.stringify(schema.format) + \" format\",\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at least of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minLength = function validateMinLength (instance, schema, options, ctx) {\n  if (!this.types.string(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var hsp = instance.match(/[\\uDC00-\\uDFFF]/g);\n  var length = instance.length - (hsp ? hsp.length : 0);\n  if (!(length >= schema.minLength)) {\n    result.addError({\n      name: 'minLength',\n      argument: schema.minLength,\n      message: \"does not meet minimum length of \" + schema.minLength,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at most of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maxLength = function validateMaxLength (instance, schema, options, ctx) {\n  if (!this.types.string(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  // TODO if this was already computed in \"minLength\", use that value instead of re-computing\n  var hsp = instance.match(/[\\uDC00-\\uDFFF]/g);\n  var length = instance.length - (hsp ? hsp.length : 0);\n  if (!(length <= schema.maxLength)) {\n    result.addError({\n      name: 'maxLength',\n      argument: schema.maxLength,\n      message: \"does not meet maximum length of \" + schema.maxLength,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether instance contains at least a minimum number of items, when the instance is an Array.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minItems = function validateMinItems (instance, schema, options, ctx) {\n  if (!this.types.array(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!(instance.length >= schema.minItems)) {\n    result.addError({\n      name: 'minItems',\n      argument: schema.minItems,\n      message: \"does not meet minimum length of \" + schema.minItems,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether instance contains no more than a maximum number of items, when the instance is an Array.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maxItems = function validateMaxItems (instance, schema, options, ctx) {\n  if (!this.types.array(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!(instance.length <= schema.maxItems)) {\n    result.addError({\n      name: 'maxItems',\n      argument: schema.maxItems,\n      message: \"does not meet maximum length of \" + schema.maxItems,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates that every item in an instance array is unique, when instance is an array\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.uniqueItems = function validateUniqueItems (instance, schema, options, ctx) {\n  if (!this.types.array(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  function testArrays (v, i, a) {\n    for (var j = i + 1; j < a.length; j++) if (helpers.deepCompareStrict(v, a[j])) {\n      return false;\n    }\n    return true;\n  }\n  if (!instance.every(testArrays)) {\n    result.addError({\n      name: 'uniqueItems',\n      message: \"contains duplicate item\",\n    });\n  }\n  return result;\n};\n\n/**\n * Deep compares arrays for duplicates\n * @param v\n * @param i\n * @param a\n * @private\n * @return {boolean}\n */\nfunction testArrays (v, i, a) {\n  var j, len = a.length;\n  for (j = i + 1, len; j < len; j++) {\n    if (helpers.deepCompareStrict(v, a[j])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Validates whether there are no duplicates, when the instance is an Array.\n * @param instance\n * @return {String|null}\n */\nvalidators.uniqueItems = function validateUniqueItems (instance, schema, options, ctx) {\n  if (!this.types.array(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!instance.every(testArrays)) {\n    result.addError({\n      name: 'uniqueItems',\n      message: \"contains duplicate item\",\n    });\n  }\n  return result;\n};\n\n/**\n * Validate for the presence of dependency properties, if the instance is an object.\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {null|ValidatorResult}\n */\nvalidators.dependencies = function validateDependencies (instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  for (var property in schema.dependencies) {\n    if (instance[property] === undefined) {\n      continue;\n    }\n    var dep = schema.dependencies[property];\n    var childContext = ctx.makeChild(dep, property);\n    if (typeof dep == 'string') {\n      dep = [dep];\n    }\n    if (Array.isArray(dep)) {\n      dep.forEach(function (prop) {\n        if (instance[prop] === undefined) {\n          result.addError({\n            // FIXME there's two different \"dependencies\" errors here with slightly different outputs\n            // Can we make these the same? Or should we create different error types?\n            name: 'dependencies',\n            argument: childContext.propertyPath,\n            message: \"property \" + prop + \" not found, required by \" + childContext.propertyPath,\n          });\n        }\n      });\n    } else {\n      var res = this.validateSchema(instance, dep, options, childContext);\n      if(result.instance !== res.instance) result.instance = res.instance;\n      if (res && res.errors.length) {\n        result.addError({\n          name: 'dependencies',\n          argument: childContext.propertyPath,\n          message: \"does not meet dependency required by \" + childContext.propertyPath,\n        });\n        result.importErrors(res);\n      }\n    }\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is one of the enumerated values.\n *\n * @param instance\n * @param schema\n * @return {ValidatorResult|null}\n */\nvalidators['enum'] = function validateEnum (instance, schema, options, ctx) {\n  if (instance === undefined) {\n    return null;\n  }\n  if (!Array.isArray(schema['enum'])) {\n    throw new SchemaError(\"enum expects an array\", schema);\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!schema['enum'].some(helpers.deepCompareStrict.bind(null, instance))) {\n    result.addError({\n      name: 'enum',\n      argument: schema['enum'],\n      message: \"is not one of enum values: \" + schema['enum'].map(String).join(','),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance exactly matches a given value\n *\n * @param instance\n * @param schema\n * @return {ValidatorResult|null}\n */\nvalidators['const'] = function validateEnum (instance, schema, options, ctx) {\n  if (instance === undefined) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!helpers.deepCompareStrict(schema['const'], instance)) {\n    result.addError({\n      name: 'const',\n      argument: schema['const'],\n      message: \"does not exactly match expected constant: \" + schema['const'],\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance if of a prohibited type.\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {null|ValidatorResult}\n */\nvalidators.not = validators.disallow = function validateNot (instance, schema, options, ctx) {\n  var self = this;\n  if(instance===undefined) return null;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var notTypes = schema.not || schema.disallow;\n  if(!notTypes) return null;\n  if(!Array.isArray(notTypes)) notTypes=[notTypes];\n  notTypes.forEach(function (type) {\n    if (self.testType(instance, schema, options, ctx, type)) {\n      var schemaId = type && type.id && ('<' + type.id + '>') || type;\n      result.addError({\n        name: 'not',\n        argument: schemaId,\n        message: \"is of prohibited type \" + schemaId,\n      });\n    }\n  });\n  return result;\n};\n\nmodule.exports = attribute;\n","'use strict'\n\n// high-level commands\nexports.c = exports.create = require('./lib/create.js')\nexports.r = exports.replace = require('./lib/replace.js')\nexports.t = exports.list = require('./lib/list.js')\nexports.u = exports.update = require('./lib/update.js')\nexports.x = exports.extract = require('./lib/extract.js')\n\n// classes\nexports.Pack = require('./lib/pack.js')\nexports.Unpack = require('./lib/unpack.js')\nexports.Parse = require('./lib/parse.js')\nexports.ReadEntry = require('./lib/read-entry.js')\nexports.WriteEntry = require('./lib/write-entry.js')\nexports.Header = require('./lib/header.js')\nexports.Pax = require('./lib/pax.js')\nexports.types = require('./lib/types.js')\n","'use strict'\n\n// tar -c\nconst hlo = require('./high-level-opt.js')\n\nconst Pack = require('./pack.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst t = require('./list.js')\nconst path = require('path')\n\nconst c = module.exports = (opt_, files, cb) => {\n  if (typeof files === 'function')\n    cb = files\n\n  if (Array.isArray(opt_))\n    files = opt_, opt_ = {}\n\n  if (!files || !Array.isArray(files) || !files.length)\n    throw new TypeError('no files or directories specified')\n\n  files = Array.from(files)\n\n  const opt = hlo(opt_)\n\n  if (opt.sync && typeof cb === 'function')\n    throw new TypeError('callback not supported for sync tar functions')\n\n  if (!opt.file && typeof cb === 'function')\n    throw new TypeError('callback only supported with file option')\n\n  return opt.file && opt.sync ? createFileSync(opt, files)\n    : opt.file ? createFile(opt, files, cb)\n    : opt.sync ? createSync(opt, files)\n    : create(opt, files)\n}\n\nconst createFileSync = (opt, files) => {\n  const p = new Pack.Sync(opt)\n  const stream = new fsm.WriteStreamSync(opt.file, {\n    mode: opt.mode || 0o666\n  })\n  p.pipe(stream)\n  addFilesSync(p, files)\n}\n\nconst createFile = (opt, files, cb) => {\n  const p = new Pack(opt)\n  const stream = new fsm.WriteStream(opt.file, {\n    mode: opt.mode || 0o666\n  })\n  p.pipe(stream)\n\n  const promise = new Promise((res, rej) => {\n    stream.on('error', rej)\n    stream.on('close', res)\n    p.on('error', rej)\n  })\n\n  addFilesAsync(p, files)\n\n  return cb ? promise.then(cb, cb) : promise\n}\n\nconst addFilesSync = (p, files) => {\n  files.forEach(file => {\n    if (file.charAt(0) === '@')\n      t({\n        file: path.resolve(p.cwd, file.substr(1)),\n        sync: true,\n        noResume: true,\n        onentry: entry => p.add(entry)\n      })\n    else\n      p.add(file)\n  })\n  p.end()\n}\n\nconst addFilesAsync = (p, files) => {\n  while (files.length) {\n    const file = files.shift()\n    if (file.charAt(0) === '@')\n      return t({\n        file: path.resolve(p.cwd, file.substr(1)),\n        noResume: true,\n        onentry: entry => p.add(entry)\n      }).then(_ => addFilesAsync(p, files))\n    else\n      p.add(file)\n  }\n  p.end()\n}\n\nconst createSync = (opt, files) => {\n  const p = new Pack.Sync(opt)\n  addFilesSync(p, files)\n  return p\n}\n\nconst create = (opt, files) => {\n  const p = new Pack(opt)\n  addFilesAsync(p, files)\n  return p\n}\n","'use strict'\nmodule.exports = function (Yallist) {\n  Yallist.prototype[Symbol.iterator] = function* () {\n    for (let walker = this.head; walker; walker = walker.next) {\n      yield walker.value\n    }\n  }\n}\n","module.exports = require(\"string_decoder\");","module.exports = require(\"zlib\");","module.exports = Object.freeze({\n  Z_NO_FLUSH: 0,\n  Z_PARTIAL_FLUSH: 1,\n  Z_SYNC_FLUSH: 2,\n  Z_FULL_FLUSH: 3,\n  Z_FINISH: 4,\n  Z_BLOCK: 5,\n  Z_OK: 0,\n  Z_STREAM_END: 1,\n  Z_NEED_DICT: 2,\n  Z_ERRNO: -1,\n  Z_STREAM_ERROR: -2,\n  Z_DATA_ERROR: -3,\n  Z_MEM_ERROR: -4,\n  Z_BUF_ERROR: -5,\n  Z_VERSION_ERROR: -6,\n  Z_NO_COMPRESSION: 0,\n  Z_BEST_SPEED: 1,\n  Z_BEST_COMPRESSION: 9,\n  Z_DEFAULT_COMPRESSION: -1,\n  Z_FILTERED: 1,\n  Z_HUFFMAN_ONLY: 2,\n  Z_RLE: 3,\n  Z_FIXED: 4,\n  Z_DEFAULT_STRATEGY: 0,\n  ZLIB_VERNUM: 4736,\n  DEFLATE: 1,\n  INFLATE: 2,\n  GZIP: 3,\n  GUNZIP: 4,\n  DEFLATERAW: 5,\n  INFLATERAW: 6,\n  UNZIP: 7,\n  Z_MIN_WINDOWBITS: 8,\n  Z_MAX_WINDOWBITS: 15,\n  Z_DEFAULT_WINDOWBITS: 15,\n  Z_MIN_CHUNK: 64,\n  Z_MAX_CHUNK: Infinity,\n  Z_DEFAULT_CHUNK: 16384,\n  Z_MIN_MEMLEVEL: 1,\n  Z_MAX_MEMLEVEL: 9,\n  Z_DEFAULT_MEMLEVEL: 8,\n  Z_MIN_LEVEL: -1,\n  Z_MAX_LEVEL: 9,\n  Z_DEFAULT_LEVEL: -1\n})\n","'use strict'\n// Tar can encode large and negative numbers using a leading byte of\n// 0xff for negative, and 0x80 for positive.\n\nconst encode = exports.encode = (num, buf) => {\n  if (!Number.isSafeInteger(num))\n    // The number is so large that javascript cannot represent it with integer\n    // precision.\n    throw TypeError('cannot encode number outside of javascript safe integer range')\n  else if (num < 0)\n    encodeNegative(num, buf)\n  else\n    encodePositive(num, buf)\n  return buf\n}\n\nconst encodePositive = (num, buf) => {\n  buf[0] = 0x80\n\n  for (var i = buf.length; i > 1; i--) {\n    buf[i-1] = num & 0xff\n    num = Math.floor(num / 0x100)\n  }\n}\n\nconst encodeNegative = (num, buf) => {\n  buf[0] = 0xff\n  var flipped = false\n  num = num * -1\n  for (var i = buf.length; i > 1; i--) {\n    var byte = num & 0xff\n    num = Math.floor(num / 0x100)\n    if (flipped)\n      buf[i-1] = onesComp(byte)\n    else if (byte === 0)\n      buf[i-1] = 0\n    else {\n      flipped = true\n      buf[i-1] = twosComp(byte)\n    }\n  }\n}\n\nconst parse = exports.parse = (buf) => {\n  var post = buf[buf.length - 1]\n  var pre = buf[0]\n  var value;\n  if (pre === 0x80)\n    value = pos(buf.slice(1, buf.length))\n  else if (pre === 0xff)\n    value = twos(buf)\n  else\n    throw TypeError('invalid base256 encoding')\n\n  if (!Number.isSafeInteger(value))\n    // The number is so large that javascript cannot represent it with integer\n    // precision.\n    throw TypeError('parsed number outside of javascript safe integer range')\n\n  return value\n}\n\nconst twos = (buf) => {\n  var len = buf.length\n  var sum = 0\n  var flipped = false\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i]\n    var f\n    if (flipped)\n      f = onesComp(byte)\n    else if (byte === 0)\n      f = byte\n    else {\n      flipped = true\n      f = twosComp(byte)\n    }\n    if (f !== 0)\n      sum -= f * Math.pow(256, len - i - 1)\n  }\n  return sum\n}\n\nconst pos = (buf) => {\n  var len = buf.length\n  var sum = 0\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i]\n    if (byte !== 0)\n      sum += byte * Math.pow(256, len - i - 1)\n  }\n  return sum\n}\n\nconst onesComp = byte => (0xff ^ byte) & 0xff\n\nconst twosComp = byte => ((0xff ^ byte) + 1) & 0xff\n","'use strict'\nmodule.exports = (mode, isDir) => {\n  mode &= 0o7777\n  // if dirs are readable, then they should be listable\n  if (isDir) {\n    if (mode & 0o400)\n      mode |= 0o100\n    if (mode & 0o40)\n      mode |= 0o10\n    if (mode & 0o4)\n      mode |= 0o1\n  }\n  return mode\n}\n","'use strict'\n\n// tar -u\n\nconst hlo = require('./high-level-opt.js')\nconst r = require('./replace.js')\n// just call tar.r with the filter and mtimeCache\n\nconst u = module.exports = (opt_, files, cb) => {\n  const opt = hlo(opt_)\n\n  if (!opt.file)\n    throw new TypeError('file is required')\n\n  if (opt.gzip)\n    throw new TypeError('cannot append to compressed archives')\n\n  if (!files || !Array.isArray(files) || !files.length)\n    throw new TypeError('no files or directories specified')\n\n  files = Array.from(files)\n\n  mtimeFilter(opt)\n  return r(opt, files, cb)\n}\n\nconst mtimeFilter = opt => {\n  const filter = opt.filter\n\n  if (!opt.mtimeCache)\n    opt.mtimeCache = new Map()\n\n  opt.filter = filter ? (path, stat) =>\n    filter(path, stat) && !(opt.mtimeCache.get(path) > stat.mtime)\n    : (path, stat) => !(opt.mtimeCache.get(path) > stat.mtime)\n}\n","'use strict'\n\n// tar -x\nconst hlo = require('./high-level-opt.js')\nconst Unpack = require('./unpack.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst path = require('path')\n\nconst x = module.exports = (opt_, files, cb) => {\n  if (typeof opt_ === 'function')\n    cb = opt_, files = null, opt_ = {}\n  else if (Array.isArray(opt_))\n    files = opt_, opt_ = {}\n\n  if (typeof files === 'function')\n    cb = files, files = null\n\n  if (!files)\n    files = []\n  else\n    files = Array.from(files)\n\n  const opt = hlo(opt_)\n\n  if (opt.sync && typeof cb === 'function')\n    throw new TypeError('callback not supported for sync tar functions')\n\n  if (!opt.file && typeof cb === 'function')\n    throw new TypeError('callback only supported with file option')\n\n  if (files.length)\n    filesFilter(opt, files)\n\n  return opt.file && opt.sync ? extractFileSync(opt)\n    : opt.file ? extractFile(opt, cb)\n    : opt.sync ? extractSync(opt)\n    : extract(opt)\n}\n\n// construct a filter that limits the file entries listed\n// include child entries if a dir is included\nconst filesFilter = (opt, files) => {\n  const map = new Map(files.map(f => [f.replace(/\\/+$/, ''), true]))\n  const filter = opt.filter\n\n  const mapHas = (file, r) => {\n    const root = r || path.parse(file).root || '.'\n    const ret = file === root ? false\n      : map.has(file) ? map.get(file)\n      : mapHas(path.dirname(file), root)\n\n    map.set(file, ret)\n    return ret\n  }\n\n  opt.filter = filter\n    ? (file, entry) => filter(file, entry) && mapHas(file.replace(/\\/+$/, ''))\n    : file => mapHas(file.replace(/\\/+$/, ''))\n}\n\nconst extractFileSync = opt => {\n  const u = new Unpack.Sync(opt)\n\n  const file = opt.file\n  let threw = true\n  let fd\n  const stat = fs.statSync(file)\n  // This trades a zero-byte read() syscall for a stat\n  // However, it will usually result in less memory allocation\n  const readSize = opt.maxReadSize || 16*1024*1024\n  const stream = new fsm.ReadStreamSync(file, {\n    readSize: readSize,\n    size: stat.size\n  })\n  stream.pipe(u)\n}\n\nconst extractFile = (opt, cb) => {\n  const u = new Unpack(opt)\n  const readSize = opt.maxReadSize || 16*1024*1024\n\n  const file = opt.file\n  const p = new Promise((resolve, reject) => {\n    u.on('error', reject)\n    u.on('close', resolve)\n\n    // This trades a zero-byte read() syscall for a stat\n    // However, it will usually result in less memory allocation\n    fs.stat(file, (er, stat) => {\n      if (er)\n        reject(er)\n      else {\n        const stream = new fsm.ReadStream(file, {\n          readSize: readSize,\n          size: stat.size\n        })\n        stream.on('error', reject)\n        stream.pipe(u)\n      }\n    })\n  })\n  return cb ? p.then(cb, cb) : p\n}\n\nconst extractSync = opt => {\n  return new Unpack.Sync(opt)\n}\n\nconst extract = opt => {\n  return new Unpack(opt)\n}\n","'use strict'\n// wrapper around mkdirp for tar's needs.\n\n// TODO: This should probably be a class, not functionally\n// passing around state in a gazillion args.\n\nconst mkdirp = require('mkdirp')\nconst fs = require('fs')\nconst path = require('path')\nconst chownr = require('chownr')\n\nclass SymlinkError extends Error {\n  constructor (symlink, path) {\n    super('Cannot extract through symbolic link')\n    this.path = path\n    this.symlink = symlink\n  }\n\n  get name () {\n    return 'SylinkError'\n  }\n}\n\nclass CwdError extends Error {\n  constructor (path, code) {\n    super(code + ': Cannot cd into \\'' + path + '\\'')\n    this.path = path\n    this.code = code\n  }\n\n  get name () {\n    return 'CwdError'\n  }\n}\n\nconst mkdir = module.exports = (dir, opt, cb) => {\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  const umask = opt.umask\n  const mode = opt.mode | 0o0700\n  const needChmod = (mode & umask) !== 0\n\n  const uid = opt.uid\n  const gid = opt.gid\n  const doChown = typeof uid === 'number' &&\n    typeof gid === 'number' &&\n    ( uid !== opt.processUid || gid !== opt.processGid )\n\n  const preserve = opt.preserve\n  const unlink = opt.unlink\n  const cache = opt.cache\n  const cwd = opt.cwd\n\n  const done = (er, created) => {\n    if (er)\n      cb(er)\n    else {\n      cache.set(dir, true)\n      if (created && doChown)\n        chownr(created, uid, gid, er => done(er))\n      else if (needChmod)\n        fs.chmod(dir, mode, cb)\n      else\n        cb()\n    }\n  }\n\n  if (cache && cache.get(dir) === true)\n    return done()\n\n  if (dir === cwd)\n    return fs.stat(dir, (er, st) => {\n      if (er || !st.isDirectory())\n        er = new CwdError(dir, er && er.code || 'ENOTDIR')\n      done(er)\n    })\n\n  if (preserve)\n    return mkdirp(dir, mode, done)\n\n  const sub = path.relative(cwd, dir)\n  const parts = sub.split(/\\/|\\\\/)\n  mkdir_(cwd, parts, mode, cache, unlink, cwd, null, done)\n}\n\nconst mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {\n  if (!parts.length)\n    return cb(null, created)\n  const p = parts.shift()\n  const part = base + '/' + p\n  if (cache.get(part))\n    return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n  fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))\n}\n\nconst onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => er => {\n  if (er) {\n    if (er.path && path.dirname(er.path) === cwd &&\n        (er.code === 'ENOTDIR' || er.code === 'ENOENT'))\n      return cb(new CwdError(cwd, er.code))\n\n    fs.lstat(part, (statEr, st) => {\n      if (statEr)\n        cb(statEr)\n      else if (st.isDirectory())\n        mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n      else if (unlink)\n        fs.unlink(part, er => {\n          if (er)\n            return cb(er)\n          fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))\n        })\n      else if (st.isSymbolicLink())\n        return cb(new SymlinkError(part, part + '/' + parts.join('/')))\n      else\n        cb(er)\n    })\n  } else {\n    created = created || part\n    mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n  }\n}\n\nconst mkdirSync = module.exports.sync = (dir, opt) => {\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  const umask = opt.umask\n  const mode = opt.mode | 0o0700\n  const needChmod = (mode & umask) !== 0\n\n  const uid = opt.uid\n  const gid = opt.gid\n  const doChown = typeof uid === 'number' &&\n    typeof gid === 'number' &&\n    ( uid !== opt.processUid || gid !== opt.processGid )\n\n  const preserve = opt.preserve\n  const unlink = opt.unlink\n  const cache = opt.cache\n  const cwd = opt.cwd\n\n  const done = (created) => {\n    cache.set(dir, true)\n    if (created && doChown)\n      chownr.sync(created, uid, gid)\n    if (needChmod)\n      fs.chmodSync(dir, mode)\n  }\n\n  if (cache && cache.get(dir) === true)\n    return done()\n\n  if (dir === cwd) {\n    let ok = false\n    let code = 'ENOTDIR'\n    try {\n      ok = fs.statSync(dir).isDirectory()\n    } catch (er) {\n      code = er.code\n    } finally {\n      if (!ok)\n        throw new CwdError(dir, code)\n    }\n    done()\n    return\n  }\n\n  if (preserve)\n    return done(mkdirp.sync(dir, mode))\n\n  const sub = path.relative(cwd, dir)\n  const parts = sub.split(/\\/|\\\\/)\n  let created = null\n  for (let p = parts.shift(), part = cwd;\n       p && (part += '/' + p);\n       p = parts.shift()) {\n\n    if (cache.get(part))\n      continue\n\n    try {\n      fs.mkdirSync(part, mode)\n      created = created || part\n      cache.set(part, true)\n    } catch (er) {\n      if (er.path && path.dirname(er.path) === cwd &&\n          (er.code === 'ENOTDIR' || er.code === 'ENOENT'))\n        return new CwdError(cwd, er.code)\n\n      const st = fs.lstatSync(part)\n      if (st.isDirectory()) {\n        cache.set(part, true)\n        continue\n      } else if (unlink) {\n        fs.unlinkSync(part)\n        fs.mkdirSync(part, mode)\n        created = created || part\n        cache.set(part, true)\n        continue\n      } else if (st.isSymbolicLink())\n        return new SymlinkError(part, part + '/' + parts.join('/'))\n    }\n  }\n\n  return done(created)\n}\n","var path = require('path');\nvar fs = require('fs');\nvar _0777 = parseInt('0777', 8);\n\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\n\nfunction mkdirP (p, opts, f, made) {\n    if (typeof opts === 'function') {\n        f = opts;\n        opts = {};\n    }\n    else if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n    \n    var cb = f || function () {};\n    p = path.resolve(p);\n    \n    xfs.mkdir(p, mode, function (er) {\n        if (!er) {\n            made = made || p;\n            return cb(null, made);\n        }\n        switch (er.code) {\n            case 'ENOENT':\n                mkdirP(path.dirname(p), opts, function (er, made) {\n                    if (er) cb(er, made);\n                    else mkdirP(p, opts, cb, made);\n                });\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                xfs.stat(p, function (er2, stat) {\n                    // if the stat fails, then that's super weird.\n                    // let the original error be the failure reason.\n                    if (er2 || !stat.isDirectory()) cb(er, made)\n                    else cb(null, made);\n                });\n                break;\n        }\n    });\n}\n\nmkdirP.sync = function sync (p, opts, made) {\n    if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n\n    p = path.resolve(p);\n\n    try {\n        xfs.mkdirSync(p, mode);\n        made = made || p;\n    }\n    catch (err0) {\n        switch (err0.code) {\n            case 'ENOENT' :\n                made = sync(path.dirname(p), opts, made);\n                sync(p, opts, made);\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                var stat;\n                try {\n                    stat = xfs.statSync(p);\n                }\n                catch (err1) {\n                    throw err0;\n                }\n                if (!stat.isDirectory()) throw err0;\n                break;\n        }\n    }\n\n    return made;\n};\n","'use strict'\nconst fs = require('fs')\nconst path = require('path')\n\n/* istanbul ignore next */\nconst LCHOWN = fs.lchown ? 'lchown' : 'chown'\n/* istanbul ignore next */\nconst LCHOWNSYNC = fs.lchownSync ? 'lchownSync' : 'chownSync'\n\nconst needEISDIRHandled = fs.lchown &&\n  !process.version.match(/v1[1-9]+\\./) &&\n  !process.version.match(/v10\\.[6-9]/)\n\n/* istanbul ignore next */\nconst handleEISDIR =\n  needEISDIRHandled ? (path, uid, gid, cb) => er => {\n    // Node prior to v10 had a very questionable implementation of\n    // fs.lchown, which would always try to call fs.open on a directory\n    // Fall back to fs.chown in those cases.\n    if (!er || er.code !== 'EISDIR')\n      cb(er)\n    else\n      fs.chown(path, uid, gid, cb)\n  }\n  : (_, __, ___, cb) => cb\n\n/* istanbul ignore next */\nconst handleEISDirSync =\n  needEISDIRHandled ? (path, uid, gid) => {\n    try {\n      return fs[LCHOWNSYNC](path, uid, gid)\n    } catch (er) {\n      if (er.code !== 'EISDIR')\n        throw er\n      fs.chownSync(path, uid, gid)\n    }\n  }\n  : fs[LCHOWNSYNC]\n\n// fs.readdir could only accept an options object as of node v6\nconst nodeVersion = process.version\nlet readdir = (path, options, cb) => fs.readdir(path, options, cb)\nlet readdirSync = (path, options) => fs.readdirSync(path, options)\n/* istanbul ignore next */\nif (/^v4\\./.test(nodeVersion))\n  readdir = (path, options, cb) => fs.readdir(path, cb)\n\nconst chownrKid = (p, child, uid, gid, cb) => {\n  if (typeof child === 'string')\n    return fs.lstat(path.resolve(p, child), (er, stats) => {\n      if (er)\n        return cb(er)\n      stats.name = child\n      chownrKid(p, stats, uid, gid, cb)\n    })\n\n  if (child.isDirectory()) {\n    chownr(path.resolve(p, child.name), uid, gid, er => {\n      if (er)\n        return cb(er)\n      const cpath = path.resolve(p, child.name)\n      fs[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, cb))\n    })\n  } else {\n    const cpath = path.resolve(p, child.name)\n    fs[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, cb))\n  }\n}\n\n\nconst chownr = (p, uid, gid, cb) => {\n  readdir(p, { withFileTypes: true }, (er, children) => {\n    // any error other than ENOTDIR or ENOTSUP means it's not readable,\n    // or doesn't exist.  give up.\n    if (er && er.code !== 'ENOTDIR' && er.code !== 'ENOTSUP')\n      return cb(er)\n    if (er || !children.length)\n      return fs[LCHOWN](p, uid, gid, handleEISDIR(p, uid, gid, cb))\n\n    let len = children.length\n    let errState = null\n    const then = er => {\n      if (errState)\n        return\n      if (er)\n        return cb(errState = er)\n      if (-- len === 0)\n        return fs[LCHOWN](p, uid, gid, handleEISDIR(p, uid, gid, cb))\n    }\n\n    children.forEach(child => chownrKid(p, child, uid, gid, then))\n  })\n}\n\nconst chownrKidSync = (p, child, uid, gid) => {\n  if (typeof child === 'string') {\n    const stats = fs.lstatSync(path.resolve(p, child))\n    stats.name = child\n    child = stats\n  }\n\n  if (child.isDirectory())\n    chownrSync(path.resolve(p, child.name), uid, gid)\n\n  handleEISDirSync(path.resolve(p, child.name), uid, gid)\n}\n\nconst chownrSync = (p, uid, gid) => {\n  let children\n  try {\n    children = readdirSync(p, { withFileTypes: true })\n  } catch (er) {\n    if (er && er.code === 'ENOTDIR' && er.code !== 'ENOTSUP')\n      return handleEISDirSync(p, uid, gid)\n    throw er\n  }\n\n  if (children.length)\n    children.forEach(child => chownrKidSync(p, child, uid, gid))\n\n  return handleEISDirSync(p, uid, gid)\n}\n\nmodule.exports = chownr\nchownr.sync = chownrSync\n","module.exports = require(\"crypto\");","module.exports = require(\"vm\");","\n // tslint:disable:max-line-length\n/**\n * Handling of types in JSII\n *\n * Types will be serialized according to the following table:\n *\n *                         ┬───────────────────────────────────────────────────────────────────────────────────────────────┐\n *                         │ JAVASCRIPT TYPE                                                                               │\n *                         ┼────────────────┬───────────┬────────────┬───────────────┬───────────────────┬─────────────────┤\n *                         │ undefined/null │   date    │ scalar (*) │     array     │ JSII-class object │ literal object  │\n * ├──────────┼────────────┼────────────────┼───────────┼────────────┼───────────────┼───────────────────┼─────────────────┤\n * │ DECLARED │ void       │ undefined      │ undefined │ undefined  │ undefined     │ undefined         │ undefined       │\n * │ TYPE     │ date       │ undefined(†)   │ { date }  │ -          │ -             │ -                 │ -               │\n * │          │ scalar (*) │ undefined(†)   │ -         │ value      │ -             │ -                 │ -               │\n * │          │ json       │ undefined      │ string    │ value      │ array/R(json) │ -                 │ byvalue/R(json) │\n * │          │ enum       │ undefined(†)   │ -         │ { enum }   │ -             │ -                 │ -               │\n * │          │ array of T │ undefined(†)   │ -         │ -          │ array/R(T)    │ -                 │ -               │\n * │          │ map of T   │ undefined(†)   │ -         │ -          │ -             │ -                 │ byvalue/R(T)    │\n * │          │ interface  │ undefined(†)   │ -         │ -          │ -             │ { ref }           │ { ref: proxy }  │\n * │          │ struct     │ undefined(†)   │ -         │ -          │ -             │ -                 │ byvalue/R(T[k]) │\n * │          │ class      │ undefined(†)   │ -         │ -          │ -             │ { ref }           │ { ref: proxy }  │\n * │          │ any        │ undefined      │ { date }  │ value      │ array/R(any)  │ { ref }           │ byvalue/R(any)  │\n * └──────────┴────────────┴────────────────┴───────────┴────────────┴───────────────┴───────────────────┴─────────────────┘\n *\n *  - (*) scalar means 'string | number | boolean'\n *  - (†) throw if not nullable\n *  - /R(t) recurse with declared type t\n */\n\n // tslint:enable:max-line-length\n\nimport * as spec from 'jsii-spec';\nimport { isObjRef, isWireDate, isWireEnum, ObjRef, TOKEN_DATE, TOKEN_ENUM, WireDate, WireEnum } from './api';\nimport { hiddenMap, jsiiTypeFqn, objectReference, ObjectTable } from './objects';\n\n/**\n * A specific singleton type to be explicit about a Void type\n *\n * In the spec, 'void' is represented as 'undefined'(*), but allowing the\n * value 'undefined' in function calls has lead to consumers failing to pass\n * type information that they had, just because they didn't \"have to\" (the\n * parameter was optional).\n *\n * (*) As in, declaration of a method looks like { returns?: TypeReference }\n * and the absence of a type means it returns 'void'.\n */\nexport type Void = 'void';\n\n/**\n * A type instance, or Void\n */\nexport type OptionalValueOrVoid = spec.OptionalValue | Void;\n\n/**\n * A special FQN that can be used to create empty javascript objects.\n */\nexport const EMPTY_OBJECT_FQN = 'Object';\n\n/**\n * The type kind, that controls how it will be serialized according to the above table\n */\nexport const enum SerializationClass {\n  Void = 'Void',\n  Date = 'Date',\n  Scalar = 'Scalar',\n  Json = 'Json',\n  Enum = 'Enum',\n  Array = 'Array',\n  Map = 'Map',\n  Struct = 'Struct',\n  ReferenceType = 'RefType',\n  Any = 'Any',\n}\n\ntype TypeLookup = (fqn: spec.FQN) => spec.Type;\ntype SymbolLookup = (fqn: spec.FQN) => any;\n\nexport interface SerializerHost {\n  readonly objects: ObjectTable;\n  debug(...args: any[]): void;\n  lookupType(fqn: string): spec.Type;\n  recurse(x: any, type: OptionalValueOrVoid): any;\n  findSymbol(fqn: spec.FQN): any;\n}\n\ninterface Serializer {\n  serialize(value: unknown, type: OptionalValueOrVoid, host: SerializerHost): any;\n  deserialize(value: unknown, type: OptionalValueOrVoid, host: SerializerHost): any;\n}\n\nexport const SERIALIZERS: {[k: string]: Serializer} = {\n  // ----------------------------------------------------------------------\n  [SerializationClass.Void]: {\n    serialize(value, _type, host) {\n      if (value != null) {\n        host.debug('Expected void, got', value);\n      }\n      return undefined;\n    },\n\n    deserialize(value, _type, host) {\n      if (value != null) {\n        host.debug('Expected void, got', value);\n      }\n      return undefined;\n    },\n  },\n\n  // ----------------------------------------------------------------------\n  [SerializationClass.Date]: {\n    serialize(value, optionalValue): WireDate | undefined {\n      if (nullAndOk(value, optionalValue)) { return undefined; }\n      if (optionalValue === 'void') { throw new Error('Encountered unexpected `void` type'); }\n\n      if (!isDate(value)) {\n        throw new Error(`Expected Date, got ${JSON.stringify(value)}`);\n      }\n      return serializeDate(value);\n    },\n\n    deserialize(value, optionalValue) {\n      if (nullAndOk(value, optionalValue)) { return undefined; }\n\n      if (!isWireDate(value)) {\n        throw new Error(`Expected Date, got ${JSON.stringify(value)}`);\n      }\n      return deserializeDate(value);\n    },\n  },\n\n  // ----------------------------------------------------------------------\n  [SerializationClass.Scalar]: {\n    serialize(value, optionalValue) {\n      if (nullAndOk(value, optionalValue)) { return undefined; }\n      if (optionalValue === 'void') { throw new Error('Encountered unexpected `void` type'); }\n\n      const primitiveType = optionalValue.type as spec.PrimitiveTypeReference;\n\n      if (!isScalar(value)) {\n        throw new Error(`Expected Scalar, got ${JSON.stringify(value)}`);\n      }\n      if (typeof value !== primitiveType.primitive) {\n        throw new Error(`Expected '${primitiveType.primitive}', got ${JSON.stringify(value)} (${typeof value})`);\n      }\n      return value;\n    },\n\n    deserialize(value, optionalValue) {\n      if (nullAndOk(value, optionalValue)) { return undefined; }\n      if (optionalValue === 'void') { throw new Error('Encountered unexpected `void` type'); }\n\n      const primitiveType = optionalValue.type as spec.PrimitiveTypeReference;\n\n      if (!isScalar(value)) {\n        throw new Error(`Expected Scalar, got ${JSON.stringify(value)}`);\n      }\n      if (typeof value !== primitiveType.primitive) {\n        throw new Error(`Expected '${primitiveType.primitive}', got ${JSON.stringify(value)} (${typeof value})`);\n      }\n\n      return value;\n    },\n  },\n\n  // ----------------------------------------------------------------------\n  [SerializationClass.Json]: {\n    serialize(value) {\n      // Just whatever. Dates will automatically serialize themselves to strings.\n      return value;\n    },\n    deserialize(value, optionalValue) {\n      // /!\\ Top-level \"null\" will turn to undefined, but any null nested in the value is valid JSON, so it'll stay!\n      if (nullAndOk(value, optionalValue)) { return undefined; }\n      return value;\n    },\n  },\n\n  // ----------------------------------------------------------------------\n  [SerializationClass.Enum]: {\n    serialize(value, optionalValue, host): WireEnum | undefined {\n      if (nullAndOk(value, optionalValue)) { return undefined; }\n      if (optionalValue === 'void') { throw new Error('Encountered unexpected `void` type'); }\n\n      if (typeof value !== 'string' && typeof value !== 'number') {\n        throw new Error(`Expected enum value, got ${JSON.stringify(value)}`);\n      }\n\n      host.debug('Serializing enum');\n\n      const enumType = optionalValue.type as spec.NamedTypeReference;\n      const enumMap = host.findSymbol(enumType.fqn);\n      const enumEntry = Object.entries(enumMap).find(([, v]) => v === value);\n      if (!enumEntry) {\n        throw new Error(`No entry in ${enumType.fqn} has value ${value}`);\n      }\n      return { [TOKEN_ENUM]: `${enumType.fqn}/${enumEntry[0]}` };\n    },\n    deserialize(value, optionalValue, host) {\n      if (nullAndOk(value, optionalValue)) { return undefined; }\n\n      if (!isWireEnum(value)) {\n        throw new Error(`Expected enum value, got ${JSON.stringify(value)}`);\n      }\n\n      return deserializeEnum(value, host.findSymbol);\n    },\n  },\n\n  // ----------------------------------------------------------------------\n  [SerializationClass.Array]: {\n    serialize(value, optionalValue, host) {\n      if (nullAndOk(value, optionalValue)) { return undefined; }\n      if (optionalValue === 'void') { throw new Error('Encountered unexpected `void` type'); }\n\n      if (!Array.isArray(value)) {\n        throw new Error(`Expected array type, got ${JSON.stringify(value)}`);\n      }\n\n      const arrayType = optionalValue.type as spec.CollectionTypeReference;\n\n      return value.map(x => host.recurse(x, { type: arrayType.collection.elementtype }));\n    },\n    deserialize(value, optionalValue, host) {\n      if (nullAndOk(value, optionalValue)) { return undefined; }\n      if (optionalValue === 'void') { throw new Error('Encountered unexpected `void` type'); }\n\n      if (!Array.isArray(value)) {\n        throw new Error(`Expected array type, got ${JSON.stringify(value)}`);\n      }\n\n      const arrayType = optionalValue.type as spec.CollectionTypeReference;\n\n      return value.map(x => host.recurse(x, { type: arrayType.collection.elementtype }));\n    },\n  },\n\n  // ----------------------------------------------------------------------\n  [SerializationClass.Map]: {\n    serialize(value, optionalValue, host) {\n      if (nullAndOk(value, optionalValue)) { return undefined; }\n      if (optionalValue === 'void') { throw new Error('Encountered unexpected `void` type'); }\n\n      const mapType = optionalValue.type as spec.CollectionTypeReference;\n      return mapValues(value, v => host.recurse(v, { type: mapType.collection.elementtype }));\n    },\n    deserialize(value, optionalValue, host) {\n      if (nullAndOk(value, optionalValue)) { return undefined; }\n      if (optionalValue === 'void') { throw new Error('Encountered unexpected `void` type'); }\n\n      const mapType = optionalValue.type as spec.CollectionTypeReference;\n      return mapValues(value, v => host.recurse(v, { type: mapType.collection.elementtype }));\n    },\n  },\n\n  // ----------------------------------------------------------------------\n  [SerializationClass.Struct]: {\n    serialize(value, optionalValue, host) {\n      if (nullAndOk(value, optionalValue)) { return undefined; }\n      if (optionalValue === 'void') { throw new Error('Encountered unexpected `void` type'); }\n\n      if (typeof value !== 'object' || value == null) {\n        throw new Error(`Expected object, got ${JSON.stringify(value)}`);\n      }\n\n      // This looks odd, but if an object was originally passed in/out as a by-ref\n      // class, and it happens to conform to a datatype interface we say we're\n      // returning, return the actual object instead of the serialized value.\n      // NOTE: Not entirely sure yet whether this is a bug masquerading as a\n      // feature or not.\n      const prevRef = objectReference(value);\n      if (prevRef) { return prevRef; }\n\n      /*\n        This is what we'd like to do, but we can't because at least the Java client\n        does not understand by-value serialized interface types, so we'll have to\n        serialize by-reference for now:\n        https://github.com/aws/jsii/issues/400\n\n      const props = propertiesOf(namedType);\n\n      return mapValues(value, (v, key) => {\n        if (!props[key]) { return undefined; } // Don't map if unknown property\n        return host.recurse(v, props[key].type);\n      });\n      */\n\n      host.debug('Returning value type as reference type for now (awslabs/jsii#400)');\n      const wireFqn = selectWireType(value, optionalValue.type as spec.NamedTypeReference, host.lookupType);\n      return host.objects.registerObject(value, wireFqn);\n    },\n    deserialize(value, optionalValue, host) {\n      if (typeof value === 'object' && Object.keys(value || {}).length === 0) {\n        // Treat empty structs as `undefined` (see https://github.com/aws/jsii/issues/411)\n        value = undefined;\n      }\n      if (nullAndOk(value, optionalValue)) { return undefined; }\n      if (optionalValue === 'void') { throw new Error('Encountered unexpected `void` type'); }\n\n      if (typeof value !== 'object' || value == null) {\n        throw new Error(`Expected object reference, got ${JSON.stringify(value)}`);\n      }\n\n      const namedType = host.lookupType((optionalValue.type as spec.NamedTypeReference).fqn);\n      const props = propertiesOf(namedType, host.lookupType);\n\n      if (Array.isArray(value)) {\n        throw new Error(`Got an array where a ${namedType.fqn} was expected. Did you mean to pass a variable number of arguments?`);\n      }\n\n      // Similarly to serialization, we might be getting a reference type where we're\n      // expecting a value type. Accept this for now (but also validate that object\n      // for presence of the right properties).\n      if (isObjRef(value)) {\n        host.debug('Expected value type but got reference type, accepting for now (awslabs/jsii#400)');\n\n        // Return same INSTANCE (shouldn't matter but we don't know for sure that it doesn't)\n        return validateRequiredProps(\n          host.objects.findObject(value).instance,\n          namedType.fqn,\n          props);\n      }\n\n      value = validateRequiredProps(value, namedType.fqn, props);\n\n      // Return a dict COPY, we have by-value semantics anyway.\n      return mapValues(value, (v, key) => {\n        if (!props[key]) { return undefined; } // Don't map if unknown property\n        return host.recurse(v, props[key]);\n      });\n    },\n  },\n\n  // ----------------------------------------------------------------------\n  [SerializationClass.ReferenceType]: {\n    serialize(value, optionalValue, host): ObjRef | undefined {\n      if (nullAndOk(value, optionalValue)) { return undefined; }\n      if (optionalValue === 'void') { throw new Error('Encountered unexpected `void` type'); }\n\n      if (typeof value !== 'object' || value == null) {\n        throw new Error(`Expected object reference, got ${JSON.stringify(value)}`);\n      }\n\n      const prevRef = objectReference(value);\n      if (prevRef) { return prevRef; }\n\n      const wireFqn = selectWireType(value, optionalValue.type as spec.NamedTypeReference, host.lookupType);\n      return host.objects.registerObject(value, wireFqn);\n    },\n    deserialize(value, optionalValue, host) {\n      if (nullAndOk(value, optionalValue)) { return undefined; }\n      if (optionalValue === 'void') { throw new Error('Encountered unexpected `void` type'); }\n\n      // The only way to pass a by-ref object is to have created it\n      // previously inside JSII kernel, so it must have an objref already.\n\n      if (!isObjRef(value)) {\n        throw new Error(`Expected object reference, got ${JSON.stringify(value)}`);\n      }\n\n      const { instance, fqn } = host.objects.findObject(value);\n\n      const namedTypeRef = optionalValue.type as spec.NamedTypeReference;\n      if (namedTypeRef.fqn !== EMPTY_OBJECT_FQN) {\n        const namedType = host.lookupType(namedTypeRef.fqn);\n\n        // Check that the object we got is of the right type\n        // We only do this for classes, not interfaces, since Java might pass us objects that\n        // privately implement some interface and we can't prove they don't.\n        // https://github.com/aws/jsii/issues/399\n        const declaredType = optionalValue.type as spec.NamedTypeReference;\n        if (spec.isClassType(namedType) && !isAssignable(fqn, declaredType, host.lookupType)) {\n          throw new Error(`Object of type ${fqn} is not convertible to ${declaredType.fqn}`);\n        }\n      }\n\n      return instance;\n    },\n  },\n\n  // ----------------------------------------------------------------------\n  [SerializationClass.Any]: {\n    serialize(value, _type, host) {\n      if (value == null) { return undefined; }\n\n      if (isDate(value)) { return serializeDate(value); }\n      if (isScalar(value)) { return value; }\n      if (Array.isArray(value)) {\n        return value.map(e => host.recurse(e, { type: spec.CANONICAL_ANY }));\n      }\n\n      // Note: no case for \"ENUM\" here, without type declaration we can't tell the difference\n      // between an enum member and a scalar.\n\n      if (typeof value !== 'object' || value == null) {\n        throw new Error(`JSII kernel assumption violated, ${JSON.stringify(value)} is not an object`);\n      }\n\n      // To make sure people aren't going to try and return Map<> or Set<> out, test for\n      // those and throw a descriptive error message. We can't detect these cases any other\n      // way, and the by-value serialized object will be quite useless.\n      if (value instanceof Set || value instanceof Map) { throw new Error(`Can't return objects of type Set or Map`); }\n\n      // Use a previous reference to maintain object identity. NOTE: this may cause us to return\n      // a different type than requested! This is just how it is right now.\n      // https://github.com/aws/jsii/issues/399\n      const prevRef = objectReference(value);\n      if (prevRef) { return prevRef; }\n\n      // If this is or should be a reference type, pass or make the reference\n      // (Like regular reftype serialization, but without the type derivation to an interface)\n      const jsiiType = jsiiTypeFqn(value);\n      if (jsiiType) { return host.objects.registerObject(value, jsiiType); }\n\n      // At this point we have an object that is not of an exported type. Either an object\n      // literal, or an instance of a fully private class (cannot distinguish those cases).\n\n      // We will serialize by-value, but recurse for serialization so that if\n      // the object contains reference objects, they will be serialized appropriately.\n      // (Basically, serialize anything else as a map of 'any').\n      return mapValues(value, (v) => host.recurse(v, { type: spec.CANONICAL_ANY }));\n    },\n\n    deserialize(value, _type, host) {\n      if (value == null) { return undefined; }\n\n      if (isWireDate(value)) {\n        host.debug('ANY is a Date');\n        return deserializeDate(value);\n      }\n      if (isScalar(value)) {\n        host.debug('ANY is a Scalar');\n        return value;\n      }\n      if (Array.isArray(value)) {\n        host.debug('ANY is an Array');\n        return value.map(e => host.recurse(e, { type: spec.CANONICAL_ANY }));\n      }\n\n      if (isWireEnum(value)) {\n        host.debug('ANY is an Enum');\n        return deserializeEnum(value, host.findSymbol);\n      }\n      if (isObjRef(value)) {\n        host.debug('ANY is a Ref');\n        return host.objects.findObject(value).instance;\n      }\n\n      // At this point again, deserialize by-value.\n      host.debug('ANY is a Map');\n      return mapValues(value, (v) => host.recurse(v, { type: spec.CANONICAL_ANY }));\n    },\n  },\n};\n\nfunction serializeDate(value: Date): WireDate {\n  return { [TOKEN_DATE]: value.toISOString() };\n}\n\nfunction deserializeDate(value: WireDate): Date {\n  return new Date(value[TOKEN_DATE]);\n}\n\nfunction deserializeEnum(value: WireEnum, lookup: SymbolLookup) {\n  const enumLocator = value[TOKEN_ENUM] as string;\n  const sep = enumLocator.lastIndexOf('/');\n  if (sep === -1) {\n      throw new Error(`Malformed enum value: ${JSON.stringify(value)}`);\n  }\n\n  const typeName = enumLocator.substr(0, sep);\n  const valueName = enumLocator.substr(sep + 1);\n\n  const enumValue = lookup(typeName)[valueName];\n  if (enumValue === undefined) {\n      throw new Error(`No enum member named ${valueName} in ${typeName}`);\n  }\n  return enumValue;\n}\n\nexport interface TypeSerialization {\n  serializationClass: SerializationClass;\n  typeRef: OptionalValueOrVoid;\n}\n\n/**\n * From a type reference, return the possible serialization types\n *\n * There can be multiple, because the type can be a type union.\n */\nexport function serializationType(typeRef: OptionalValueOrVoid, lookup: TypeLookup): TypeSerialization[] {\n  if (typeRef == null) { throw new Error(`Kernel error: expected type information, got 'undefined'`); }\n  if (typeRef === 'void') { return [{ serializationClass: SerializationClass.Void, typeRef }]; }\n  if (spec.isPrimitiveTypeReference(typeRef.type)) {\n    switch (typeRef.type.primitive) {\n      case spec.PrimitiveType.Any: return [{ serializationClass: SerializationClass.Any, typeRef }];\n      case spec.PrimitiveType.Date: return [{ serializationClass: SerializationClass.Date, typeRef }];\n      case spec.PrimitiveType.Json: return [{ serializationClass: SerializationClass.Json, typeRef }];\n      case spec.PrimitiveType.Boolean:\n      case spec.PrimitiveType.Number:\n      case spec.PrimitiveType.String:\n        return [{ serializationClass: SerializationClass.Scalar, typeRef }];\n    }\n\n    throw new Error('Unknown primitive type');\n  }\n  if (spec.isCollectionTypeReference(typeRef.type)) {\n    return [{\n      serializationClass: typeRef.type.collection.kind === spec.CollectionKind.Array ? SerializationClass.Array : SerializationClass.Map,\n      typeRef\n    }];\n  }\n  if (spec.isUnionTypeReference(typeRef.type)) {\n    const compoundTypes = flatMap(typeRef.type.union.types, t => serializationType({ type: t }, lookup));\n    // Propagate the top-level 'optional' field to each individual subtype\n    for (const t of compoundTypes) {\n      if (t.typeRef !== 'void') {\n        t.typeRef.optional = typeRef.optional;\n      }\n    }\n    return compoundTypes;\n  }\n\n  // The next part of the conversion is lookup-dependent\n  const type = lookup(typeRef.type.fqn);\n\n  if (spec.isEnumType(type)) {\n    return [{ serializationClass: SerializationClass.Enum, typeRef }];\n  }\n\n  if (spec.isInterfaceType(type) && type.datatype) {\n    return [{ serializationClass: SerializationClass.Struct, typeRef }];\n  }\n\n  return [{ serializationClass: SerializationClass.ReferenceType, typeRef }];\n}\n\nfunction nullAndOk(x: unknown, type: OptionalValueOrVoid): boolean {\n  if (x != null) { return false; }\n\n  if (type !== 'void' && !type.optional) {\n    throw new Error(`Got 'undefined' for non-optional instance of ${JSON.stringify(type)}`);\n  }\n\n  return true;\n}\n\nfunction isDate(x: unknown): x is Date {\n  return typeof x === 'object' && Object.prototype.toString.call(x) === '[object Date]';\n}\n\nfunction isScalar(x: unknown): x is string | number | boolean {\n  return typeof x === 'string' || typeof x === 'number' || typeof x === 'boolean';\n}\n\nfunction flatMap<T, U>(xs: T[], fn: (x: T) => U[]): U[] {\n  const ret = new Array<U>();\n  for (const x of xs) { ret.push(...fn(x)); }\n  return ret;\n}\n\n/**\n * Map an object's values, skipping 'undefined' values'\n */\nfunction mapValues(value: unknown, fn: (value: any, field: string) => any) {\n  if (typeof value !== 'object' || value == null) {\n    throw new Error(`Expected object type, got ${JSON.stringify(value)}`);\n  }\n\n  const out: any = { };\n  for (const [k, v] of Object.entries(value)) {\n    const wireValue = fn(v, k);\n    if (wireValue === undefined) { continue; }\n    out[k] = wireValue;\n  }\n  return out;\n}\n\nfunction propertiesOf(t: spec.Type, lookup: TypeLookup): {[name: string]: spec.Property} {\n  if (!spec.isClassOrInterfaceType(t)) { return {}; }\n\n  let ret: { [name: string]: spec.Property } = {};\n\n  if (t.interfaces) {\n    for (const iface of t.interfaces) {\n      ret = { ...ret, ...propertiesOf(lookup(iface), lookup) };\n    }\n  }\n  if (spec.isClassType(t) && t.base) {\n    ret = { ...ret, ...propertiesOf(lookup(t.base), lookup) };\n  }\n\n  for (const prop of t.properties || []) {\n    ret[prop.name] = prop;\n  }\n\n  return ret;\n}\n\nconst WIRE_TYPE_MAP = Symbol('$__jsii_wire_type__$');\n\n/**\n * Select the wire type for the given object and requested type\n *\n * Should return the most specific type that is in the JSII assembly and\n * assignable to the required type.\n *\n * We actually don't need to search much; because of prototypal constructor\n * linking, object.constructor.__jsii__ will have the FQN of the most specific\n * exported JSII class this object is an instance of.\n *\n * Either that's assignable to the requested type, in which case we return it,\n * or it's not, in which case there's a hidden class that implements the interface\n * and we just return the interface so the other side can instantiate an interface\n * proxy for it.\n *\n * Cache the analysis on the object to avoid having to do too many searches through\n * the type system for repeated accesses on the same object.\n */\nfunction selectWireType(obj: any, expectedType: spec.NamedTypeReference, lookup: TypeLookup): string {\n  const map = hiddenMap<string>(obj, WIRE_TYPE_MAP);\n\n  if (!(expectedType.fqn in map)) {\n    const jsiiType = jsiiTypeFqn(obj);\n    if (jsiiType) {\n      const assignable = isAssignable(jsiiType, expectedType, lookup);\n\n      // If we're not assignable and both types are class types, this cannot be satisfied.\n      if (!assignable && spec.isClassType(lookup(expectedType.fqn))) {\n        throw new Error(`Object of type ${jsiiType} is not convertible to ${expectedType.fqn}`);\n      }\n\n      map[expectedType.fqn] = assignable ? jsiiType : expectedType.fqn;\n    } else {\n      map[expectedType.fqn] = expectedType.fqn;\n    }\n  }\n\n  return map[expectedType.fqn];\n}\n\n/**\n * Tests whether a given type (by it's FQN) can be assigned to a named type reference.\n *\n * @param actualTypeFqn the FQN of the type that is being tested.\n * @param requiredType  the required reference type.\n *\n * @returns true if ``requiredType`` is a super-type (base class or implemented interface) of the type designated by\n *          ``actualTypeFqn``.\n */\nfunction isAssignable(actualTypeFqn: string, requiredType: spec.NamedTypeReference, lookup: TypeLookup): boolean {\n  // The empty object is assignable to everything\n  if (actualTypeFqn === EMPTY_OBJECT_FQN) { return true; }\n\n  if (requiredType.fqn === actualTypeFqn) {\n    return true;\n  }\n  const actualType = lookup(actualTypeFqn);\n  if (spec.isClassType(actualType)) {\n    if (actualType.base && isAssignable(actualType.base, requiredType, lookup)) {\n      return true;\n    }\n  }\n  if (spec.isClassOrInterfaceType(actualType) && actualType.interfaces) {\n    return actualType.interfaces.find(iface => isAssignable(iface, requiredType, lookup)) != null;\n  }\n  return false;\n}\n\nfunction validateRequiredProps(actualProps: {[key: string]: any}, typeName: string, specProps: {[key: string]: spec.Property}) {\n  // Check for required properties\n  const missingRequiredProps = Object.keys(specProps)\n      .filter(name => !specProps[name].optional)\n      .filter(name => !(name in actualProps));\n\n  if (missingRequiredProps.length > 0) {\n    throw new Error(`Missing required properties for ${typeName}: ${missingRequiredProps}`);\n  }\n\n  return actualProps;\n}\n","module.exports = require(\"module\");","import { SyncStdio } from './sync-stdio'\nimport { api } from 'jsii-kernel'\n\nexport type Output = \n    { hello: string } |\n    { ok: api.KernelResponse } | \n    { callback: api.Callback } |\n    { pending: true } |\n    { error: string, stack?: string };\n\nexport type Input = \n    { api: string } & api.KernelRequest |\n    { complete: api.CompleteRequest };\n\nexport class InputOutput {\n    debug = false\n\n    private readonly stdio = new SyncStdio();\n\n    write(obj: Output) {\n        const output = JSON.stringify(obj);\n        this.stdio.writeLine(output);\n\n        if (this.debug) {\n            this.stdio.writeErrorLine('< ' + output);\n        }\n    }\n    \n    read(): Input | undefined {\n        let reqLine = this.stdio.readLine();\n        if (!reqLine) {\n            return undefined;\n        }\n    \n        // skip recorded responses\n        if (reqLine.indexOf('< ') === 0) {\n            return this.read();\n        }\n    \n        // stip \"> \" from recorded requests\n        if (reqLine.indexOf('> ') === 0) {\n            reqLine = reqLine.substr(2);\n        }\n    \n        const input = JSON.parse(reqLine);\n\n        if (this.debug) {\n            this.stdio.writeErrorLine('> ' + JSON.stringify(input));\n        }\n\n        return input;\n    }\n}","import * as fs from 'fs'\n\nconst STDIN_FD = 0;\nconst STDOUT_FD = 1;\nconst STDERR_FD = 2;\nconst INPUT_BUFFER_SIZE = 1024 * 1024; // not related to max line length\n\nexport class SyncStdio {\n    private inputQueue = new Array<string>();\n    private currentLine = '';\n\n    writeErrorLine(line: string) {\n        this.writeBuffer(Buffer.from(`${line}\\n`), STDERR_FD);\n    }\n\n    writeLine(line: string) {\n        this.writeBuffer(Buffer.from(`${line}\\n`), STDOUT_FD);\n    }\n\n    readLine(): string | undefined {\n        if (this.inputQueue.length > 0) {\n            return this.inputQueue.shift();\n        }\n\n        const buff = Buffer.alloc(INPUT_BUFFER_SIZE);\n        const read = fs.readSync(STDIN_FD, buff, 0, buff.length, null);\n\n        if (read === 0) {\n            return undefined;\n        }\n\n        const str = buff.slice(0, read).toString();\n\n        for (let i = 0; i < str.length; ++i) {\n            const ch = str[i];\n\n            if (ch === '\\n') {\n                this.inputQueue.push(this.currentLine);\n                this.currentLine = '';\n            }\n            else {\n                this.currentLine += ch;\n            }\n        }\n\n        const next = this.inputQueue.shift();\n        if (next == null) {\n            return this.readLine();\n        }\n\n        return next;\n    }\n\n    private writeBuffer(buffer: Buffer, fd: number) {\n        let offset = 0;\n        while (offset < buffer.length) {\n            try {\n                offset += fs.writeSync(fd, buffer, offset);\n            } catch (e) {\n                if (e.code !== 'EAGAIN') { throw e; }\n            }\n        }\n    }\n}\n"],"sourceRoot":""}